//Created by KhanhNVTB in 06/2021

1. HELLO        Hello World
//Code:
#include<bits/stdc++.h>
using namespace std;

int main() {
    cout << "Hello PTIT.";
    return 0;
}
2. DSA06023	SẮP XẾP ĐỔI CHỖ TRỰC TIẾP
/*Hãy thực hiện thuật toán sắp xếp đổi chỗ trực tiếp trên dãy N số nguyên. Ghi ra các bước thực hiện thuật toán. Dữ liệu
vào: Dòng 1 ghi số N (không quá 100). Dòng 2 ghi N số nguyên dương (không quá 100). Kết quả: Ghi ra màn hình từng bước
thực hiện thuật toán. Mỗi bước trên một dòng, các số trong dãy cách nhau đúng một khoảng trống.
Input                Output
4                    Buoc 1: 2 7 5 3
5 7 3 2              Buoc 2: 2 3 7 5
                     Buoc 3: 2 3 5 7
*/
//Ý tưởng: Bắt đầu từ từng vị trí tìm tất cả các số đằng sau nó nêu nhỏ hơn số hiện tại thì đổi chỗ 2 số đó
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, a[105], cnt=0;

void init() { //hàm khởi tạo
    cin >> n; 
    for (int i = 0; i < n; i++) cin >> a[i];
}

void print() { //hàm in ra kết quả của bước hiện tại
    cout << "Buoc " << count << ": ";
    for (int i = 0; i < n; i++) cout << a[i] << " ";
    cout << endl;
}

void solve() {
    for (int i = 0; i < n - 1; i++) {
        cnt++; //tăng đếm đến bước hiện tại
        for (int j = i + 1; j < n; j++) {
            if (a[i] > a[j]) swap (a[i], a[j]); //phát hiện phần tử nhỏ hơn thực hiện đổi chỗ
        }
        print (); //in ra kết quả hiện tại
    }
}

int main() {
    init ();
    solve ();
    return 0;
}
3. DSA06024	SẮP XẾP CHỌN
/*Hãy thực hiện thuật toán sắp xếp chọn trên dãy N số nguyên. Ghi ra các bước thực hiện thuật toán.
Dữ liệu vào: Dòng 1 ghi số N (không quá 100). Dòng 2 ghi N số nguyên dương (không quá 100).
Kết quả: Ghi ra màn hình từng bước thực hiện thuật toán. Mỗi bước trên một dòng, các số trong dãy cách nhau đúng một
khoảng trống.
Input                Output
4                    Buoc 1: 2 7 3 5
5 7 3 2              Buoc 2: 2 3 7 5
                     Buoc 3: 2 3 5 7
*/
/*Ý tưởng: duyệt qua tất cả các phần tử. Với mỗi phần tử tìm trong các phần tử sau nó phần tử nào là nhỏ nhất thì thực
hiện đổi chỗ*/
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, a[105], cnt=0;

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void print() { //hàm in ra kết quả của bước hiện tại
    cout << "Buoc " << cnt << ": ";
    for (int i = 0; i < n; i++) cout << a[i] << " ";
    cout << endl;
}
void selectionSort() {
    int i, j, min_idx;
    for (i = 0; i < n - 1; i++) {
        cnt++; //tăng đếm đến bước hiện tại
        min_idx = i; //đánh dấu chỉ mục hiện tại
        for (j = i + 1; j < n; j++) //tìm tất cả các số sau chỉ mục hiện tại
            if (a[j] < a[min_idx]) //tìm ra phần tử nhỏ nhất
                min_idx = j;
        swap (a[min_idx], a[i]); //đổi chỗ với phần tử phần tử ở chỉ mục hiện tại
    }
}

int main() {
    init ();
    selectionSort ();
    return 0;
}
4. DSA06025	SẮP XẾP CHÈN
/*Hãy thực hiện thuật toán sắp xếp chèn trên dãy N số nguyên. Ghi ra các bước thực hiện thuật toán.
Dữ liệu vào: Dòng 1 ghi số N (không quá 100). Dòng 2 ghi N số nguyên dương (không quá 100).
Kết quả: Ghi ra màn hình từng bước thực hiện thuật toán. Mỗi bước trên một dòng, các số trong dãy cách nhau đúng một
khoảng trống.
Input                Output
4                    Buoc 0: 5
5 7 3 2              Buoc 1: 5 7
                     Buoc 2: 3 5 7
                     Buoc 3: 2 3 5 7
*/
/*Ý tưởng: Duyệt qua tất cả phần tử. Với mỗi phần tử tìm kiếm ở trước nó nếu còn phần tử lớn hơn nó thì chèn nó lên
trước phần tử đó.*/
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, a[105], cnt=0;

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void print() { //hàm in ra kết quả của bước hiện tại
    cout << "Buoc " << cnt << ": ";
    for (int i = 0; i <= cnt; i++) cout << a[i] << " ";
    cout << endl;
}

void insertionSort() {
    int i, key, j;
    print (); //in ra kết quả
    for (i = 1; i < n; i++) {
        key = a[i]; //gán key là chỉ mục hiện tại
        j = i - 1; //gán j là chỉ mục của phần tử đầu tiên đứng trước phần tử tại key
        while (j >= 0 && a[j] > key) { //tìm phần tử lớn hơn phần tử tại key
            a[j + 1] = a[j]; //dịch các phần tử sang phải 1 đơn vị
            j--;
        }
        a[j + 1] = key; // thực hiện chèn
        cnt++;
    }
}

int main() {
    init ();
    insertionSort ();
    return 0;
}
5. DSA06026	SẮP XẾP NỔI BỌT
/*Hãy thực hiện thuật toán sắp xếp nổi bọt trên dãy N số nguyên. Ghi ra các bước thực hiện thuật toán.
Dữ liệu vào: Dòng 1 ghi số N (không quá 100). Dòng 2 ghi N số nguyên dương (không quá 100).
Kết quả: Ghi ra màn hình từng bước thực hiện thuật toán. Mỗi bước trên một dòng, các số trong dãy cách nhau đúng một
khoảng trống.
Input                Output
4                    Buoc 1: 3 2 5 7
5 3 2 7              Buoc 2: 2 3 5 7
*/
//Ý tưởng: So sánh hai phần tử kề nhau, nếu chúng chưa đứng đúng thứ tự thì đổi chỗ
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, a[105], cnt=0;

void init() {
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void print() { //hàm in kết quả hiện tại
    cout << "Buoc " << cnt << ": ";
    for (int i = 0; i < n; i++) cout << a[i] << " ";
    cout << endl;
}

void bubbleSort() {
    bool check = false;
    for (int i = 0; i < n - 1; i++) {
        if (cnt > 0) print (); //nếu tìm được kết quả thực hiện in
        check = false; //đánh dấu mảng đã được sắp xếp
        for (int j = 0; j < n - i - 1; j++) {
            if (a[j] > a[j + 1]) { //nếu đứng sai thứ tự thực hiện đổi chỗ
                swap (a[j], a[j + 1]);
                check = true; // đánh dấu mảng chưa được sắp xếp
            }
        }
        cnt++;
        if (check == false) break; //nếu mảng đã được sắp xếp thì dừng lại
    }
}

int main() {
    init ();
    bubbleSort (a, n, count);
    return 0;
}
6. DSA07021	DÃY NGOẶC ĐÚNG DÀI NHẤT
/*Cho một xâu chỉ gồm các kí tự ‘(‘ và ‘)’. Một dãy ngoặc đúng được định nghĩa như sau:
- Xâu rỗng là 1 dãy ngoặc đúng.
- Nếu A là 1 dãy ngoặc đúng thì (A) là 1 dãy ngoặc đúng.
- Nếu A và B là 2 dãy ngoặc đúng thì AB là 1 dãy ngoặc đúng.
Cho một xâu S. Nhiệm vụ của bạn là hãy tìm dãy ngoặc đúng dài nhất xuất hiện trong xâu đã cho.
Input: Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test gồm một xâu S có độ dài không vượt quá 105 kí tự.
Output:  Với mỗi test in ra một số nguyên là độ dài dãy ngoặc đúng dài nhất tìm được.
Input                Output
3
((()                 2
)()())               4
()(()))))            6
*/
/*Ý tưởng: Đánh dấu chỉ mục của dấu '(' đầu tiên trong cặp ngoặc còn lại sau nó tìm chỉ mục của dấu ')' cuối cùng tương
ứng và so sánh kết quả hiện tại với khoảng cách đó*/
//Code:

#include<bits/stdc++.h>
using namespace std;

string str;
int res;

void init(){ //hàm khởi tạo
    cin>>str;
}

void solve() { //hàm sử lý
    res = 0; //khởi tạo res=0
    stack <int> s; //khởi tạo stack
    s.push (-1); //đẩy -1 vào stack do chỉ mục của chuỗi bắt đầu từ 0
    for (int i = 0; i < str.length (); i++) {
        if (str[i] == '(') s.push (i); //đưa chỉ mục của dấu '(' vào stack
        else {
            s.pop (); //xoá phần tử ở đỉnh của stack tương ứng với dấu '('
            if (!s.empty) res = max (res, i - s.top ()); //nếu stack không rỗng so sánh khoảng cách với kết quả hiện tại
            else s.push (i); //nếu stack rỗng đưa chỉ mục hiện tại vào stack
        }
    }
    cout << res << endl;//in ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
7. 7	DSA09001	CHUYỂN DANH SÁCH CẠNH SANG DANH SÁCH KỀ
/*Cho đồ thị vô hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy viết chương trình thực hiện chuyển đổi biểu
diễn đồ thị dưới dạng danh sách kề.
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm |E| +1 dòng: dòng đầu tiên đưa vào hai số |V|, |E| tương ứng
với số đỉnh và số cạnh của đồ thị; |E| dòng tiếp theo đưa vào các bộ đôi uÎV, vÎV tương ứng với một cạnh của đồ thị.
T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤200; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra danh sách kề của các đỉnh tương ứng theo khuôn dạng của ví dụ dưới đây. Các đỉnh trong danh sách in ra theo thứ
tự tăng dần.
Input                Output
1
6 9                 1: 2 3
1 2                 2: 1 3 5
1 3                 3: 1 2 4 5
2 3                 4: 3 5 6
2 5                 5: 2 3 4 6
3 4                 6: 4 5
3 5
4 5
4 6
5 6
*/
//Ý tưởng: gặp cạnh nào thì thêm vào danh sách kề tương ứng.
//Code:

#include<bits/stdc++.h>
using namespace std;

int v, e;
vector <int> adjacent[1005];

void init() { //hàm khởi tạo
    cin >> v >> e;
    int i, j;
    while (e--) {
        cin >> i >> j;
        adjacent[i].push_back (j); //tạo ma trận kề
        adjacent[j].push_back (i); 
    }
}

void solve() { //hàm xử lý
    for (int i = 1; i <= v; i++) {
        cout << i << ": "; //in ra kết quả
        for (int j = 0; j < adjacent[i].size (); j++) cout << adjacent[i][j] << " ";
        cout << endl;
        adjacent[i].clear (); //xoá ma trận kề
    }
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
8. DSA09002	CHUYỂN TỪ DANH SÁCH KỀ SANG DANH SÁCH CẠNH
/*Cho đơn đồ thị G vô hướng liên thông được mô tả bởi danh sách kề. Hãy in ra danh sách cạnh tương ứng của G.
Input: Dòng đầu tiên ghi số N là số đỉnh (1<N<50)
N dòng tiếp theo mỗi dòng ghi 1 danh sách kề lần lượt theo thứ tự từ đỉnh 1 đến đỉnh N
Output: Ghi ra lần lượt từng cạnh của đồ thị theo thứ tự tăng dần.
Input                Output
3
2 3                  1 2
1 3                  1 3
1 2                  2 3
*/
//Ý tưởng: Với mỗi đỉnh kề nếu lớn hơn đỉnh hiện tại thì tạo cạnh kề tương ứng
//Code:

#include<bits/stdc++.h>
using namespace std;

int v;
vector <int> a;

void init() {
    cin >> v;
    cin.ignore ();
    int i;
    for (int i = 1; i <= v; i++) {
        string str;
        getline (cin, str); //nhập vào các đỉnh kề
        int x = 0;
        for (int j = 0; j < str.length (); j++) {
            if (str[j] != ' ') x = x * 10 + (int) (str[j] - '0'); //chuyển đỉnh kề sang kiểu int
            else {
                if (x > i) { //tạo ma trận kề
                    a.push_back (i);
                    a.push_back (x);
                }
                x = 0;
            }
        }
        if (x > i) {
            a.push_back (i); //tạo ma trận kề
            a.push_back (x);
        }
    }
}

void print() { //hàm in ra kết quả
    for (int i = 0; i < a.size (); i += 2) cout << a[i] << " " << a[i + 1] << endl;
}

int main() {
    init ();
    print ();
    return 0;
}
9. DSA09003	BIỂU DIỄN ĐỒ THỊ CÓ HƯỚNG.
/*Cho đồ thị có hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy viết chương trình thực hiện chuyển đổi biểu
diễn đồ thị dưới dạng danh sách kề.
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm |E| +1 dòng: dòng đầu tiên đưa vào hai số |V|, |E| tương ứng
với số đỉnh và số cạnh của đồ thị; |E| dòng tiếp theo đưa vào các bộ đôi uÎV, vÎV tương ứng với một cạnh của đồ thị.
T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤200; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra danh sách kề của các đỉnh tương ứng theo khuôn dạng của ví dụ dưới đây. Các đỉnh trong danh sách in ra theo thứ
tự tăng dần.
Input                Output
1
6 9                  1: 2
1 2                  2: 5                                          
2 5                  3: 1 2 5
3 1                  4: 3
3 2                  5: 4 6
3 5                  6: 4
4 3
5 4
5 6
6 4
*/
//Ý tưởng: gặp cạnh nào thì thêm vào danh sách kề tương ứng.
//Code:

#include<bits/stdc++.h>
using namespace std;

int v, e;
vector <int> adjacent[1005];

void init() { //hàm khởi tạo
    cin >> v >> e;
    int i, j;
    while (e--) {
        cin >> i >> j;
        adjacent[i].push_back (j); //tạo ma trận kề
    }
}

void solve() { //hàm xử lý
    for (int i = 1; i <= v; i++) {
        cout << i << ": "; //in ra kết quả
        for (int j = 0; j < adjacent[i].size (); j++) cout << adjacent[i][j] << " ";
        cout << endl;
        adjacent[i].clear (); //xoá ma trận kề
    }
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
10. DSA09004	DFS TRÊN ĐỒ THỊ VÔ HƯỚNG
/*Cho đồ thị vô hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy viết thuật toán duyệt theo chiều sâu bắt đầu
tại đỉnh uÎV (DFS(u)=?)
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm |E| +1 dòng: dòng đầu tiên đưa vào ba số |V|, |E| tương ứng
với số đỉnh và số cạnh của đồ thị, và u là đỉnh xuất phát; |E| dòng tiếp theo đưa vào các bộ đôi uÎV, vÎV tương ứng với
một cạnh của đồ thị.
T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤200; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra danh sách các đỉnh được duyệt theo thuật toán DFS(u) của mỗi test theo khuôn dạng của ví dụ dưới đây.
Input                 Output
1
6 9 5                 5 3 1 2 4 6
1 2
1 3
2 3
2 4
3 4
3 5
4 5
4 6
5 6
*/
//Ý tưởng: thực hiện thuật toán dfs được học ở môn toán rời rạc 2
//Code:

#include <bits/stdc++.h>
using namespace std;
int v, e, first, vs[1005];
vector <int> adjacent[1005];

void init() { //hàm khởi tạo
    cin >> v >> e >> first;
    int i, j;
    while (e--) {
        cin >> i >> j;
        adjacent[i].push_back (j); //tạo ma trận kề
        adjacent[j].push_back (i);
    }
}

void dfs(int u) { //hàm dfs
    cout << u << " "; //in đỉnh hiện tại
    vs[u] = 1; //đánh dấu đã thăm
    for (int i = 0; i < adjacent[u].size (); i++) {
        int tmp = adjacent[u][i];
        if (!vs[tmp]) dfs (tmp); //nếu chưa được thăm gọi dfs tại đỉnh đó
    }
}

void solve() { //hàm xử lý
    memset (vs, 0, sizeof (vs)); //đánh dấu tất cả chưa được thăm
    dfs (first); //duyệt dfs từ đỉnh đầu vào
    for (int i = 1; i <= v; i++) adjacent[i].clear (); //xoá ma trận kề
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
11. DSA01001	XÂU NHỊ PHÂN KẾ TIẾP
/*Cho xâu nhị phân X[], nhiệm vụ của bạn là hãy đưa ra xâu nhị phân tiếp theo của X[]. Ví dụ X[] =”010101” thì xâu nhị
phân tiếp theo của X[] là “010110”.
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một xâu nhi phân X.
T, X[] thỏa mãn ràng buộc: 1≤T≤100; 1≤length(X)≤10^3.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
010101               010110
111111               000000
*/
//Ý tưởng: Duyệt từ cuối lên gặp phần tử 0 đầu tiên thay thê nó bằng 1 rồi đặt tất cả các phần tử sau nó thành 0
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, check, a[1005];
string str;

void init() { //hàm khởi tạo
    cin >> str;
    n = str.length (); //gán n là chiều dài của xâu
}

void solve() { //hàm xử lý
    check = -1; //biến kiểm tra
    //duyệt từ cuối mảng đến phần tử 0 đầu tiên thì gán lại bằng 1 sau đó gán tất cả phần tử phía sau bằng 0
    for (int i = n - 1; i >= 0; i--) {
        if (str[i] == '0') {
            str[i] = '1'; //thay đổi thành 1
            check = i; //thay đổi biến kiểm tra
            for (int j = check + 1; j < n; j++) str[j] = '0'; //gán các phần tử sau nó bằng 0
            break;
        }
    }
    //nếu là câu hình cuối cùng thì in ra cấu hình đầu tiên nếu không phải thì in ra cấu hình vừa tạo thành
    if (check == -1) for (int i = 0; i < n; i++) cout << "0";
    else for (int i = 0; i < n; i++) cout << str[i];
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
12. DSA01002	TẬP CON KẾ TIẾP
/*Cho hai số N, K và một tập con K phần tử X[] =(X1, X2,.., XK) của 1, 2, .., N. Nhiệm vụ của bạn là hãy đưa ra tập con K phần tử tiếp theo của X[]. Ví dụ N=5, K=3, X[] ={2, 3, 4} thì tập con tiếp theo của X[] là {2, 3, 5}.

Input:

Dòng đầu tiên đưa vào số lượng test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất là hai số N và K; dòng tiếp theo đưa vào K phần tử của X[] là một tập con K phần tử của 1, 2, .., N.
T, K, N, X[] thỏa mãn ràng buộc: 1≤T≤100; 1≤K≤N≤103.
Output:

Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
5  3
1  4  5              2 3 4
5  3
3  4  5              1 2 3
*/
//Ý tưởng: Duyệt từ cuối lên tìm phần tử khác n-k+i cộng nó lên 1 sau đó thay các phần tử sau nó thành a[i]+j-i
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, k, check, a[1005];

void init() { //hàm khởi tạo
    cin >> n >> k;
    for (int i = 1; i <= k; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    int check = 0;
    for (int i = k; i > 0; i--) {
        if (a[i] != n - k + i) { //tìm phần tử đầu tiên khác n-k+i
            a[i] = a[i] + 1; //tăng nó lên 1
            for (int j = i + 1; j <= k; j++) a[j] = a[i] + j - i; //gán lại các phần tử sau nó
            check = 1; //đánh dấu đã tìm được cấu hình tiếp theo
            break;
        }
    }
    if (!check) for (int i = 0; i < k; i++) cout << i + 1 << " "; //nếu là cấu hình cuối cùng in ra cấu hình đầu tiên
    else for (int i = 1; i <= k; i++) cout << a[i] << " "; //in ra cấu hình tiếp theo
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
13. DSA01003	HOÁN VỊ KẾ TIẾP
/*Cho số tự nhiên N và một hoán vị X[] của 1, 2, .., N. Nhiệm vụ của bạn là đưa ra hoán vị tiếp theo của X[]. Ví dụ N=5,
X[] = {1, 2, 3, 4, 5} thì hoán vị tiếp theo của X[] là {1, 2, 3, 5, 4}.
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất là số N; dòng tiếp theo đưa vào hoán vị
X[] của 1, 2, .., N.
T, N, X[] thỏa mãn ràng buộc: 1≤T≤100; 1≤ N≤10^3.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
5
1  2  3  4  5        1 2  3  5  4
5
5  4  3  2  1        1 2  3  4  5
*/
/*Ý tưởng: Duyệt từ cuối lên tìm phần tử đầu tiên nhỏ hơn phần tử sau nó. Sau đó tìm đằng sau nó phần tử nhỏ nhất còn
lớn hơn nó sau đó đổi chỗ 2 phần tử. Tiếp tục thực hiện lật đoạn phần tử từ sau phần tử tìm được đến cuối. */
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, a[1005];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    int k = -1;
    for (int i = n - 1; i >= 0; i--) {
        if (a[i] > a[i - 1]) { //tìm phần tử đầu tiên mà nhỏ hơn phần tử đứng sau nó
            k = i - 1;
            for (int j = n - 1; j >= k; j--) { //tìm phần tử nhỏ nhất còn lớn hơn a[k] và thực hiện đổi chỗ
                if (a[j] > a[k]) {
                    swap (a[i], a[k]);
                    break;
                }
            }
            int l = k + 1;
            int r = n - 1;
            while (l < r) { //lật ngược đoạn từ k+1 đến cuối
                swap (a[l], a[r]);
                l++;
                r--;
            }
            break;
        }
    }
    if (k == -1) for (int i = 0; i < n; i++) cout << i + 1 << " "; //nếu là cấu hình cuối cùng in ra cấu hình đầu tiên
    else for (int i = 0; i < n; i++) cout << a[i] << " "; //in ra cấu hình tìm được
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
14. DSA01007	XÂU AB CÓ ĐỘ DÀI N
/*Xâu ký tự str được gọi là xâu AB nếu mỗi ký tự trong xâu hoặc là ký tự ‘A’ hoặc là ký tự ‘B’. Ví dụ xâu str=”ABBABB”
 là xâu AB độ dài 6. Nhiệm vụ của bạn là hãy liệt kê tất cả các xâu AB có độ dài n.
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một số tự nhiên n.
T, n thỏa mãn ràng buộc: 1≤T≤10; 1≤n≤10.
Output:
Đưa ra kết quả mỗi test theo từng dòng. Mỗi xâu cách nhau 1 khoảng trống.
Input                Output
2
2                    AA AB BA BB
3                    AAA AAB ABA ABB BAA BAB BBA BBB
*/
//Ý tưởng: Thực hiện giống sinh xâu nhị phân với A ứng với 0 và B ứng với 1
//Code:

#include<bits/stdc++.h>
using namespace std;

int n;
char a[10];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) a[i] = 'A';
}

void print() { //hàm in cấu hình
    for (int i = 0; i < n; i++) cout << a[i];
    cout << " ";
}

void solve() { //hàm xử lý
    print (); //in ra cấu hình đầu tiên
    for (int i = n - 1; i >= 0; i--) { //tìm phần tử A đầu tiên từ cuối lên 
        if (a[i] == 'A') {
            a[i] = 'B'; //thay A bằng B
            for (int j = i + 1; j < n; j++) a[j] = 'A'; //gán tất cả phần tử sau A là A
            print (); //in ra kết quả
            i = n ; //gán lại i=n để thực hiện tìm lại từ cuối lên
        }
    }
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
15. DSA01004	SINH TỔ HỢP
/*Cho hai số nguyên dương N và K. Nhiệm vụ của bạn là hãy liệt kê tất cả các tập con K phần tử của 1, 2, .., N. Ví dụ
với N=5, K=3 ta có 10 tập con của 1, 2, 3, 4, 5 như sau: {1, 2, 3}, {1, 2, 4},{1, 2, 5},{1, 3, 4},{1, 3, 5},{1, 4, 5},
{2, 3, 4},{2, 3, 5},{2, 4, 5},{3, 4, 5}.
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một cặp số tự nhiên N, K được viết trên một dòng.
T, n thỏa mãn ràng buộc: 1≤T≤100; 1≤k ≤ n≤15.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
2                   
4 3                   123 124 134 234
5 3                   123 124 125 134 135 145 234 235 245 345 
*/
//Ý tưởng: Duyệt từ cuối lên tìm phần tử khác n-k+i cộng nó lên 1 sau đó thay các phần tử sau nó thành a[i]+j-i
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, k, a[20];

void init() { //hàm khởi tạo
    cin >> n >> k;
    for (int i = 1; i <= k; i++) a[i] = i;
}

void print() { //hàm in cấu hình
    for (int i = 1; i <= k; i++) cout << a[i];
    cout << " ";
}

void solve() { //hàm xử lý
    print (); //in ra cấu hình đầu tiên
    for (int i = k; i > 0; i--) {
        if (a[i] != n - k + i) { //tìm phần tử đầu tiên khác n-k+i
            a[i] = a[i] + 1; //tăng nó lên 1
            for (int j = i + 1; j <= k; j++) a[j] = a[i] + j - i; //gán lại các phần tử sau nó
            print (); //in ra cấu hình
            i = k + 1; //đặt lại i=k+1 để duyệt lại từ cuối lên
        }
    }
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
16. DSA01005	SINH HOÁN VỊ
/*Cho số nguyên dương N. Nhiệm vụ của bạn là hãy liệt kê tất cả các hoán vị của 1, 2, .., N. Ví dụ với N = 3 ta có kết
quả: 123, 132, 213, 231, 312, 321.
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một số tự nhiên N được viết trên một dòng.
T, n thỏa mãn ràng buộc: 1≤T, N≤10.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input               Output
2
2                   12 21
3                   123 132 213 231 312 321
*/
/*Ý tưởng: Duyệt từ cuối lên tìm phần tử đầu tiên nhỏ hơn phần tử sau nó. Sau đó tìm đằng sau nó phần tử nhỏ nhất còn
lớn hơn nó sau đó đổi chỗ 2 phần tử. Tiếp tục thực hiện lật đoạn phần tử từ sau phần tử tìm được đến cuối. */
//Code:

#include<bits/stdc++.h>
using namespace std;
int n, a[10];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) a[i] = i+1;
}

void print() { //hàm in cấu hình
    for (int i = 0; i < n; i++) cout << a[i];
    cout << " ";
}

void solve() { //hàm xử lý
    print (); //in cấu hình đầu tiên
    for (int i = n - 1; i > 0; i--) {
        if (a[i] > a[i - 1]) { //tìm phần tử đầu tiên nhỏ hơn phần tử sau nó
            for (int j = n - 1; j >= i - 1; j--) { //tìm phần tử nhỏ nhất còn lớn hơn a[i-1] và thực hiện đổi chỗ
                if (a[j] > a[i - 1]) {
                    swap (a[i - 1], a[j]);
                    break;
                }
            }
            int l = i;
            int r = n - 1;
            while (l < r) { //lật ngược đoạn từ i đến cuối
                swap (a[l], a[r]);
                l++;
                r--;
            }
            print (); //in ra cấu hình
            i = n; //gán lại i=n để duyệt lại từ đầu
        }
    }
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
17. DSA01006	HOÁN VỊ NGƯỢC
/*Cho số nguyên dương N. Nhiệm vụ của bạn là hãy liệt kê tất cả các hoán vị ngược của 1, 2, .., N. Ví dụ với N = 3 ta có
kết quả: 321, 312, 231, 213, 132, 123.
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một số tự nhiên N được viết trên một dòng.
T, n thỏa mãn ràng buộc: 1≤T, N≤10.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input               Output
2
2                   21 12
3                   321 312 231 213 132 123
*/
/*Ý tưởng: Duyệt từ cuối lên tìm phần tử đầu tiên lớn hơn phần tử trước nó. Sau đó tìm đằng sau nó phần tử lớn nhất còn
nhỏ hơn nó sau đó đổi chỗ 2 phần tử. Tiếp tục thực hiện lật đoạn phần tử từ trước phần tử tìm được đến đầu. */
//Code:

#include<bits/stdc++.h>
using namespace std;
int n, a[10];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) a[i] = n - i;
}

void print() { //hàm in cấu hình
    for (int i = 0; i < n; i++) cout << a[i];
    cout << " ";
}

void solve() { //hàm xử lý
    print (); //in cấu hình đầu tiên
    for (int i = n - 1; i > 0; i--) {
        if (a[i] < a[i - 1]) { //tìm phần tử đầu tiên nhỏ hơn phần tử sau nó
            for (int j = n - 1; j >= i - 1; j--) { //tìm phần tử nhỏ nhất còn lớn hơn a[i-1] và thực hiện đổi chỗ
                if (a[j] < a[i - 1]) {
                    swap (a[i - 1], a[j]);
                    break;
                }
            }
            int l = i;
            int r = n - 1;
            while (l < r) { //lật ngược đoạn từ i đến cuối
                swap (a[l], a[r]);
                l++;
                r--;
            }
            print (); //in ra cấu hình
            i = n; //gán lại i=n để duyệt lại từ đầu
        }
    }
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
18. /*Hãy in ra tất cả các xâu nhị phân độ dài N, có K bit 1 theo thứ tự từ điển tăng dần.
Input: Dòng đầu tiên là số lượng bộ test T (T ≤ 20). Mỗi test gồm 2 số nguyên N, K (1 ≤ K ≤ N ≤ 16).
Output:  Với mỗi test, in ra đáp án tìm được, mỗi xâu in ra trên một dòng.
Input                  Output
2
4 2                    0011
                       0101
                       0110
                       1001
                       1010
                       1100
3 2                    011
                       101
                       110
*/
//Ý tưởng: Sinh ra các xâu nhị phân sau đó kiểm tra xem nó có đúng k bit 1 không. Nếu đúng thực hiện in
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, k, a[20];

void init() { //hàm khởi tạo
    cin >> n >> k;
    for (int i = 0; i < n; i++) a[i] = 0;
}

int check() { //hàm kiểm tra xâu có bao nhiêu bit 1
    int cnt = 0;
    for (int i = 0; i < n; i++) if (a[i] == 1) cnt++;
    return cnt;
}

void print() { //hàm in cấu hình
    for (int i = 0; i < n; i++) cout << a[i];
    cout << endl;
}

void solve() {
    if (check () == k) print (); //kiểm tra cấu hình đầu tiên
    for (int i = n - 1; i >= 0; i--) { //sinh ra các cấu hình kế tiếp
        if (a[i] == 0) {
            a[i] = 1;
            for (int j = i + 1; j < n; j++) a[j] = 0;
            if (check () == k) print (); //kiểm tra cấu hình hiện tại
            i = n;
        }
    }
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
19. DSA02001	DÃY SỐ 1
/*Cho dãy số A[] gồm n số nguyên dương. Tam giác đặc biệt của dãy số A[] là tam giác được tạo ra bởi n hàng, trong đó
hàng thứ 1 là dãy số A[], hàng i là tổng hai phần tử liên tiếp của hàng i-1 (2≤i≤n). Ví dụ A[] = {1, 2, 3, 4, 5}, khi đó
tam giác được tạo nên như dưới đây:
[1, 2, 3, 4, 5 ]
[3, 5, 7, 9 ]
[8, 12, 16]
[20, 28]
[48]
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất đưa vào N là số lượng phần tử của dãy
số A[]; dòng tiếp theo đưa vào N số của mảng A[].
T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100; 1≤N, A[i] ≤10;
Output:
Đưa ra tam giác tổng của mỗi test theo từng dòng. Mỗi dòng của tam giác tổng được bao bởi ký tự [, ].
Input                 Output
1
5                     [1, 2, 3, 4, 5 ]
1 2 3 4 5             [3, 5, 7, 9 ]
                      [8, 12, 16]
                      [20, 28]
                      [48]
*/
//Ý tưởng: Thực hiện hàm quay lui sau đó cập nhật giá trị của mảng theo quy luật
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, a[10];

void init(){ //hàm khởi tạo
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
}

void print(int i) { //hàm in kết quả
    cout << '[';
    for (int j = 0; j < i; j++) cout << a[j] << " ";
    cout << a[i] << ']' << endl;
}

void Try(int i) {
    print (i); //in ra kết quả hiện tại
    for (int j = 0; j < i; j++) a[j] += a[j + 1]; //cập nhật giá trị mới
    if (i > 0) Try (i - 1); //nếu chưa phải kết quả cuối cùng gọi đệ quy lại
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        Try (n - 1);
    }
    return 0;
}
20. 	DSA02002	DÃY SỐ 2
/*Cho dãy số A[] gồm n số nguyên dương. Tam giác đặc biệt của dãy số A[] là tam giác được tạo ra bởi n hàng, trong đó hàng
thứ n là dãy số A[], hàng i là tổng hai phần tử liên tiếp của hàng i+1 (1≤i≤n-1). Ví dụ A[] = {1, 2, 3, 4, 5}, khi đó
tam giác được tạo nên như dưới đây:
[48]
[20, 28]
[8, 12, 16]
[3, 5, 7, 9 ]
[1, 2, 3, 4, 5 ]
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất đưa vào N là số lượng phần tử của dãy
số A[]; dòng tiếp theo đưa vào N số của mảng A[].
T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100; 1≤N, A[i] ≤10;
Output:
Đưa ra kết quả mỗi test theo từng dòng. Mỗi dòng của tam giác tổng được bao bởi ký tự [, ].
Input                 Output
1
5                     [48] [20 28] [8 12 16] [3 5 7 9] [1 2 3 4 5]
1 2 3 4 5
*/
//Ý tưởng: Đưa các kết quả vào 1 vector sau đó in
#include <bits/stdc++.h>
using namespace std;

int n, a[10];
vector <int> res;

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void print() { //hàm in kết quả
    int cnt = 1; //biến đếm chỉ số phần tử của kết quả hiện tại
    for (int i = 1; i <= n; i++) {
        cout << '[';
        int begin = res.size () - cnt; //vị trí bắt đầu của kêt quả hiện tại
        int end = res.size () - cnt + i - 1; //vị trí kết thúc của kết quả hiện tại
        for (int j = begin; j < end; j++) cout << res[j] << " "; //in ra kết quả
        cout << res[end] << ']' << " ";
        cnt = cnt + i + 1; //cập nhật số phần tử của kết quả sau
    }
    cout << endl;
    res.clear (); //làm mới vector
}

void Try(int i) { //hàm quay lui
    for (int j = 0; j <= i; j++) res.push_back (a[j]); //đẩy kết quả vào vector
    for (int j = 0; j < i; j++) a[j] += a[j + 1]; //tạo kết quả mới
    if (i > 0) Try (i - 1); //nếu chưa phải kết quả cuối cùng gọi hàm đệ quy
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        Try (n - 1);
        print ();
    }
    return 0;
}
21. DSA02005	HOÁN VỊ XÂU KÝ TỰ
/*Cho xâu ký tự S bao gồm các ký tự in hoa khác nhau. Hãy đưa ra tất cả các hoán vị của xâu ký tự S. Ví dụ S=”ABC” ta có
kết quả {ABC ACB BAC BCA CAB CBA}.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test là một xâu ký tự S được viết trên 1 dòng.
T, S thỏa mãn ràng buộc: 1≤T≤10; 1≤length(S) ≤10;
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
2
AB                    AB BA
ABC                   ABC ACB BAC BCA CAB CBA
*/
/*Ý tưởng: tạo 1 mảng đánh dấu các chỉ mục của xâu ban đầu. Thực hiện sinh hoán vị của các chỉ mục sau đó in ra ký tự
tương ứng với chỉ mục đó*/
//Code:

#include <bits/stdc++.h>
using namespace std;

string str;
bool used[10];
int a[10];

void init() { //hàm khởi tạo
    cin >> str;
}

void print() { //hàm in kết quả
    for (int i = 0; i < str.length (); i++) cout << str[a[i]]; //in ra ký tự tương ứng với chỉ mục hiện tại
    cout << " ";
}

void Try(int i) { //hàm quay lui
    for (int j = 0; j < str.length (); j++) {
        if (!used[j]) { //nếu tìm thấy chỉ mục chưa sử dụng
            a[i] = j; //gán a[i] bằng chỉ mục đó
            used[j] = 1; //đánh dấu  đã sử dụng
            if (i == str.length () - 1) print (); //nếu đã duyệt đủ ký tự đưa ra kết quả
            else Try (i + 1); //nếu chưa duyệt hết tiếp tục gọi hàm đệ quy
            used[j] = 0; //đánh dấu lại chỉ mục chưa được sử dụng
        }
    }
}

void solve() { //hàm xử lý
    memset (used, 0, sizeof (used)); //gán tất cả chỉ mục chưa được sử dụng
    for (int i = 0; i < str.length (); i++) a[i] = i; //gán chỉ mục cho mảng a
    Try (0); //gọi hàm quay lui
    cout << endl;
}

int  main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
22. DSA02003	DI CHUYỂN TRONG MÊ CUNG 1
/*Cho một mê cung bao gồm các khối được biểu diễn như một ma trận nhị phân A[N][N]. Một con chuột đi từ ô đầu tiên góc
trái (A[0][0]) đến ô cuối cùng góc phải (A[N-1][N-1]) theo nguyên tắc:
Down (D): Chuột được phép xuống dưới nếu ô dưới nó có giá trị 1.
Right (R): Chuột được phép sang phải dưới nếu ô bên phải nó có giá trị 1.
Hãy đưa ra một hành trình của con chuột trên mê cung. Đưa ra -1 nếu chuột không thể đi đến đích.
https://www.geeksforgeeks.org/wp-content/uploads/ratinmaze_filled_path1.png
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất đưa vào số N là kích cỡ của mê cung;
dòng tiếp theo đưa vào ma trận nhị phân A[N][N].
T, N, A[i][j] thỏa mãn ràng buộc: 1≤T ≤10; 2≤N≤10; 0≤A[i][j] ≤1.
Output:
Đưa ra tất cả đường đi của con chuột trong mê cung theo thứ tự từ điển. Đưa ra -1 nếu chuột không đi được đến đích.
Input                Output
2
4                    DRDDRR
1  0  0  0
1  1  0  1
0  1  0  0
1  1  1  1
5                    DDRDRRDR DDRDRRRD DRDDRRDR DRDDRRRD DRRRRDDD
1 0 0 0 0
1 1 1 1 1
1 1 0 0 1
0 1 1 1 1
0 0 0 1 1
*/
//Ý tưởng: Nếu vị trí bên phải, bên dưới có số 1 thì gọi hàm quay lui tại vị trí đó và cập nhật kết quả
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, check, a[100][100];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            cin >> a[i][j];
}

void Try(int i, int j, string str) { //hàm quay lui
    if (i == n - 1 && j == n - 1) { //nếu đã đi đến đích in ra kết quả đánh dấu đã có kết quả
        cout << str << " ";
        check = 1;
        return;
    }
    if (i < n - 1 && a[i + 1][j] == 1) Try (i + 1, j, str + "D"); //nếu bên dưới có đường đi gọi hàm quay lui
    if (j < n - 1 && a[i][j + 1] == 1) Try (i, j + 1, str + "R"); //nếu bên phải có đường đi gọi hàm quay lui
}

void solve() {
    check = 0;
    if (a[0][0] != 1 || a[n - 1][n - 1] != 1) cout << "-1"; //nếu đầu và đích khác 1 thì không có kết quả in ra -1
    else {
        Try (0, 0, ""); //gọi hàm quay lui tại vị trí đầu
        if (check == 0) cout << "-1"; //nếu không có đường đến đích in ra -1
    }
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
23. DSA02006	DÃY CON TỔNG BẰNG K
/*Cho dãy số A[] = (a1, a2, .., an) và số tự nhiên K. Hãy đưa ra tất cả các dãy con của dãy số A[] sao cho tổng các phần
tử của dãy con đó đúng bằng K. Các phần tử của dãy số A[] được giả thuyết là nguyên dương và không có các phần tử giống
nhau. Ví dụ với dãy con A[] = {5, 10, 15, 20, 25}, K = 50 ta có 3 dãy con {5, 10, 15, 20}, {5, 20, 25}, {10, 15, 25}.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất đưa vào số N là số lượng phần tử của dãy
số A[] và số K; dòng tiếp theo đưa vào N phần tử của dãy số A[].
T, N, A[i] thỏa mãn ràng buộc: 1≤T ≤100; 1≤N≤10; 1≤ K, A[i] ≤100.
Output:
Đưa ra tất cả các dãy con của dãy số A[] thỏa mãn yêu cầu bài toán theo thứ tự từ điển, trong đó mỗi dãy con được bao
bởi các ký tự [, ]. Nếu không có dãy con nào thỏa mãn yêu cầu bài toán, hãy đưa ra -1.
Input                             Output
2
5 50                              [5 10 15 20] [5 20 25] [10 15 25]
5  10 15 20  25
8  53                             [8 9 14 22] [8 14 15 16] [15 16 22]
15  22  14  26  32  9  16  8
*/
//Ý tưởng: Thực hiện quay lui với 2 giá trị 0, 1 với 0 ứng với không sử dụng và 1 ứng với được sử dụng
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, k, a[20];
bool check;

void init() { //hàm khởi tạo
    cin >> n >> k;
    check = false;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void print(vector <int> res) { //hàm in kết quả
    cout << "[";
    for (int i = 0; i < res.size () - 1; i++) cout << res[i] << " ";
    cout << res[res.size () - 1] << "] ";
}

void Try(int i, int sum, vector <int> res) { //hàm quay lui
    for (int j = 1; j >= 0; j--) {
        if (j == 1) { //j bằng 1 ứng với a[i] được sử dụng
            sum += a[i]; //tăng tổng hiện tại
            res.push_back (a[i]); //thêm a[i] vào kết quả
            if (sum == k) { //nếu tổng bằng k đưa ra kết quả và đánh dấu đã có kết quả
                check = true;
                print (res);
                return;
            } else if (sum > k) return; //nếu tổng lớn hơn k dừng cận
            else {
                if (i < n) Try (i + 1, sum, res); //nếu tổng nhỏ hơn k và chưa duyệt hết mảng thì gọi hàm đệ quy
            }
            sum -= a[i]; //trả lại tổng trước đó
            res.pop_back (); //trả lại kết quả trước đó
        } else { //j=0 ứng với không được sử dụng
            if (i < n) Try (i + 1, sum, res); //nếu chưa duyệt hết dãy thì gọi hàm đệ quy
        }
    }
}

void solve() { //hàm xử lý
    sort (a, a + n); //sắp xếp lại mảng
    vector <int> res; //khai báo vector kết quả trống
    Try (0, 0, res); //gọi hàm quay lui
    if (check == false) cout << "-1"; //nếu không có kết quả in -1
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
24. DSA05009	TẬP CON BẰNG NHAU
/*Cho tập các số A[] = (a1, a2, .., an). Hãy kiểm tra xem ta có thể chia tập A[] thành hai tập con sao cho tổng các phần
tử của hai tập con bằng nhau hay không. Đưa ra YES nếu có thể thực hiện được, ngược lại đưa ra NO.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất đưa vào số N là số lượng phần tử của dãy
số A[]; dòng tiếp theo đưa vào N phần tử của dãy số A[].
T, N, A[i] thỏa mãn ràng buộc: 1≤T ≤100; 1≤N≤100; 1≤ A[i] ≤100.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
4                    YES
1 5 11 5
3                    NO
1 3 5
*/
//Ý tưởng: kiểm tra xem có tìm được dãy con nào có tổng là sum/2 không
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, sum, check, a[101];

void init() { //hàm khởi tạo
    cin >> n;
    sum = 0;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
        sum += a[i]; //tính tổng các phần tử
    }
}

void Try(int i, int s, int sumbest) { //hàm quay lui
    if (check == 1) return; //nếu đã tìm được mảng con thì dừng nhánh
    for (int j = 1; j >= 0; j--) {
        if (j == 1) { //j=1 ứng với được sử dụng
            s += a[i]; //tăng tổng hiện tại
            sumbest -= a[i]; //giảm tổng tối đa còn lại
            if (s == sum) { //nếu tìm được kết quả dừng nhanh đánh dấu đã tìm được
                check = 1;
                return;
            } else if (s > sum || sumbest < sum) return; //nếu tổng lớn hơn sum/2 hoặc tổng lớn nhất còn lại nhỏ hơn sum
            else {
                if (i > 0) Try (i - 1, s, sumbest); //gọi hàm đệ quy nếu chưa duyệt hết
            }
            s -= a[i]; //trả lại tổng trước đó
            sumbest += a[i]; //trả lại tổng lớn nhất còn lại trước đó
        } else {
            if (i > 0) Try (i - 1, s, sumbest); //gọi hàm đệ quy nếu chưa duyệt hết
        }
    }
}

void solve() { //hàm xủ lý
    if (sum % 2 == 1) cout << "NO" << "\n"; //nếu tổng không chia hết cho 2 tức là không thể chia mảng
    else {
        sort (a, a + n); //sắp xếp lại mảng
        check = 0; //đánh dấu là chưa tìm được kết quả
        sum /= 2; //chia tổng cho 2
        Try (n - 1, 0, sum * 2); //gọi hàm quay lui
        if (check == 1) cout << "YES" << "\n"; //in ra kết quả
        else cout << "NO" << "\n";
    }
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
25. DSA02012	DI CHUYỂN TRONG MA TRẬN
/*Cho ma trận A[M][N]. Nhiệm vụ của bạn là đếm tất cả các đường đi từ phần tử A[0][0] đến phần tử A[M-1][N-1]. Bạn chỉ
được phép dịch chuyển xuống dưới hoặc sang phải phần tử liền kề với vị trí hiện tại.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất là hai số M, N tương ứng với số hàng và
số cột của ma trận; dòng tiếp theo đưa vào các phần tử của ma trận A[][]; các số được viết cách nhau một vài khoảng
trống.
T, M, N, A[i][j] thỏa mãn ràng buộc: 1≤T ≤10; 1≤M, N, A[i][j]≤100.
Output:
Đưa ra số cách di chuyển của mỗi test theo từng dòng.
Giải thích test 1: Có 3 cách di chuyển là [1 4 5 6], [1 2 5 6] và [1 2 3 6].
Input                Output
2
2  3                 3
1  2  3
4  5  6
2  2                 2
1  2
3  4
*/
//Ý tưởng: Nếu bên phải hoặc bên dưới còn đường đi thì gọi hàm quay lui tại vị trí đó
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, m, cnt, a[105][105];

void init() { //hàm khởi tạo
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            cin >> a[i][j];
}

void Try(int i, int j) { //hàm quay lui
    if (i == n && j == m) cnt++; //nếu đã đi đến đích tăng biến đếm
    if (i < n) Try (i + 1, j); //nếu bên phải còn đường đi gọi hàm đệ quy tại đó
    if (j < m) Try (i, j + 1); //nếu bên dưới còn đường đi gọi hàm đệ quy tại đó
}

void solve() {
    cnt = 0; //gán số đường đi bằng 0
    Try (1, 1); //gọi hàm đệ quy
    cout << cnt << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
26. 	DSA02016	SẮP XẾP QUÂN HẬU 1
/*Cho một bàn cờ vua có kích thước n * n, ta biết ràng quân hậu có thể di chuyển theo chiều ngang, dọc, chéo. Vấn đề đặt
ra rằng, có n quân hậu, bạn cần đếm số cách đặt n quân hậu này lên bàn cờ sao cho với 2 quân hậu bất kì, chúng không
“ăn” nhau.
Input: Dòng đầu ghi số bộ test T (T<5). Mỗi bộ test ghi một số nguyên dương n duy nhất (không quá 10)
Output:  Ghi kết quả mỗi bộ test trên một dòng. Số cách đặt quân hậu.
Input                Output
1
4                    2
*/
//ý tưởng: Kiểm tra tại vị trí được duyệt tới nếu không có quân hậu khác ăn thì đặt vào
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, cnt, a[20];

void init() { //hàm khởi tạo
    cin >> n;
}

bool check(int x,int y) { //hàm kiểm tra đặt quân hậu có bị ăn không
    for (int i = 1; i < x; i++)
        if (a[i] == y || abs (i - x) == abs (a[i] - y)) //công thức kiểm tra, nên vẽ hình để nhìn
            return false;
    return true;
}

void Try(int i) { //hàm quay lui
    for (int j = 1; j <= n; j++) {
        if (check (i, j)) { //nếu đặt được quân hậu
            a[i] = j; //thực hiện đặt quân hậu
            if (i == n) cnt++; //nếu đặt đủ n quân hậu tăng số cách đặt
            Try (i + 1); //nếu chưa đặt đủ n quân hậu gọi hàm đệ quy
        }
    }
}

void solve() {
    cnt = 0; //gán số cách đặt quân hậu bằng 0
    Try (1); //gọi hàm quay lui
    cout << cnt << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
27. DSA03001	ĐỔI TIỀN
/*Tại ngân hàng có các mệnh giá bằng 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000. Tổng số tiền cần đổi có giá trị bằng N.
Hãy xác định xem có ít nhất bao nhiêu tờ tiền sau khi đổi tiền?
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 50).  Mỗi test gồm 1 số nguyên N ( 1 ≤ N ≤ 100 000).
Output:  Với mỗi test, in ra đáp án trên một dòng.
Input                Output
2
70                   2
121                  3
*/
//Ý tưởng: Trả tờ tiền có mệnh giá cao nhất không lớn hơn số tiền hiện tại đến khi trả đủ tiền
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, cnt, pos, a[]={1, 2, 5, 10, 20, 50, 100, 200, 500, 1000};

void init() { //hàm khởi tạo
    cin >> n;
}

void solve() { //hàm xử lý
    cnt = 0, pos = 9; //gán số tờ tiền bằng 0 và vị trí tờ tiền cao nhất có thể là 9
    while (n > 0) { //nếu chưa trả hết tiền
        if (n >= a[pos]) { //nếu tờ tiền hiện tại có thể trả được
            cnt += n / a[pos]; //trả số tờ tiền nhiều nhất có thể
            n %= a[pos]; //cập nhật số tiền còn lại phải trả
        } else pos--; //nếu tờ tiền hiện tại không thể trả giảm vị trí tờ tiền lớn nhất
    }
    cout << cnt << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
28. DSA03002	NHẦM CHỮ SỐ
/*Trong một buổi học toán, giáo viên viết 2 số nguyên, A và B, và yêu cầu Tèo thực hiện phép cộng. Tèo không bao giờ
tính toán sai, nhưng thỉnh thoảng cậu ta chép các con số một cách không chính xác. Lỗi duy nhất của là ghi nhầm '5'
thành '6' hoặc ngược lại.  Cho hai số, A và B, tính tổng nhỏ nhất và lớn nhất mà Tèo có thể nhận được.
Input: Có một dòng chứa hai số nguyên dương A và B ( 1 ≤ A, B ≤ 1 000 000).
Output: In ra 2 số nguyên cách nhau một dấu cách, tổng nhỏ nhất và lớn nhất có thể nhận được.
Input                Output
11 25                36 37
1430 4862            6282 6292
16796 58786          74580 85582
*/
//Ý tưởng: Chuyển 5 thành 6 để tìm max và chuyển 6 thành 5 để tìm min

#include<bits/stdc++.h>
using namespace std;

int a, b;

void init(){ //hàm khởi tạo
    cin>>a>>b;
}

int min(int n) { //tìm giá trị nhỏ nhất
    int val = 0;
    int cnt = 0;
    while (n > 0) {
        int x = n % 10; //lấy từng chữ số của n
        if (x == 6) x = 5; //thay 6 bằng 5
        val += x * pow (10, cnt); //nhân với luỹ thừa của 10 với vị trí của nó từ dưới lên
        cnt++; //tăng vị trí
        n /= 10; //giảm n
    }
    return val; //trả về giá trị nhỏ nhất
}

int max(int n) { //tìm giá trị lớn nhất
    int val = 0;
    int cnt = 0;
    while (n > 0) {
        int x = n % 10; //lấy từng chữ số của n
        if (x == 5) x = 6; //thay 5 bằng 6
        val += x * pow (10, cnt); //nhân với luỹ thừa của 10 với vị trí của nó từ dưới lên
        cnt++; //tăng vị trí
        n /= 10; //giảm n
    }
    return val; //trả về giá trị lớn nhất
}

void solve() { //hàm xử lý
    cout << min (a) + min (b) << " " << max (a) + max (b); //đưa ra kết quả
}

int main() {
    init ();
    solve ();
    return 0;
}
29. DSA03003	TÌM MAX
/*Cho mảng A[] gồm N phần tử.Nhiệm vụ của bạn là tìm  bằng cách sắp đặt lại các phần tử trong mảng. Chú ý, kết quả của
bài toán có thể rất lớn vì vậy bạn hãy đưa ra kết quả lấy modulo với 109+7.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất đưa vào số phần tử của mảng N; dòng tiếp
theo đưa vào N số A[i] tương ứng với các phần tử của mảng A[]; các số được viết cách nhau một vài khoảng trống.
T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤N, A[i] ≤107.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
2
5                     40
5 3 2 4 1
3                     8
1 2 3
*/
//Ý tưởng: Sắp xếp lại mảng sau đó nhân giá trị và chỉ mục
//Code:

#include<bits/stdc++.h>
using namespace std;

long n, a[1000005], res, m=1e9+7;

void init() { //hàm khởi tạo
    cin >> n;
    for (long i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    sort (a, a + n); //sắp xếp lại mảng
    res = 0;
    for (long i = 1; i < n; i++) res = (res + a[i] * i % m) % m; //nhân giá trị với chỉ mục tương ứng
    cout << res << endl; //đưa ra kết quả
}

int main(){
    int t;
    cin>>t;
    while(t--){
        init();
        solve();
    }
    return 0;
}
30. DSA03004	TỔNG NHỎ NHẤT
/*Cho mảng A[] gồm các số từ 0 đến 9. Nhiệm vụ của bạn là tìm tổng nhỏ nhất của hai số được tạo bởi các số trong mảng
A[]. Chú ý, tất cả các số trong mảng A[] đều được sử dụng để tạo nên hai số.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất đưa vào số phần tử của mảng N; dòng tiếp
theo đưa vào N số A[i] tương ứng với các phần tử của mảng A[]; các số được viết cách nhau một vài khoảng trống.
T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤N ≤20; 0≤A[i]≤9.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
6                    604
6 8 4 5 2 3
5                    82
5 3 0 7 4
*/
//Ý tưởng:Sắp xếp lại mảng sau đó tạo nên 2 số x, y bằng cách thêm từng chữ số nhỏ nhất vào
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, a[20];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    sort (a, a + n); //sắp xếp lại mảng a
    long x = 0, y = 0, res;
    for (int i = 0; i < n; i++) {
        if (i % 2 == 0) x = x * 10 + a[i]; //đưa số nhỏ nhất vào x
        else y = y * 10 + a[i]; //đưa số nhỏ tiếp theo vào y
    }
    res = x + y; //cập nhật kết quả
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
31. DSA03005	CHIA MẢNG THÀNH HAI MẢNG CON CÓ TỔNG LỚN NHẤT
/*Cho mảng A[] gồm N số nguyên không âm và số K. Nhiệm vụ của bạn là hãy chia mảng A[] thành hai mảng con có kích cỡ K
và N-K sao cho hiệu giữa tổng hai mảng con là lớn nhất. Ví dụ với mảng A[] = {8, 4, 5, 2, 10}, K=2 ta có kết quả là 17
vì mảng A[] được chia thành hai mảng {4, 2} và { 8, 5,10} có hiệu của hai mảng con là 23-6=17 là lớn nhất.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất đưa vào số phần tử của mảng N và số K;
dòng tiếp theo đưa vào N số A[i] tương ứng với các phần tử của mảng A[]; các số được viết cách nhau một vài khoảng
trống. T, N, K, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤ K<N ≤50; 0≤A[i]≤1000.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
5 2                  17
8 4 5 2 10
8 3                  2
1 1 1 1 1 1 1 1
*/
//Ý tưởng: chia mảng thành 2 phần, phần có số phần tử lớn hơn chưa các số lớn và ngược lại
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, k, a[1005];

void init() { //hàm khởi tạo
    cin >> n >> k;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xủ lý
    sort (a, a + n); //sắp xếp lại mảng a
    int min = fmin (k, n - k); //tìm số phần tử min
    int res = 0;
    for (int i = 0; i < n; i++) {
        if (i < min) res -= a[i]; //trừ đi phần tử thuộc mảng ít phần tử hơn
        else res += a[i]; //cộng thêm phần tử thuộc mảng nhiều phần tử hơn
    }
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
32. DSA03006	SẮP XẾP THAM LAM 
/*Cho mảng A[] gồm N số và thực hiện các thao tác theo nguyên tắc dưới đây:
Ta chọn một mảng con sao cho phần tử ở giữa của mảng con cũng là phần tử ở giữa của mảng A[] (trong trường hợp N lẻ).
Đảo ngược mảng con đã chọn trong mảng A[]. Ta được phép chọn mảng con và phép đảo ngược mảng con bao nhiêu lần tùy ý.
Ví dụ với mảng A[] = {1, 6, 3, 4, 5, 2, 7} ta có câu trả lời là Yes vì: ta chọn mảng con {3, 4, 5} và đảo ngược để nhận
được mảng A[]={1, 6, 5, 4, 3, 2, 7}, chọn tiếp mảng con {6, 5, 4, 3, 2} và đảo ngược ta nhận được mảng A[]={1, 2, 3, 4,
5, 6, 7}. Hãy cho biết ta có thể sắp xếp được mảng A[] bằng cách thực hiện các thao tác kể trên hay không?
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất đưa vào số phần tử của mảng N; dòng tiếp theo đưa vào N số A[i] tương ứng với các phần tử của mảng A[]; các số được viết cách nhau một vài khoảng trống.
T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤ N ≤50; 0≤A[i]≤1000.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
7                    Yes
1 6 3 4 5 2 7
7                    No
1 6 3 4 5 7 2
*/
//Ý tưởng: Kiểm tra xem 2 vị trí đối xứng có 2 phần tử thuộc 2 vị trí đó của mảng đã sắp xếp không
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, check, a[50];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    check = 1; //đánh dấu là mảng có thể sắp xếp
    int min1, max1; //min1 và max1 của 2 phần tử đối xứng nhau
    if (n % 2 == 1) { //nếu n lẻ chọn min1 và max1 là phần tử trung gian
        min1 = a[n / 2];
        max1 = a[n / 2];
    } else { //nếu n chẵn thì chọn min1 là max1 của 2 phần tử trung gian + 1 và min là min của 2 phần tử trung gian -1
        min1 = max (a[n / 2 - 1], a[n / 2]) + 1;
        max1 = min (a[n / 2 - 1], a[n / 2]) - 1;
    }
    for (int i = n / 2 - 1; i >= 0; i--) { //duyệt từ phần tử trung gian về
        int min2 = min (a[i], a[n - i - 1]); //min2 là min của 2 phần tử đối xứng tiếp theo
        int max2 = max (a[i], a[n - i - 1]); //max 2 là max của 2 phần tử đối xứng tiếp theo
        if (min2 >= min1 || max2 <= max1) { //nếu không thể sắp xếp gán check bằng 0 và dừng vòng for
            check = 0;
            break;
        } else { //ngược lại cập nhật min1 và max1
            min1 = min2;
            max1 = max2;
        }
    }
    if (check == 1) cout << "Yes"; //đưa ra kết quả
    else cout << "No";
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
33. DSA03010	NỐI DÂY 1
/*Cho N sợi dây với độ dài khác nhau được lưu trong mảng A[]. Nhiệm vụ của bạn là nối N sợi dây thành một sợi sao cho
tổng chi phí nối dây là nhỏ nhất.Biết chi phí nối sợi dây thứ i và sợi dây thứ j là tổng độ dài hai sợi dây A[i] và A[j].
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất đưa vào số lượng sợi dây N; dòng tiếp theo đưa vào N số A[i] là độ dài của các sợi dây; các số được viết cách nhau một vài khoảng trống.
T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤N≤106; 0≤A[i]≤106.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
2
4                     29
4 3 2 6
5                     62
4 2 7 6 9
*/
//Ý tưởng: Ghép 2 sợi dây có chi phí nhỏ nhất trong các sợi dây còn lại sử dụng hàng đợi ưu tiên
//Code:

#include <bits/stdc++.h>
using namespace std;

long n, res;
priority_queue<long, vector<long>, greater<long> >q;

void init() { //hàm khởi tạo
    cin >> n;
    long tmp;
    for (long i = 0; i < n; i++) {
        cin >> tmp;
        q.push (tmp); //đưa phần tử vào queue
    }
}

void solve() { //hàm xử lý
    res = 0; //khởi tạo res=0
    while (q.size () > 1) { //nếu q có nhiều hơn 1 phần tử tức là vẫn có thể nối
        long x = q.top (); //lấy phần tử ở đỉnh của queue
        q.pop (); //xoá phần tử đó
        long y = q.top (); //lấy phần tử ở đỉnh của queue
        q.pop (); //xoá phần tử đó
        long long z = x + y; //cộng 2 phần tử lấy ra lại
        q.push (z); //đưa sợi dây được nối vào queue
        res += z; //cập nhật kết quả
    }
    cout << res << endl; //đưa ra kết quả
    q.pop (); //làm trống queue
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
34. DSA03012	SẮP ĐẶT XÂU KÝ TỰ 1
/*Cho xâu ký tự S bao gồm các ký tự in thường. Nhiệm vụ của bạn là kiểm tra xem ta có thể sắp đặt lại các ký tự trong S để
hai ký tự giống nhau đều không kề nhau hay không? Đưa ra 1 nếu có thể sắp đặt lại các ký tự trong S thỏa mãn yêu cầu bài
toán, ngược lại đưa ra -1.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một xâu ký tự S được viết trên một dòng.
T, S thỏa mãn ràng buộc: 1≤T≤100;  1≤length(S)≤10000.
Output:
Đưa ra kết quả mỗi test theo từng dòng.

Input                               Output
3
geeksforgeeks                       1
bbbabaaacd                          1
bbbbb                               -1
*/
/*Ý tưởng: nếu độ dài của mảng là số chẵn thì số lần xuất hiện lớn nhất không lớn hơn tổng số lần xuất hiện của các phần
tử còn lại, nếu độ dài của mảng là số lẻ thì số lần xuất hiện lớn nhất không lớn hơn tổng số lần xuất hiện của các phần
tử còn lại cộng 1 */
//Code:

#include<bits/stdc++.h>
using namespace std;

string str;
void init(){ //hàm khởi tạo
    cin>>str;
}

void solve() { //hàm xử lý
    int a[130] = {0}; //khai báo mảng đếm và gán tất cả bằng 0
    for (int i = 0; i < str.length (); i++) a[str[i]]++; //đếm số lần xuất hiện của mỗi phần tử
    sort (a, a + 130); //sắp xếp lại mảng thì phần tử cuối cùng là số lần xuất hiện lớn nhất của 1 phần tử
    //kiểm tra điều kiện và đưa ra kết quả
    if (str.length () % 2 == 0) {
        if (a[129] <= str.length () / 2) cout << "1";
        else cout << "-1";
    } else {
        if (a[129] <= str.length () / 2 + 1) cout << "1";
        else cout << "-1";
    }
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
35. DSA03013	SẮP ĐẶT XÂU KÝ TỰ 2
/*Cho xâu ký tự S bao gồm các ký tự in thường và số D. Nhiệm vụ của bạn là kiểm tra xem ta có thể sắp đặt lại các ký
tự trong S để tất cả các ký tự giống nhau đều có khoảng cách là D hay không? Đưa ra 1 nếu có thể sắp đặt lại các
ký tự trong S thỏa mãn yêu cầu bài toán, ngược lại đưa ra -1.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất là số D; dòng tiếp theo là xâu S.
T, S, D thỏa mãn ràng buộc: 1≤T≤100;  1≤length(S)≤10000; 1≤D≤100.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                             Output
2
2
ABB                               1
2
AAA                               -1
*/
/*Ý tưởng: khoảng cách giữa các ký tự giống nhau là d nên số các ký tự khác số lần xuất hiện nhiều nhất phải nhỏ hơn số
khoảng trống sau khi đặt các ký tự xuất hiện nhiều nhất cách nhau d ký tự */
//Code:

#include<bits/stdc++.h>
using namespace std;

int d, res;
string str;

void init() { //hàm khởi tạo
    cin >> d >> str;
}

void solve() { //hàm xử lý
    int a[130] = {0}; //tạo mảng đếm số lần xuất hiện các ký tự
    for (int i = 0; i < str.length (); i++)
        a[str[i]]++; //nếu xuất hiện kí tự nào thì tăng số lần xuất hiện của ký tự đó
    sort (a, a + 130);  //sắp xếp lại số lần xuất hiện của các ký tự
    res = 1;
    if ((a[129] - 1) * (d - 1) > str.length () - a[129]) res = -1; //kiểm tra điều kiện
    cout << res << endl; //in ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
36. DSA03015	MUA LƯƠNG THỰC
/*Giả sử bạn là một người nghèo trong địa phương của bạn. Địa phương của bạn có duy nhất một cửa hàng bán lương thực.
Cửa hàng của bạn mở cửa tất cả các ngày trong tuần ngoại trừ chủ nhật. Cho bộ ba số N, S, M thỏa mãn ràng buộc sau:
N : số đơn vị lương thực nhiều nhất bạn có thể mua trong ngày.
S : số lượng ngày bạn cần được sử dụng lương thực để tồn tại.
M : số đơn vị lương thực cần có mỗi ngày để bạn tồn tại.
Giả sử bạn đang ở ngày thứ 2 trong tuần và cần tồn tại trong S ngày tới. Hãy cho biết số lượng ngày ít nhất bạn cần phải
mua lương thực từ của hàng để tồn tại hoặc bạn sẽ bị chết đói trong S ngày tới.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là bộ 3 số N, S, M được viết trên một dòng.
T, N, S, M thỏa mãn ràng buộc: 1≤T≤100;  1≤N, S, M ≤30.
Output:
Đưa ra số ngày ít nhất bạn có thể mua lương thực để tồn tại hoặc đưa ra -1 nếu bạn bị chết đói.
Input                Output
2
16 10 2              2
20 10 30             -1
*/
//Ý tưởng: đếm số lương thục bạn có thể mua. Nếu lớn hơn số lương thực cần tồn tại thì in ra số ngày đã mua
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, s, m;

void init() {
    //hàm khởi tạo
    cin >> n >> s >> m;
}

void solve() { //hàm xử lý
    int x = s * m; //số lương thực cần để tồn tại
    int sum = 0; //số lương thục đã mua
    int res = 0; //số ngày cần mua
    for (int i = 1; i <= s; i++) {
        if (i % 7 != 0) sum += n; // ngày khác chủ nhật mua tối đa lương thực có thể mua trong ngày
        else res--; // ngày chủ nhật không thể mua
        if (sum >= x) { //nếu số lương thực đã mua đã đủ để tồn tại in ra số ngày tối thiểu
            cout << res + i;
            break;
        }
    }
    if (sum < x) cout << "-1"; //nếu không mua đủ lương thực đưa ra -1
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
37. DSA04001	LŨY THỪA
/*Cho số nguyên dương N và K. Hãy tính NK modulo 10^9+7.
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test gồm 1 số nguyên N và K (1 ≤ N ≤ 1000, 1 ≤ K ≤ 10^9).
Output:
Với mỗi test, in ra đáp án trên một dòng.
Input                Output
2
2 3                  8
4 2                  16
*/
//Ý tưởng: a^b = a^(b/2)*a^(b/2) với b chăn và a^b = a^(b/2)*a^(b/2)*a với b lẻ
//Code:

#include<bits/stdc++.h>
using namespace std;

long n, k, m=1e9+7;

void init() { //hàm khởi tạo
    cin >> n >> k;
}

long power(long x,long y) { //hàm tính luỹ thừa
    if (y == 0) return 1;
    else if (y == 1) return x;
    else {
        if (y % 2 == 0) return (power (x, y / 2) % m * power (x, y / 2) % m) % m; //th y chẵn
        return (power (x, y / 2) % m * power (x, y / 2) % m * x % m) % m; //th y lẻ
    }
}

void solve() { //hàm xử lý
    cout << power (n, k) << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
38. DSA04004	GẤP ĐÔI DÃY SỐ
/*Một dãy số tự nhiên bắt đầu bởi con số 1 và được thực hiện N-1 phép biến đổi “gấp đôi” dãy số như sau:
Với dãy số A hiện tại, dãy số mới có dạng A, x, A trong đó x là số tự nhiên bé nhất chưa xuất hiện trong A.
Ví dụ với 2 bước biến đổi, ta có [1] à [1 2 1] à [1 2 1 3 1 2 1].
Các bạn hãy xác định số thứ K trong dãy số cuối cùng là bao nhiêu?
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test gồm số nguyên dương N và K (1 ≤ N ≤ 50, 1 ≤ K ≤ 2N - 1).
Output:
Với mỗi test, in ra đáp án trên một dòng.
Input                Output
2
3 2                  2
4 8                  4
*/
//Ý tưởng: nếu k bằng 2^(n-1) thì giá trị tại k là n, nếu k nhỏ hơn 2^(n-1) thì giá trị tại k là giá trị tại k-2^(n-1).
//Code:

#include<bits/stdc++.h>
using namespace std;

int n;
long long k;

void init() { //hàm khởi tạo
    cin >> n >> k;
}

long find(int n, long long k) {
    if (k == pow (2, n - 1)) return n; //nếu k=2^(n-1)
    if (k > pow (2, n - 1)) return find (n - 1, k - pow (2, n - 1)); //nếu k>(2^n-1)
    return find (n - 1, k); //nếu k<2^(n-1) thì giảm n
}

void solve() { //hàm xử lý
    cout << find (n, k) << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
39. DSA04003	ĐẾM DÃY
/*Cho số nguyên dương n. Hãy cho biết có bao nhiêu dãy số nguyên dương có tổng các phần tử trong dãy bằng n.
Dữ liệu vào: dòng đầu tiên chứa số nguyên T là số bộ dữ liệu, mỗi bộ dữ liệu ghi một số nguyên dương n duy nhất không
quá 10^18.
Kết quả: Mỗi bộ dữ liệu ghi ra một số nguyên duy nhất là số dư của kết quả tìm được khi chia cho 123456789.
Input                Output
1
3                    4
*/
//Ý tưởng: số dãy bằng 2^(n-1)
//Code:

#include<bits/stdc++.h>
using namespace std;

long n, m=123456789;

void init() { //hàm khởi tạo
    cin >> n;
}

long long power(long n) { //hàm tính luỹ thừa
    if (n == 0) return 1;
    else if (n == 1) return 2;
    if (n % 2 == 0) return (power (n / 2) % m * power (n / 2) % m) % m;
    else return ((power (n / 2) % m * power (n / 2) % m) % m * 2) % m;
}

void solve() { //hàm xử lý
    cout << power (n - 1) << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
40. DSA04005	DÃY XÂU FIBONACI
/*Một dãy xâu ký tự G chỉ bao gồm các chữ cái A và B được gọi là dãy xâu Fibonacci nếu thỏa mãn tính chất:    G(1) = A;
G(2) = B; G(n) = G(n-2)+G(n-1). Với phép cộng (+) là phép nối hai xâu với nhau.  Bài toán đặt ra là tìm ký tự ở vị trí
thứ i (tính từ 1) của xâu Fibonacci thứ n.
Dữ liệu vào: Dòng 1 ghi số bộ test. Mỗi bộ test ghi trên một dòng 2 số nguyên N và i (1<N<93). Số i đảm bảo trong phạm
vi của xâu G(N) và không quá 18 chữ số. Kết quả: Ghi ra màn hình kết quả tương ứng với từng bộ test.
Input                 Output
2
6 4                   A
8 19                  B
*/
/*Ý tưởng: ký tự thuộc xâu 1 là A, ký tự thứ 2 là B. nếu k <= fib[n-2] thì ký tự k là ký tự k của xâu thứ n-2, còn không
thì ký tự k là ký tự k-fib[n-2] của xâu thứ n-1*/
//Code:

#include <bits/stdc++.h>
using namespace std;

int n;
long long k, fib[100];

void init() { //hàm khởi tạo
    cin >> n >> k;
}

char find(int n, long long k) { //hàm tìm ký tự thứ k
    if (n == 1) return 'A';
    if (n == 2) return 'B';
    if (k <= fib[n - 2]) return find (n - 2, k);
    else return find (n - 1, k - fib[n - 2]);
}

void solve() { //hàm xử lý
    //tìm độ dài của các xâu fib
    fib[0] = 0;
    fib[1] = 1;
    for (int i = 2; i < 93; i++) fib[i] = fib[i - 1] + fib[i - 2];
}

int main() {
    int t;
    cin >> t;
    solve ();
    while (t--) {
        init ();
        cout << find (n, k) << endl;
    }
    return 0;
}
41. DSA04002	LŨY THỪA ĐẢO
/*Cho mảng số N. Ta gọi số đảo của N là R. Hãy tìm lũy thừa R của N. Đưa ra kết quả của bài toán dưới dạng modulo với
109 + 7.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm là số N được ghi trên một dòng.
T, N thỏa mãn ràng buộc: 1≤T≤100;  1≤N≤1010.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
2                    4
12                   130323020
*/
//Ý tưởng: tính số đảo của n sau đó tính luỹ thừa đảo của n
//Code:

#include<bits/stdc++.h>
using namespace std;

long n, m=1e9+7;

void init() { //hàm khởi tạo
    cin >> n;
}

long islandNumber(long tmp) { //hàm tính số đảo
    long val = 0;
    while (tmp > 0) { //bổ sung chữ số vào giá trị hiện tại
        val = val * 10 + tmp % 10;
        tmp /= 10;
    }
    return val; //trả về số đảo của n
}

long power(long a, long b) { //hàm tính luỹ thừa
    if (b == 0) return 1;
    else if (b == 1) return a;
    else {
        if (b % 2 == 0) return (power (a, b / 2) % m * power (a, b / 2) % m) % m;
        return (power (a, b / 2) % m * power (a, b / 2) % m * a % m) % m;
    }
}

void solve() { //hàm xử lý
    cout << power (n, islandNumber (n)) << endl; //in ra luỹ thừa đảo của n
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
42. DSA04010	DÃY CON LIÊN TIẾP CÓ TỔNG LỚN NHẤT
/*Cho mảng A[] gồm N số có cả các số âm và số dương. Nhiệm vụ của bạn là tìm mảng con liên tục có tổng lớn nhất của mảng.
Ví dụ với mảng A[]={-2, -5, 6, -2,-3, 1, 5, -6} ta có kết quả là 7 tương ứng với dãy con {6, -2, -3, 1, 5}.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất đưa vào hai số N tương ứng với số phần tử
của mảng; dòng tiếp theo đưa vào N số A[i]; các số được viết cách nhau một vài khoảng trống.
T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤ N≤100; -100≤A[i] ≤100.
Output:
Đưa ra tổng con liên tục lớn nhất của mỗi test theo từng dòng.
Input                Output
1
8                    7
-2 -5 6 -2 -3 1 5 -6
*/
/*Ý tưởng: tìm kiếm tất cả các đoạn liền kề dương của mảng. Và theo dõi tổng phân đoạn liền kề tối đa trong số tất cả
các phân đoạn dương. Mỗi khi nhận được một tổng dương, hãy so sánh nó với max và cập nhật max nếu nó lớn hơn max*/
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, a[100];

void init() {
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void solve() {
    int max = -1, sum = 0; //khởi tạo max và sum
    for (int i = 0; i < n; i++) {
        sum += a[i]; //cập nhật sum mới
        if (max < sum) max = sum; //nếu sum>max cập nhật giá trị max mới
        else if (sum < 0) sum = 0; //nếu sum<0 đặt lại sum bằng 0
    }
    cout << max << endl; //in ra kết quả. Dãy toàn âm in ra -1
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
43. DSA04015	TÍNH FLOOR(X)
/*Cho mảng đã được sắp xếp A[] gồm N phần tử không có hai phần tử giống nhau và số X. Nhiệm vụ của bạn là tìm floor(X).
Trong đó, K=floor(X) là phần tử lớn nhất trong mảng A[] nhỏ hơn hoặc bằng X.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất đưa vào số N là số phần tử của mảng A[] và
số X; dòng tiếp theo đưa vào N số của mảng A[]; các số được viết cách nhau một vài khoảng trống.
T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤ N≤107; 1≤ A[i]≤1018.
Output:
Đưa ra vị trí của  floor(X) trong mảng A[] hoặc -1 nếu không tồn tại floor(X) của mỗi test theo từng dòng.
Input                Output
3
7 0                  -1
1 2 8 10 11 12 19
7 5                  2
1 2 8 10 11 12 19
7 10                 4
1 2 8 10 11 12 19
*/
/*Ý tưởng: chọn vị trí chính giữa của mảng nếu bằng x hoặc nếu đã là số lớn nhất còn nhỏ hơn x thì in. Nếu giá trị đó
nhỏ hơn x thì tiếp tục tìm ở nửa bên phải, ngược lại tìm ở nửa bên trái*/
//Code:

#include<bits/stdc++.h>
using namespace std;

long n;
long long k, a[1000005];

void init() { //hàm khởi tạo
    cin >> n >> k;
    for (long i = 1; i <= n; i++) cin >> a[i];
}

long floor(long x, long y) { //hàm tính floor
    long index = (x + y) / 2; //chọn vị trí giữa
    if (a[index] == k) return index; //nếu đúng bằng k trả về index
    else if (a[index] < k) { //nếu nhỏ hơn k
        if (a[index + 1] > k) return index; //nếu vị trí sau index lớn hơn k trả về index
        else return floor (index + 1, y); //nếu không tìm ở nửa sau
    } else if (a[index] > k) { //nếu lớn hơn k
        if (a[index - 1] < k) return index - 1; //nếu vị trí trước index nhỏ hơn k trả về index-1
        else return floor (x, index - 1); //nếu không tìm ở nửa trước
    }
}

void solve() { //hàm xử lý
    if (a[1] > k) cout << "-1"; //nếu không có kết quả in ra -1
    else cout << floor (1, n); //in ra kết quả
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
44. DSA04016	PHẦN TỬ THỨ K
/*Cho hai mảng đã được sắp xếp A[], B[] gồm M, N phần tử theo thứ tự và số K. Nhiệm vụ của bạn là tìm phần tử ở vị trí
số K sau khi trộn hai mảng để nhận được một mảng được sắp xếp.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 3 dòng: dòng thứ nhất đưa vào số M, N, K; dòng tiếp theo đưa vào
M số của mảng A[];dòng tiếp theo đưa vào N số của mảng B[];các số được viết cách nhau một vài khoảng trống.
T, M,N, A[i], B[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤ N, A[i], B[i]≤106; 1≤ K≤N+M.
Output:
Đưa ra giá trị phần tử thứ K của mỗi test theo từng dòng.
Input                Output
1
5 4 5                6
2 3 6 7 9
1 4 8 10
*/
//Ý tưởng: gộp 2 mảng lại và đưa ra phần tử thứ k
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, m, k, a[1000005], b[1000005];
vector <int> c;

void init() { //hàm khởi tạo
    cin >> n >> m >> k;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
        c.push_back (a[i]); //đẩy a[i] vào c
    }
    for (long i = 0; i < m; i++) {
        cin >> b[i];
        c.push_back (b[i]); //đẩy b[i] vào c
    }
}

void solve() { //hàm xử lý
    sort (c.begin (), c.end ()); //sắp xếp lại c
    cout << c[k - 1] << endl; //đưa ra phần tử thứ k
    c.clear(); //làm mới c
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
45. DSA04017	PHẦN TỬ KHÁC NHAU
/*Cho hai mảng đã được sắp xếp A[] và B[] gồm N và N-1 phần tử. Các phần tử của mảng A[] chỉ khác mảng B[] một phần tử
duy nhất. Hãy tìm vị trí của phần tử khác nhau giữa A[] và B[].
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 3 dòng: dòng thứ nhất đưa vào số N; dòng tiếp theo đưa vào N số
của mảng A[];dòng tiếp theo đưa vào N-1 số của mảng B[]; các số được viết cách nhau một vài khoảng trống.
T, N, A[i], B[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤ N≤107; 0≤ A[i]≤1018.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
7                    5
2 4 6 8 9 10 12
2 4 6 8 10 12
6                    4
3 5 7 9 11 13
3 5 7 11 13
*/
/*Ý tưởng: chọn phần tử ở giữa. Nếu xuất hiện ở cả 2 mảng thì tìm ở nửa sau. Nếu khác nhau mà phần tử trước đó bằng nhau
thì trả về giá trị đó, ngược lại tìm ở nửa trước*/
//Code:

#include<bits/stdc++.h>
using namespace std;

long n, a[100005], b[100005];

void init() { //hàm khởi tạo
    cin >> n;
    for (long i = 1; i <= n; i++) cin >> a[i];
    for (long i = 1; i < n; i++) cin >> b[i];
}

long find(long x, long y) { //hàm tìm vị trí
    long z = (x + y) / 2; //chọn phần tử ở giữa
    if (a[z] == b[z]) return find (z + 1, y); //nếu có ở cả 2 mảng tìm ở nửa sau
    else if (a[z] != b[z] && a[z - 1] == b[z - 1]) return z; //nếu khác nhau mà phần tử trước bằng nhau trả về vị trí
    else return find (x, z - 1); //nếu không thì tìm ở nửa sau
}

void solve() { //hàm xử lý
    b[n] = 0; //thêm 1 số vào mảng b để tạo 2 mảng cùng số phần tử
    cout << find (1, n) << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
46. DSA04018	ĐẾM SỐ 0
/*Cho mảng A[] gồm N phần tử chỉ bao gồm các số 0 và 1. Các số 0 được đặt trước các số 1. Hãy đếm các số 0 với thời gian
log(N).
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất đưa vào số N; dòng tiếp theo đưa vào N số
của mảng A[]; các số được viết cách nhau một vài khoảng trống.
T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤ N≤1000; 0≤ A[i]≤1.
Output:
Đưa ra kết quả mỗi test theo từng dòng
Input                     Output
3
12                        9
0 0 0 0 0 0 0 0 0 1 1 1
5                         5
0 0 0 0 0
6                         0
1 1 1 1 1 1
*/
/*Ý tưởng: Tìm phần tử ở giữa. Nếu nó là số 1 và trước nó là số 0 in ra chỉ mục của nó trừ đi 1, còn không thì tìm ở nửa
trước. Nếu nó là số 0 và sau nó là số 1 thì trả về chỉ mục của nó, còn không thì tìm ở nửa sau*/
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, a[1005];

void init() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
}

int cnt(int x, int y) {
    int z = (x + y) / 2;
    if (a[z] == 0) { //nếu tìm thấy số 0
        if (a[z + 1] == 1) return z; //nếu sau nó là số 1 trả về chỉ mục của nó
        else return cnt (z + 1, y); //nếu không tìm ở nửa sau
    } else { //nếu tìm thấy số 1
        if (a[z - 1] == 0) return z - 1; //nếu trước nó là số 0 trả về chỉ mục trước nó
        else return cnt (x, z - 1); //nếu không tìm ở nửa trước
    }
}

void solve() {
    if (a[1] == 1) cout << 0; //nếu mảng toàn số 1 in ra 0
    else if (a[n] == 0) cout << n; //nếu mảng toàn số 0 in ra n
    else cout << cnt (1, n); //in ra kết quả
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
47. DSA05001	XÂU CON CHUNG DÀI NHẤT
/*Cho 2 xâu S1 và S2. Hãy tìm xâu con chung dài nhất của 2 xâu này (các phần tử không nhất thiết phải liên tiếp nhau).
Input: Dòng đầu tiên là số lượng bộ test T (T ≤ 20). Mỗi test gồm hai dòng, mô tả xâu S1 và S2, mỗi xâu có độ dài không
quá 1000 và chỉ gồm các chữ cái in hoa.
Output:  Với mỗi test, in ra độ dài dãy con chung dài nhất trên một dòng.
Ví dụ:
Input                Output
2
AGGTAB               4
GXTXAYB
AA                   0
BB
*/
/*Ý tưởng: duyệt qua 2 xâu nếu kí tự giống nhau thì bằng dãy con lớn nhất trước đó cộng 1, nếu khác nhau thì bằng max
của dãy con chung dài nhất của xâu con trước của str1 với xâu con của str2 và dãy con chung dài nhất của xâu con của
str1 với xâu con trước của str2*/
//Code:

#include<bits/stdc++.h>
using namespace std;

string str1, str2;
int n, m, dp[1005][1005]; //mảng dp lưu trữ độ dài độ dài xâu con chung dài nhất

void init() { //hàm khởi tạo
    cin >> str1;
    cin >> str2;
}

void solve() { //hàm xử lý
    int n = str1.length ();
    int m = str2.length ();
    //1 trong 2 xâu rỗng thì độ dài xâu con chung dài nhất là 0
    for (int i = 0; i <= n; i++) dp[i][0] = 0;
    for (int i = 0; i <= m; i++) dp[0][i] = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            //nếu ký tự cuối cùng của 2 xâu con giống nhau thì bằng độ dài xâu con chung trước cộng 1
            if (str1[i - 1] == str2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
            else {
                /*
                nếu ký tự cuối cùng khác nhau thì độ dài xâu con dài nhất sẽ là max của xâu trước đó của xâu 1 và
                xâu 2 với xâu trước đó của xâu 2 với xâu 1
                 */
                dp[i][j] = max (dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    cout << dp[n][m] << endl; //in ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
48. DSA05004	DÃY CON TĂNG DÀI NHẤT
//
// Created by KhanhNVTB on 26/04/2021.
//
/*Cho 2 xâu S1 và S2. Hãy tìm xâu con chung dài nhất của 2 xâu này (các phần tử không nhất thiết phải liên tiếp nhau).
Input: Dòng đầu tiên là số lượng bộ test T (T ≤ 20). Mỗi test gồm hai dòng, mô tả xâu S1 và S2, mỗi xâu có độ dài không
quá 1000 và chỉ gồm các chữ cái in hoa.
Output:  Với mỗi test, in ra độ dài dãy con chung dài nhất trên một dòng.
Ví dụ:
Input                Output
2
AGGTAB               4
GXTXAYB
AA                   0
BB
*/
/*Ý tưởng: duyệt qua 2 xâu nếu kí tự giống nhau thì bằng dãy con lớn nhất trước đó cộng 1, nếu khác nhau thì bằng max
của dãy con chung dài nhất của xâu con trước của str1 với xâu con của str2 và dãy con chung dài nhất của xâu con của
str1 với xâu con trước của str2*/
//Code:

//
// Created by KhanhNVTB on 05/05/2021.
//
/*Cho một dãy số nguyên gồm N phần tử A[1], A[2], ... A[N].
Biết rằng dãy con tăng là 1 dãy A[i1],... A[ik] thỏa mãn i1 < i2 < ... < ik và A[i1] < A[i2] < .. < A[ik].
Hãy cho biết dãy con tăng dài nhất của dãy này có bao nhiêu phần tử?
Input: Dòng 1 gồm 1 số nguyên là số N (1 ≤ N ≤ 1000). Dòng thứ 2 ghi N số nguyên A[1], A[2], .. A[N] (1 ≤ A[i] ≤ 1000).
Output: Ghi ra độ dài của dãy con tăng dài nhất.
Input                Output
6                    4
1 2 5 4 6 2
*/
/*Ý tưởng: Duyệt xâu con lần lượt đến phần tử thứ i của xâu mẹ. Nếu a[i]>a[j] thì độ dài dãy con bằng max của dãy con
lớn nhất đến j cộng 1 với dãy con lớn nhất hiện tại*/
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, res, a[1005], dp[1005]; //mảng dp lưu độ dài dãy con tăng dài nhất tại vị trí i

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    res = 0; //gán kết quả bằng 0
    for (int i = 1; i <= n; i++) {
        dp[i] = 1; //gán dãy con dài nhất tại vị trí i là 1
        for (int j = 1; j < i; j++) //duyệt qua đoạn từ đầu tới i
            if (a[i] > a[j]) dp[i] = max (dp[i], dp[j] + 1); //nếu tìm được phần tử nhỏ hơn cập nhật kết quả
        res = max (res, dp[i]); //so sánh với kết quả hiện tại
    }
    cout << res << endl; //đưa ra kết quả
}

int main() {
    init ();
    solve ();
    return 0;
}
49. DSA05008	DÃY CON CÓ TỔNG BẰNG S 
/*Cho N  số nguyên dương tạo thành dãy A={A1, A2, ..., AN}. Tìm ra một dãy con của dãy A (không nhất thiết là các phần
tử liên tiếp trong dãy) có tổng bằng S cho trước.
Input: Dòng đầu ghi số bộ test T (T<10).  Mỗi bộ test có hai dòng, dòng đầu tiên ghi hai số nguyên dương N và S
(0 < N ≤ 200) và S (0 < S ≤ 40000). Dòng tiếp theo lần lượt ghi N số hạng của dãy A là các số A1, A2, ..., AN
(0 < Ai ≤ 200).
Output:  Với mỗi bộ test, nếu bài toán vô nghiệm thì in ra “NO”, ngược lại in ra “YES”
Input                 Output
2
5 6                   YES
1 2 4 3 5
10 15                 NO
2 2 2 2 2 2 2 2 2 2
*/
/*Ý tưởng: Tạo mảng dp lưu các tổng có thể tạo thành. Duyệt qua các các phần tử gán có thể tạo thành tổng là phần tử đó.
Nếu tại j mà dp[j-a[i]] có thể được tạo thành thì có thể tạo thành j. Nếu j bằng s tức là có thể tạo thành s*/
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, s, a[205], dp[40005];

void init() { //hàm khởi tạo
    cin >> n >> s;
    memset (dp, 0, sizeof (dp)); //gán tất cả các tổng không thể tạo thành
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        dp[a[i]] = 1; //có thể tạo thành tổng bằng phần tử a[i];
    }
}

void solve() { //hàm xử lý
    for (int i = 1; i <= n; i++) { //duyệt qua tất cả phần tử
        for (long j = s; j > a[i]; j--) { //duyệt qua các tổng không lớn hơn s
            if (dp[j - a[i]] == 1) { //nếu có thể tạo thành tổng nào thì đánh dấu
                dp[j] = 1;
                if (j == s) break; //nếu tổng được tạo thành bằng s thì dừng vòng lặp
            }
        }
        if(dp[s]==1) break;
    }
    if (dp[s]) cout << "YES"; //in ra kết quả
    else cout << "NO";
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
50. DSA05012	TỔ HỢP C(n, k)
/*Cho 2 số nguyên n, k. Bạn hãy tính C(n, k) modulo 109+7.
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test gồm 2 số nguyên n, k (1 ≤ k ≤ n ≤ 1000).
Output:
Với mỗi test, in ra đáp án trên một dòng.
Input                   Output
2
5 2                     10
10 3                    120
*/
//Ý tưởng: Áp dụng tính chất của tổ hợp
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, k;
long  dp[1001][1001], m=1e9+7;

void init() {
    cin >> n >> k;
}

void solve() { //hàm xử lý
    //tìm tất cả các tổ hợp trong phạm vi
    for (int i = 1; i <= 1000; i++) dp[1][i] = i; //tổ hợp chập 1 của i luôn bằng i
    for (int i = 2; i <= 1000; i++)
        for (int j = 2; j <= i; j++)
            dp[j][i] = (dp[j][i - 1] + dp[j - 1][i - 1]) % m; //tính tổ hợp chập j của i dựa vào tính chất của tổ hợp
}

int main() {
    int t;
    cin >> t;
    solve ();
    while (t--) {
        init ();
        cout << dp[k][n] << endl; //đưa ra kết quả
    }
    return 0;
}
51. DSA05013	BẬC THANG
/*Một chiếc cầu thang có N bậc. Mỗi bước, bạn được phép bước lên trên tối đa K bước. Hỏi có tất cả bao nhiêu cách bước
để đi hết cầu thang? (Tổng số bước đúng bằng N).
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 100).
Mỗi test gồm hai số nguyên dương N và K(1 ≤ N ≤ 100000, 1 ≤ K ≤ 100).
Output:
Với mỗi test, in ra đáp án tìm được trên một dòng theo modulo 10^9+7.
Input                 Output
2
2 2                   2
4 2                   5
*/
//Ý tưởng: số cách bước bằng tổng số cách bước đến bậc n-i với i<=k
//Code:

#include <bits/stdc++.h>
using namespace std;

long n, k, m=1e9+7, a[1005];

void init() { //hàm khởi tạo
    cin >> n >> k;
}

void solve() { //hàm xử lý
    a[0] = 1, a[1] = 1; //khởi tạo giá trị ban đầu
    for (int i = 2; i <= n; i++) {
        a[i] = 0; //gán số cách bước bằng 0
        for (int j = 1; j <= k; j++) { //tìm các cách bước đến bậc trước nó
            if (j <= i) {
                a[i] += a[i - j] % m; //cập nhật số cách bước
            }
        }
    }
    cout << a[n]%m << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
52. DSA05002	DÃY CON LẶP LẠI DÀI NHẤT
/*Cho xâu ký tự S. Nhiệm vụ của bạn là tìm độ dài dãy con lặp lại dài nhất trong S. Dãy con có thể chứa các phần tử
không liên tiếp nhau.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên đưa vào độ dài xâu str; dòng tiếp theo
đưa vào xâu S.
T, str thỏa mãn ràng buộc: 1 ≤ T ≤ 100;  1 ≤ size(S) ≤ 100.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
2
3                     0
abc
5                     2
axxxy
*/
/*Ý tưởng: so sánh 2 xâu con nếu có ký tự được lặp lại thì dãy lặp dài nhất bằng dãy lặp của 2 xâu con trước đó cộng 1,
còn khác nhau thì bằng max của dãy lặp của xâu con 1 và xâu con trước của xâu con 2 với xâu con trước của xâu con 1 và
xâu con 2*/
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, dp[105][105]; //mảng dp lưu trữ giá trị dãy con lặp lại dài nhất với độ dài 2 xâu con là i và j
string str;

void init() { //hàm khởi tạo
    cin >> n;
    cin >> str;
}

void solve() { //hàm xử lý
    for (int i = 0; i <= n; i++)
        for (int j = 0; j <= n; j++) {
            if (i == 0 || j == 0) dp[i][j] = 0; //dãy lặp dài nhất của xâu rỗng là 0
            else if (str[i - 1] == str[j - 1] && i != j) dp[i][j] = dp[i - 1][j - 1] + 1; //cập nhật kết quả
            else dp[i][j] = max (dp[i - 1][j], dp[i][j - 1]);
        }
    cout << dp[n][n] << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
53. Số bước ít nhất
/*Cho mảng A[] gồm N số nguyên. Nhiệm vụ của bạn là sắp xếp lại mảng số với số lượng bước là ít nhất. Tại mỗi bước, bạn
chỉ được phép chèn phần tử bất kỳ của mảng vào vị trí bất kỳ trong mảng. Ví dụ A[] = {2, 3, 5, 1, 4, 7, 6 }sẽ cho ta số
phép chèn ít nhất là 3 bằng cách lấy số 1 chèn trước số 2, lấy số 4 chèn trước số 5, lấy số 6 chèn trước số 7 ta nhận
được mảng được sắp.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất là một số N; dòng tiếp theo đưa vào N số
của mảng A[]; các số được viết cách nhau một vài khoảng trống.
T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤N ≤1000; 1≤A[i] ≤1000.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
1
7                     3
2 3 5 1 4 7 6
*/
//Ý tưởng: Số bước đổi chỗ ít nhất bằng độ dài của mảng trừ đi độ dài dãy con tăng dài nhất
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, a[1005], dp[1005];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    int tmp = 0; //khởi tạo độ dài dãy con tăng dài nhất bằng 0
    for (int i = 1; i <= n; i++) {
        dp[i] = 1; //khởi tạo dãy con tăng dài nhất tại 1 vị trí luôn bằng 1
        for (int j = 1; j < i; j++)
            if (a[i] >= a[j]) dp[i] = max (dp[i], dp[j] + 1); //nếu tìm được phần tử nhỏ hơn cập nhật giá trị dp[i]
        tmp = max (tmp, dp[i]); //so sánh với giá trị dãy con dài nhất hiện tại
    }
    cout << n - tmp << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
54. DSA05025	CON ẾCH
/*Một con ếch có thể nhảy 1, 2, 3 bước để có thể lên đến một đỉnh cần đến. Hãy đếm số các cách con ếch có thể nhảy đến
đỉnh.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là số n là số bước con ếch có thể lên được đỉnh.
T, n thỏa mãn ràng buộc: 1≤T≤100;  1≤n ≤50.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
2
1                     1
5                     13
*/
//Ý tưởng: tương tự bài bậc thang với k = 3
//Code:

#include <bits/stdc++.h>
using namespace std;

int n;
long dp[55]; //mảng dp lưu trữ sô cách nhảy

void init() { //hàm khởi tạo
    cin >> n;
}

void solve() { //hàm xử lý
    dp[0] = 1, dp[1] = 1, dp[2] = 2; //khởi tạo giá trị ban đầu
    for (int i = 3; i <= n; i++) {
        dp[i] = 0;
        dp[i] += dp[i - 1] + dp[i - 2] + dp[i - 3]; //cập nhật số cách nhảy
    }
    cout << dp[n] << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
55. DSA05026	XEM PHIM
/*John có một đàn bò. Một ngày đẹp trời, anh ta quyết định mua xe tải với khả năng chở được C kg (1000 ≤ C ≤ 25000) để
đưa những con bò đi xem phim. Cho số con bò là N (20 ≤ N ≤ 100) và khối lượng w[i] của từng con (đều nhỏ hơn C), hãy cho
biết khối lượng bò lớn nhất mà John có thể đưa đi xem phim là bao nhiêu.
Input:
Dòng 1: 2 số nguyên C và N cách nhau bởi dấu cách
Dòng 2..N+1:   Ghi lần lượt các số nguyên: w[i]
Output:
Một số nguyên là tổng khối lượng bò lớn nhất mà John có thể mang đi xem phim
Input                  Output
259 5                  242
81
58
42
33
61
*/
/*Ý tưởng: Nếu con bò có khối lượng không lớn hơn khả năng chở còn lại thì khối lượng tối đa bằng khối lượng trước đó
cộng với khối lượng con bò hiện tại*/
//Code:

#include <bits/stdc++.h>
using namespace std;

int c, n, w[105];

void init() { //hàm khởi tạo
    cin >> c >> n;
    for (int i = 1; i <= n; i++) cin >> w[i];
}

void solve() {
    int dp[n + 1][c + 1]; //mảng dp lưu trữ khối lượng tối đa tại i con bò
    memset (dp, 0, sizeof (dp)); //khởi tạo số con bò tối đa là 0
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= c; j++) {
            if (w[i] <= j) dp[i][j] = max (w[i] + dp[i - 1][j - w[i]], dp[i - 1][j]); //nếu chở con bò này
            else dp[i][j] = dp[i - 1][j]; //nếu không chở con bò này
        }
    cout << dp[n][c]; //đưa ra kết quả
}

int main() {
    init ();
    solve ();
    return 0;
}
56. DSA05027	CÁI TÚI
/*Một người có cái túi thể tích V (V<1000). Anh ta có N đồ vật cần mang theo (N≤1000), mỗi đồ vật có thể tích là A[i]
(A[i]≤100) và giá trị là C[i] (C[i]≤100). Hãy xác định tổng giá trị lớn nhất của các đồ vật mà người đó có thể mang theo
sao cho tổng thể tích không vượt quá V.
Input
Dòng đầu ghi số bộ test T (T<10)
Mỗi bộ test gồm ba dòng. Dòng đầu ghi 2 số N và V. Dòng tiếp theo ghi N số của mảng A. Sau đó là một dòng ghi N số của
mảng C.
Dữ liệu vào luôn đảm bảo không có đồ vật nào có thể tích lớn hơn V.
Output
Với mỗi bộ test, ghi trên một dòng giá trị lớn nhất có thể đạt được.
Input                            Output
1
15 10                            15
5 2 1 3 5 2 5 8 9 6 3 1 4 7 8
1 2 3 5 1 2 5 8 7 4 1 2 3 2 1
*/
/*Ý tưởng: Nếu đồ vật được sử dụng giá trị sử dụng bằng giá trị sử dụng trước đó cộng với giá trị sử dụng của đồ vật,
còn đồ vật không được sử dụng thì giá trị sử dụng bằng giá trị sử dụng trước đó*/
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, v, a[1005], c[1005], dp[1005][1005];

void init() {
    cin >> n >> v;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) cin >> c[i];
}

void solve() {
    for (int i = 0; i <= n; i++)
        for (int j = 0; j <= v; j++) dp[i][j] = 0; //túi rỗng thì giá trị sử dụng bằng 0
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= v; j++) {
            //nếu thể tích còn lại lớn hơn thể tích của đồ vật kiểm tra xem sử dụng hay không sử dụng đồ vật sẽ tối ưu
            if (j >= a[i]) dp[i][j] = max (dp[i - 1][j], c[i] + dp[i - 1][j - a[i]]);
                //nếu thể tích còn lại nhỏ hơn thể tích của đồ vật thì giá trị sử dụng không đổi
            else dp[i][j] = dp[i - 1][j];
        }
    cout << dp[n][v] << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
57. DSA05029	GIẢI MÃ
/*Một bản tin M đã mã hóa bí mật thành các con số theo ánh xạ như sau: ‘A’->1, ‘B’->2, .., ‘Z’->26. Hãy cho biết có bao
nhiêu cách khác nhau để giải mã bản tin M. Ví dụ với bản mã M=”123” nó có thể được giải mã thành ABC (1 2 3), LC (12 3),
AW(1 23).
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một xâu ký tự số M.
T, M thỏa mãn ràng buộc: 1≤T≤100;  1≤length(M)≤40.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
2
123                   3
2563                  2
*/
/*Ý tưởng: Số có 1 chữ số thì chỉ có 1 cách giải mã, số có 2 chữ số nhỏ hơn 27 có 2 cách giải mã. Tạo mảng dp lưu trữ số
cách giải mã dựa vào những xâu con nhỏ hơn*/
//Code:

#include <bits/stdc++.h>
using namespace std;

string str;
int n, dp[45]; //mảng dp lưu số cách giải mã của xâu có độ dài i

void init() { //hàm khởi tạo
    cin >> str;
}

void solve() { //hàm xử lý
    n = str.length ();
    if (str[0] == '0') cout << "0"; //trường hợp số 0 ở đầu không thể giải mã
    else {
        dp[0] = 1, dp[1] = 1; //khởi tạo cấu hình ban đầu
        for (int i = 2; i <= n; i++) {
            dp[i] = 0;
            if (str[i - 1] > '0') dp[i] = dp[i - 1]; //trường hợp là chữ số lớn hơn 0 cách giải không đổi
            //trường hợp thuộc khoảng từ 10 đến 26 thì có thêm 1 cách giải mã
            if (str[i - 2] == '1' || str[i - 2] == '2' && str[i - 1] < '7') dp[i] += dp[i - 2];
        }
        cout << dp[n]; //đưa ra kết quả
    }
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
58. DSA06001	SẮP XẾP XEN KẼ
/*Cho mảng A[] gồm n số nguyên khác nhau. Hãy đưa ra các phần tử của mảng theo khuôn dạng lớn nhất, nhỏ nhất, lớn thứ
hai, nhỏ thứ 2, … Ví dụ với A[] = {9, 7, 12, 8, 6, 5} ta đưa ra : 12, 5, 9, 6, 8, 7.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên là số phần tử của mảng n; dòng tiếp theo
là n số A [i] của mảng A [];các số được viết cách nhau một vài khoảng trống.
T, n thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n ≤103.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
7                    7 1 6 2 5 3 4
7 1 2 3 4 5 6
8                    9 1 8 2 7 3 6 4
1 6 9 4 3 7 8 2
*/
//Ý tưởng: Sắp xếp lại mảng. Sau đó đưa các phần tử lớn nhất vào vị trí chẵn và nhỏ nhỏ nhất vào vị trí lẻ
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, a[1005];

void init(){ //hàm khởi tạo
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
}

void solve() { //hàm xử lý
    sort (a, a + n); //sắp xếp lại mảng
    for (int i = 0; i < n; i += 2) cout << a[n - 1 - i / 2] << " " << a[i / 2] << " "; //đưa ra kết quả theo khuôn dạng
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
59. DSA06002	SẮP XẾP THEO GIÁ TRỊ TUYỆT ĐỐI
/*Cho mảng A[] gồm n phần tử và số X. Hãy đưa sắp xếp các phần tử của mảng theo trị tuyệt đối của |X - A[i] |. Ví dụ với
A[] = {10, 5, 3, 9, 2} và X = 7 ta đưa ra mảng được sắp xếp theo nguyên tắc kể trên: A[] = {5, 9, 10, 3, 2} vì |7-10|=3,
|7-5|=2, |7-3|=4, |7-9|=2, |7-2|=5.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên là số phần tử của mảng n và X; dòng tiếp
theo là n số A [i] của mảng A [];các số được viết cách nhau một vài khoảng trống.
T, n, X thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n, X, A[i] ≤105.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
2
5 7                   5 9 10 3 2
10 5 3 9 2
5 6                   5 4 3 2 1
1 2 3 4 5
*/
//Ý tưởng:  kiểm tra nếu giá trị tuyệt đối của 2 phần tử không đúng thứ tự thì đổi chỗ
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, x, a[10005];

void init() { //hàm khởi tạo
    cin >> n >> x;
    for (long i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    for (long i = 0; i < n - 1; i++)
        for (long j = 0; j < n - i - 1; j++)
            //thực hiện đổi chỗ nếu không đúng thứ tự
            if (abs (x - a[j]) > abs (x - a[j + 1])) swap (a[j], a[j + 1]);
    for (long i = 0; i < n; i++) cout << a[i] << " "; //đưa ra kết quả
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
60. DSA06003	ĐỔI CHỖ ÍT NHẤT
/*Cho mảng A[] gồm n phần tử. Hãy tìm số phép đổi chỗ ít nhất giữa các phần tử của mảng để mảng A[] được sắp xếp. Ví dụ
với A[] = {4, 3, 2, 1} ta cần thực hiện ít nhất 2 phép đổi chỗ: Swap(A[0], A[3]),  Swap(A[1], A[2]).
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên là số phần tử của mảng n và X; dòng tiếp
theo là n số A [i] của mảng A [];các số được viết cách nhau một vài khoảng trống.
T, n thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n ≤103.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
2
4                     2
4 3 2 1
5                     2
1 5 4 3 2
*/
//Ý tưởng: Sử dụng sắp xếp chọn
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, a[1000], res;

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void solve() {
    res = 0;
    int check, pos;
    for (int i = 0; i < n - 1; i++) { //duyệt qua mảng
        check = 0;
        pos = i;
        for (int j = i + 1; j < n; j++) //tìm phần tử nhỏ nhất sau phần tử i
            if (a[j] < a[pos]) {
                pos = j;
                check = 1;
            }
        if (check) { //nếu tìm được thì đổi chỗ với phần tử tại i và tăng kết quả
            res++;
            swap (a[i], a[pos]);
        }
    }
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
61. DSA06004	HỢP VÀ GIAO CỦA HAI DÃY SỐ 1
/*Cho mảng A[] gồm n phần tử, mảng B[] gồm m phần tử khác nhau. Các phần tử của mảng A[] và B[] đã được sắp xếp. Hãy tìm
mảng hợp và giao được sắp giữa A[] và B[]. Ví dụ với A[] = {1, 3, 4, 5, 7}, B[]={2, 3, 5, 6} ta có mảng hợp
Union = {1, 2, 3, 4, 5, 6, 7}, mảng giao Intersection = {3, 5}. In ra đáp án theo giá trị phần tử từ nhỏ đến lớn.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm ba dòng: dòng đầu tiên đưa vào n, m là số phần tử của mảng A[] và
B[]; dòng tiếp theo là n số A [i] của mảng A [];dòng tiếp theo là m số B[i] của mảng B[]; các số được viết cách nhau một
vài khoảng trống.
T, n, m, A[i], B[i] thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n, m, A[i], B[i] ≤105.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
*/
/*Ý tưởng: Đưa hết các phần tử của 2 mảng vào 1 vector sau đó sắp xếp lại. Mảng hợp là tất cả các phần tử khác nhau của
vector, mảng giao là phần tử xuất hiện 2 lần trong vector*/
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, m, tmp;
vector <int> c;

void init() { //hàm khởi tạo
    cin >> n >> m;
    c.clear (); //làm trống vector c
    for (long i = 0; i < n; i++) {
        cin >> tmp;
        c.push_back (tmp); //đưa phần tử của mảng a vào c
    }
    for (long i = 0; i < m; i++) {
        cin >> tmp;
        c.push_back (tmp); //đưa phần tử của mảng b vào c
    }
}

void solve() { //hàm xử lý
    sort (c.begin (), c.end ()); //sắp xếp lại mảng a
    cout << c[0] << " "; //in ra mảng hợp
    for (int i = 1; i < c.size (); i++)
        if (c[i] != c[i - 1]) cout << c[i] << " "; //các phần tử chỉ được in đúng 1 lần
    cout << endl;
    for (int i = 0; i < c.size () - 1; i++) //in ra mảng giao
        if (c[i] == c[i + 1]) cout << c[i] << " "; //phần tử xuất hiện 2 lần thuộc mảng giao
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
62. HỢP VÀ GIAO CỦA HAI DÃY SỐ 2
/*Cho mảng A[] gồm n phần tử, mảng B[] gồm m phần tử khác nhau. Các phần tử của mảng A[] và B[] chưa được sắp xếp. Hãy
tìm mảng hợp và giao được sắp giữa A[] và B[]. Ví dụ với A[] = {7, 1, 5, 2, 3, 6}, B[]={3, 8, 6, 20, 7} ta có mảng hợp
Union = {1, 2, 3, 5, 6, 7, 8, 20}, mảng giao Intersection = {3, 6}.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm ba dòng: dòng đầu tiên đưa vào n, m là số phần tử của mảng A[] và
B[]; dòng tiếp theo là n số A [i] của mảng A [];dòng tiếp theo là m số B[i] của mảng B[]; các số được viết cách nhau một
vài khoảng trống.
T, n, m, A[i], B[i] thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n, m, A[i], B[i] ≤105.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
1
6 5                  1 2 3 5 6 7 8 20
7 1 5 2 3 6          3 6
3 8 6 20 7
*/
//Ý tưởng: Giống hệt bài " HỢP VÀ GIAO CỦA HAI DÃY SỐ 1 "
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, m, tmp;
vector <int> c;

void init() { //hàm khởi tạo
    cin >> n >> m;
    c.clear (); //làm trống vector c
    for (long i = 0; i < n; i++) {
        cin >> tmp;
        c.push_back (tmp); //đưa phần tử của mảng a vào c
    }
    for (long i = 0; i < m; i++) {
        cin >> tmp;
        c.push_back (tmp); //đưa phần tử của mảng b vào c
    }
}

void solve() { //hàm xử lý
    sort (c.begin (), c.end ()); //sắp xếp lại mảng a
    cout << c[0] << " "; //in ra mảng hợp
    for (int i = 1; i < c.size (); i++)
        if (c[i] != c[i - 1]) cout << c[i] << " "; //các phần tử chỉ được in đúng 1 lần
    cout << endl;
    for (int i = 0; i < c.size () - 1; i++) //in ra mảng giao
        if (c[i] == c[i + 1]) cout << c[i] << " "; //phần tử xuất hiện 2 lần thuộc mảng giao
    cout << endl;
}
63. DSA06006	SẮP XẾP [0 1 2]
int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
/*Cho mảng A[] gồm n phần tử. Các phần tử của mảng A[] chỉ bao gồm các số 0, 1, 2. Hãy sắp xếp mảng A[] theo thứ tự tăng
dần. Ví dụ với A[] = {0, 2, 1, 2, 0} ta kết quả A[] = {0, 0, 1, 2, 2}.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên đưa vào n là số phần tử của mảng A[]; dòng
tiếp theo là n số A [i] của mảng A []các số được viết cách nhau một vài khoảng trống.
T, n, A[i] thỏa mãn ràng buộc: 1≤ T ≤100; 0≤ A[i] ≤2; 1≤ n ≤106.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
5
0 2 1 2 0            0 0 1 2 2
3
0 1 0                0 0 1
*/
//ý tưởng: Sắp xếp lại mảng
//Code:

#include<bits/stdc++.h>
using namespace std;
int n, a[1000005];

void init(){ //hàm khởi tạo
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
}

void solve() { //hàm xủ lý
    sort (a, a + n); //sắp xếp lại mảng
    for (int i = 0; i < n; i++) cout << a[i] << " "; //đưa ra kết quả
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
64. DSA06007	SẮP XẾP DÃY CON LIÊN TỤC
/*Cho mảng A[] gồm n phần tử. Hãy tìm dãy con liên tục của mảng A[R], .., A[L] sao cho khi sắp xếp lại dãy con ta nhận
được một mảng được sắp xếp. Ví dụ với A[] = {10, 12, 20, 30, 25, 40, 32, 31, 35, 50, 60} ta chỉ cần sắp xếp lại dãy con
từ A[4],.., A[9]: {30, 25, 40, 32, 31, 35} để có mảng được sắp.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên đưa vào n là số phần tử của mảng A[]; dòng
tiếp theo là n số A [i] của mảng A []các số được viết cách nhau một vài khoảng trống.
T, n, A[i] thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n ≤106; 0≤ A[i] ≤107.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                                 Output
2
11                                    4 9
10 12 20 30 25 40 32 31 35 50 60
9                                     3 6
0 1 15 25 6 7 30 40 50
*/
/*Ý tưởng: tìm từ trái qua phần tử đầu tiên không sắp xếp đúng đánh dấu là vị trí l, tìm từ phải qua tìm phần tử đầu
tiên không sắp xếp đúng đánh dấu là r. tìm min và max trong khoảng l và r. So sánh min với khoảng bên trái l tìm phần tử
nhỏ hơn min cập nhật vị trí l, so sánh max với khoảng bên phải r tìm phần tử đầu tiên lớn hơn max cập nhật vị trí r*/
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, a[1000005];

void init() { //hàm khởi tạo
    cin >> n;
    for (long i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    int l = 0, r = n - 1; //khởi tạo 2 giá trị l và r
    while (a[l] <= a[l + 1] && l < n - 1) l++; //tìm phần tử đầu tiên sai thứ tự từ bên trái
    while (a[r] >= a[r - 1] && r > 0) r--; //tìm phần tử đầu tiên sai thứ tự từ bên phải
    long min = a[l], max = a[l]; //khởi tạo min và max của đoạn từ l đến r
    for (long i = l + 1; i <= r; i++) {
        if (a[i] < min)min = a[i]; //tìm min của đoạn l,r
        if (a[i] > max) max = a[i]; //tìm max của đoạn l,r
    }
    for (long i = 0; i <= l; i++) //tìm phần tử bên trái đấu tiên nhỏ hơn l thì cập nhật vị trí l
        if (a[i] > min) {
            l = i + 1;
            break;
        }
    for (long i = n - 1; i >= r; i--) //tìm phần  tử bên phải đấu tiền lớn hơn r thì cập nhật vị trí r
        if (a[i] < max) {
            r = i + 1;
            break;
        }
    cout << l << " " << r << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
65. DSA06008	ĐẾM CẶP
/*Cho mảng X[] gồm n phần tử và mảng Y[] gồm m phần tử. Hãy đếm số các cặp x^y>y^x, trong đó x€X[] và y€Y[]. Ví dụ X[] =
{2, 1, 6 }, Y[] = {1, 5} ta có kết quả là 3 cặp (2, 1), (2, 5), (6, 1).
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm ba dòng: dòng đầu tiên đưa vào n, m tương ứng với số phần tử của
mảng X[] và Y[]; dòng tiếp theo là n số X[i] của mảng X[]; dòng cuối cùng là m số của mảng Y[]; các số được viết cách
nhau một vài khoảng trống.
T, n, m, X[i], Y[j] thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n, m ≤105; 0≤ X[i], Y[j] ≤103.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
1
3 2                  3
2 1 6
1 5
*/
//Ý tưởng: Ngoài các cặp (2,3), (2,4), (1,y), (0,y) ra thì tất cả các cặp (x,y) với x<y đều cho x^y>y^x
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, m, a[100005], b[100005];

void init() { //hàm khởi tạo
    cin >> n >> m;
    for (long i = 0; i < n; i++) cin >> a[i];
    for (long i = 0; i < m; i++) cin >> b[i];
}

void solve() { //hàm xử lý
    sort (a, a + n); //sắp xếp lại mảng a
    sort (b, b + n); //sắp xếp lại mảng b
    int res = 0; //khởi tạo biến kết quả
    int cnt0 = 0, cnt1 = 0, h = 0; //khởi tạo biến đếm số 0, số 1, và biến vị trí h
    for (int i = 0; i < m; i++) {
        if (b[i] == 0) cnt0++; //đếm số 0
        else if (b[i] == 1) cnt1++; //đếm số 1
        else break;
    }
    for (long i = 0; i < n; i++) {
        if (a[i] == 1) res += cnt0; //1^0>0^1
        else if (a[i] == 2) {
            res += cnt0; //2^0>0^2
            res += cnt1; //2^1>1^2
            for (long j = 0; j < m; j++)
                if (b[j] > 4) { //mọi y > 4 thì 2^y>y^2
                    res += m - j;
                    break;
                }
        } else if (a[i] == 3) {
            res += cnt0; //3^0>0^3
            res += cnt1; //3^1>1^3
            for (long j = 0; j < m; j++) {
                if (b[j] == 2) res++; //3^2>2^3
                else if (b[j] > 3) { //mọi y >3 thì 3^y>y^3
                    res += m - j;
                    break;
                }
            }
        } else if (a[i] > 3) {
            res += cnt0; //x^0>0^x với mọi x>3
            res += cnt1; //x^1>1^x với mọi x>3
            for (int j = h; j < m; j++) {
                if (b[j] > a[i]) { //x^y>y^x với mọi x<y và x và y >3
                    res += m - j;
                    h = j; //do mảng đã sắp xếp nên chỉ cần so sánh a[i] với phần tử sau j
                    break;
                }
            }
        }
    }
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
66. DSA06009	CẶP SỐ TỔNG BẰNG K
/*Cho mảng A[] gồm n phần tử và số k. Đếm tất cả các cặp phần tử của mảng có tổng bằng k. Ví dụ A[] = {1, 5, 3, 4, 2 },
k = 7 ta có kết quả là 2 cặp (3, 4), (5, 2).
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên đưa vào n là số phần tử của mảng A[] và k;
dòng tiếp theo là n số A[i] của mảng A[]các số được viết cách nhau một vài khoảng trống.
T, n, k, A[i] thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n ≤100; 0≤ k ≤100, 0≤ A[i] ≤103.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
5 9                  1
1 5 4 1 2
3 2                  3
1 1 1
*/
//Ý tưởng: Duyệt trâu kiểm tra xem cặp nào có tổng bằng k thì tăng kết quả
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, k, a[105];

void init() { //hàm khởi tạo
    cin >> n >> k;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    int res = 0;
    for (int i = 0; i < n - 1; i++)
        for (int j = i + 1; j < n; j++)
            if (a[i] + a[j] == k) res++; //tìm thấy cặp số tổng bằng k tăng kết quả
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
67. DSA06010	SẮP XẾP CHỮ SỐ 
/*Cho mảng A[] gồm n phần tử. Nhiệm vụ của bạn là đưa ra mảng đã được sắp xếp bao gồm các chữ số của mỗi phần tử trong
A[]. Ví dụ A[] = {110, 111, 112, 113, 114 }ta có kết quả là {0, 1, 2, 3, 4}.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên đưa vào n là số phần tử của mảng A[]; dòng
tiếp theo là n số A[i] ; các số được viết cách nhau một vài khoảng trống.
T, n, A[i] thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n ≤107; 0≤ A[i] ≤1016.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
*/
/*Ý tưởng: tạo 1 mảng kiểm tra kiểm tra xem chữ số hiện tại đã sử dụng chưa. Nếu chưa sử dụng thì thêm vào vector kết
quả. Nếu đã đủ hết các chữ số thì dừng lại. Sắp xếp lại mảng kêt quả và in*/
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, used[10];
vector <int> res;
string str;

void init() { //hàm khởi tạo
    res.clear (); //làm trống kết quả
    cin >> n;
    memset (used, 0, sizeof (used)); //đánh dấu chưa có chữ số nào
    while (n--) {
        cin >> str;
        for (int i = 0; i < str.length (); i++) {
            if (res.size () == 10) break; //nếu có đủ 10 chữ số dừng lại
            else { //str[i]-48 dùng để ép kiểu char thành kiểu int
                if (used[(int)(str[i]-'0')] == 0) { //nếu tìm được 1 chữ số chưa sử dụng
                    res.push_back ((int)(str[i]-'0')); //đẩy nó vào kết quả
                    used[(int)(str[i]-'0')] = 1; //đánh dấu nó đã sử dụng
                }
            }
        }
    }
}

void solve() {
    sort (res.begin (), res.end ()); //sắp xếp lại mảng kết quả
    for (int i = 0; i < res.size (); i++) cout << res[i] << " "; //đưa ra kết quả
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
68. DSA06011	TỔNG GẦN 0 NHẤT
/*Cho mảng A[] gồm n phần tử, hãy tìm cặp phần tử có tổng gần nhất so với 0.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất đưa vào n là số phần tử của mảng A[];
dòng tiếp theo đưa vào n số A[i]; các số được viết cách nhau một vài khoảng trống.
T, n, A[i] thỏa mãn ràng buộc: 1≤T≤100; 2≤N ≤103, -106≤A[i] ≤106.
Output:
Đưa ra tổng gần nhất với 0 của cặp phần tử.
Input                 Output
2
3                     -68
-8 -66 -60
6                     -14
-21 -67 -37 -18 4 -65
*/
//Ý tưởng: tìm cặp số có giá trị tuyệt đối gần 0 nhất. nếu 2 cặp bằng nhau thì cặp nào xuất hiện trước thì in
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, a[1005];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    int min = INT_MAX;
    int res;
    for (int i = 0; i < n - 1; i++)
        for (int j = i + 1; j < n; j++)
            if (abs (a[i] + a[j]) < min) {
                min = abs (a[i] + a[j]); //tìm min giá trị tuyệt đối
                res = a[i] + a[j]; //cập nhật kết quả
            }
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
69. DSA06012	PHẦN TỬ LỚN NHẤT
/*Cho mảng A[] gồm n phần tử, hãy tìm k phần tử lớn nhất của mảng. Các phần tử được đưa ra theo thứ tự giảm dần.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất đưa vào N và K; dòng tiếp theo đưa vào n
số A[i]; các số được viết cách nhau một vài khoảng trống.
T, N, K, A[i] thỏa mãn ràng buộc: 1≤T≤100; 1≤K < N ≤10^3, 1≤A[i] ≤10^6.
Output:
Đưa ra k phần tử lớn nhất trên một dòng.
Input                Output
2
5 3                  12 10 9
10 7 9 12 6
6 2                  12 9
9 7 12 8 6 5
*/
//Ý tưởng: Sắp xếp lại mảng sau đó in ngược lên
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, k, a[1005];

void init() { //hàm khởi tạo
    cin >> n >> k;
    for (int i = 1; i <= n; i++) cin >> a[i];
}

void solve() { //hãm xử lý
    sort (a + 1, a + n + 1); //sắp xếp lại mảng
    while (k--) cout << a[n--] << " "; //đưa ra kết quả
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
70. DSA06013	SỐ LẦN XUẤT HIỆN
/*Cho mảng A[] gồm n phần tử đã được sắp xếp. Hãy tìm số lần xuất hiện số X trong mảng. Nếu số lần xuất hiện số x trong
mảng là 0 hãy đưa ra -1.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất đưa vào N và X; dòng tiếp theo đưa vào n
số A[i]; các số được viết cách nhau một vài khoảng trống.
T, N, X, A[i] thỏa mãn ràng buộc: 1≤T≤100; 1≤ N ≤103, 1≤A[i], X ≤106.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
7 2                  4
1 1 2 2 2 2 3
7 4                  -1
1 1 2 2 2 2 3
*/
//Ý tưởng: Sắp xếp lại mảng sau đó đếm số X, nếu phần tử lớn hơn X thì dừng lại
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, x, res, a[1005];

void init() { //hàm khởi tạo
    cin >> n >> x;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    res = 0;
    sort (a, a + n); //sắp xếp lại mảng
    for (int i = 0; i < n; i++) {
        if (a[i] == x) res++; //nếu tìm thấy x tăng kết quả
        else if (a[i] > x) break; //nếu lớn hơn x dừng
    }
    if (res) cout << res << endl; //đưa ra kết quả
    else cout << "-1" << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
71. DSA06014	TỔNG CẶP SỐ NGUYÊN TỐ
/*Cho số tự nhiên N. Hãy tìm cặp số nguyên tố đầu tiên có tổng là N. Nếu không tồn tại cặp số nguyên tố có tổng bằng N,
hãy đưa ra -1.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm là một số N được ghi trên một dòng.
T, N thỏa mãn ràng buộc: 1≤T≤100; 1≤ N ≤106.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
4                    2 2
8                    3 5
*/
//Ý tưởng: Dùng sàng nguyên tố
//Code:

#include<bits/stdc++.h>
using namespace std;

int n;

void init() { //hàm khởi tạo
    cin >> n;
}

void solve() { //hàm xử lý
    int isPrime[n + 1];
    memset (isPrime, 1, sizeof (isPrime)); //giả định tất cả các số đều là số nguyên tố
    for (int i = 2; i * i <= n; i++)
        if (isPrime[i]) //nếu i là 1 số nguyên tố
            for (int j = i * i; j <= n; j += i) isPrime[j] = 0; //các bội số của i không phải là số nguyên tố
    int check = 0; //đánh dấu chưa tìm được cặp số nguyên tố
    for (int i = 2; i <= n / 2; i++)
        if (isPrime[i] && isPrime[n - i]) { //nếu tìm được cặp số nguyên tố
            cout << i << " " << n - i; //đưa ra kết quả
            check = 1; //đánh dấu đã tìm được
            break; //dừng lại
        }
    if (!check) cout << -1; //không tìm được đưa ra -1
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
72. DSA06015	MERGE SORT
/*Cho mảng A[] gồm N phần tử chưa được sắp xếp. Nhiệm vụ của bạn là sắp xếp các phần tử của mảng A[] theo thứ tự tăng
dần bằng thuật toán Merge Sort.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất đưa vào số N tương ứng với số phần tử
của mảng A[]; phần thứ 2 là N số của mảng A[]; các số được viết cách nhau một vài khoảng trống.
T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤N, A[i]≤106.
Output:
Đưa ra kết quả các test theo từng dòng.
Input                 Output
2
5                     1 3 4 7 9
4 1 3 9 7
10                    1 2 3 4 5 6 7 8 9 10
10 9 8 7 6 5 4 3 2 1
*/
//Ý tưởng: sát nhập từng mảng nhỏ đã sắp xếp lại với nhau
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, a[1000005];
void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void merge(int l, int m, int r) { //hàm nhập
    int n1 = m - l + 1; //độ dài của đoạn 1
    int n2 = r - m; //độ dài của đoạn 2
    int L[n1]; //mảng lưu đoạn 1
    int R[n2]; //mảng lưu đoạn 2
    //lưu ý là đoạn 1 và đoạn 2 đã được sắp xếp khi chạy thuật toán
    for (int i = 0; i < n1; i++) L[i] = a[l + i]; //gán giá trị cho đoạn 1
    for (int i = 0; i < n2; i++) R[i] = a[m + 1 + i]; //gán giá trị cho đoạn 2
    int i = 0, j = 0, k = l;
    while (i < n1 && j < n2) { //so sánh giá trị của phần tử ở đoạn 1 với đoạn 2
        if (L[i] <= R[j]) a[k++] = L[i++]; //nếu chưa đứng đúng thứ tự
        else a[k++] = R[j++]; //cập nhật nhật giá trị cho đoạn cần sắp xếp
    }
    while (i < n1) a[k++] = L[i++]; //bổ sung khi vẫn còn phần tử
    while (j < n2) a[k++] = R[j++]; //bổ sung khi vẫn còn phần tử
}

void mergeSort(int l, int r) { //hàm sắp xếp nhập
    if (l < r) { //khi chỉ mục bên trái còn nhỏ hơn bên phải thực hiện chia mảng
        int m = l + (r - l) / 2; //chia mảng thành 2 đoạn con với chỉ mục trung gian là vị trí giữa
        mergeSort (l, m); //thực hiện sắp xếp đoạn trái
        mergeSort (m + 1, r); //thực hiện sắp xếp đoạn phải
        merge (l, m, r); //nhập 2 đoạn
    }
}

void print() { //hàm in kết quả
    for (int i = 0; i < n; i++) cout << a[i] << " "; //đưa ra hết quả
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        mergeSort (0, n - 1);
        print ();
    }
    return 0;
}
73. DSA06016	TÍCH LỚN NHẤT - NHỎ NHẤT
/*Cho mảng A[] gồm n phần tử và mảng B[] gồm m phần tử. Nhiệm vụ của bạn là tìm tích giữa phần tử lớn nhất của mảng A[]
và phần tử nhỏ nhất của mảng B[]. Ví dụ A[] = {5, 7, 112, 9, 3, 6, 2 }, B[] = {1, 2, 6, -1, 0, 9} ta có kết quả là
-9 = 9*(-1).
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm ba dòng: dòng đầu tiên đưa vào n, m tương ứng với số phần tử của
mảng A[] và B[]; dòng tiếp theo là n số A[i] ; dòng cuối cùng là m số B[i]; các số được viết cách nhau một vài khoảng
trống. T, n, m, A[i], B[i] thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n, m ≤106; -108≤ A[i] ≤108.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
6 6                  -9
5 7 9 3 6 2
1 2 6 -1 0 9
6 6                  20
1 4 2 3 10 2
4 2 6 5 2 9
*/
//Ý tưởng: lấy 2 phần tử tương ứng nhân với nhau
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, m;
long a[1000005], b[1000005];

void init(){ //hàm khởi tạo
    cin>>n>>m;
    for(int i=0;i<n;i++) cin>>a[i];
    for(int i=0;i<m;i++) cin>>b[i];
}

void solve() { //hàm xử lý
    long minb = LONG_MAX, maxa = LONG_MIN;
    for (int i = 0; i < n; i++)
        if (a[i] > maxa) maxa = a[i]; //tìm max của mảng a
    for (int i = 0; i < m; i++)
        if (b[i] < minb) minb = b[i]; //tìm min của mảng b
    long long res = maxa * minb; //tính kết quả
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
74. DSA06017	TRỘN HAI DÃY
/*Cho mảng A[] gồm n phần tử và mảng B[] gồm m phần tử. Nhiệm vụ của bạn là hợp nhất hai mảng A[] và B[] để được một
mảng mới đã được sắp xếp. Ví dụ A[] = {5, 7, 112, 9, 3, 6, 2 }, B[] = {1, 2, 6, -1, 0, 9} ta có kết quả là C[] =
{-1, 1, 0, 2, 3, 5, 6, 6, 7, ...}
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm ba dòng: dòng đầu tiên đưa vào n, m tương ứng với số phần tử của
mảng A[] và B[]; dòng tiếp theo là n số A[i] ; dòng cuối cùng là m số B[i]; các số được viết cách nhau một vài khoảng
trống. T, n, m, A[i], B[i] thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n, m ≤106; -108≤ A[i] ≤108.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
1
3 3                  2 3 5 10 15 20
10 5 15
20 3 2
*/
//Ý tưởng: đưa các phần tử và 1 mảng sau đó sắp xếp
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, m;
long a[2000005];

void init() { //hàm khởi tạo
    cin >> n >> m;
    for (int i = 0; i < n; i++) cin >> a[i];
    for (int i = n; i < n + m; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    sort (a, a + n + m); //sắp xếp lại mảng a
    for (int i = 0; i < n + m; i++) cout << a[i] << " "; //đưa ra kết quả
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
75. DSA06018	BỔ SUNG PHẦN TỬ
/*Cho mảng A[] gồm n số nguyên dương. Gọi L, R là max và min các phần tử của A[]. Nhiệm vụ của bạn là tìm số phần tử cần
thiết cần thêm vào mảng để mảng có đầy đủ các số trong khoảng [L, R]. Ví dụ A[] = {5, 7, 9, 3, 6, 2 } ta nhận được kết
quả là 2 tương ứng với các số còn thiếu là 4, 8.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên đưa vào n, tương ứng với số phần tử của
mảng A[]; dòng tiếp theo là n số A[i] ; các số được viết cách nhau một vài khoảng trống.
T, n, A[i] thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n, A[i] ≤103.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
5                    1
4 5 3 8 6
3                    0
2 1 3
*/
//Ý tưởng: Tìm số lớn nhất và nhỏ nhất của mảng, sau đó tìm số phần tử giống nhau, rồi tìm số phần tử còn thiếu.
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, cnt, res, a[1005];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    sort (a, a + n); //sắp xếp lại mảng
    cnt = 0; //khởi tạo cnt
    res = a[n - 1] - a[0] + 1; //tìm số phần tử cần có của mảng
    for (int i = 1; i < n; i++)
        if (a[i] == a[i - 1]) cnt++; //đếm số phần tử lặp lại
    cout << res - n + cnt << "\n"; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
76. DSA06019	SẮP XẾP THEO SỐ LẦN XUẤT HIỆN
/*Cho mảng A[] gồm n số nguyên. Nhiệm vụ của bạn là sắp xếp mảng theo số lần xuất hiện các phần tử của mảng. Số xuất
hiện nhiều lần nhất đứng trước. Nếu hai phần tử có số lần xuất hiện như nhau, số nhỏ hơn đứng trước. Ví dụ A[] =
{5, 5, 4, 6, 4 }, ta nhận được kết quả là A[] = {4, 4, 5, 5, 6}.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên đưa vào n, tương ứng với số phần tử của
mảng A[] và số k; dòng tiếp theo là n số A[i] ; các số được viết cách nhau một vài khoảng trống.
T, n, A[i] thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n ≤104; 1≤ k ≤103; 1≤ A[i] ≤105.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
5                    4 4 5 5 6
5 5 4 6 4
5                    9 9 9 2 5
9 9 9 2 5
*/
/*Ý tưởng: Đếm số lần xuất hiện của các phần tủ. Sau đó so sánh số lần xuất hiện nếu cùng số lần xuất hiện thì so sánh
giá trị phần tử*/
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, a[10005];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    sort (a, a + n); //sắp xếp lại mảng a
    vector <int> val; //mảng lưu giá trị
    vector <int> cnt; //mảng lưu số lần xuất hiện
    val.push_back (a[0]);
    cnt.push_back (1);
    for (int i = 1; i < n; i++) {
        if (a[i] != a[i - 1]) { //nếu gặp phần tử mới
            val.push_back (a[i]); //thêm phần tử vào mảng giá trị
            cnt.push_back (1); //thêm số lần xuất hiện tương ứng là 1
        } else cnt[cnt.size () - 1]++; //nếu gặp phần tử cũ tăng số lần xuất hiện lên 1
    }
    for (int i = 0; i < cnt.size () - 1; i++)
        for (int j = i + 1; j < cnt.size (); j++) {
            if (cnt[i] < cnt[j]) { //phần tử đứng không đúng thứ tự thực hiện đổi chỗ
                swap (cnt[i], cnt[j]);
                swap (val[i], val[j]);
            } else if (cnt[i] == cnt[j] && val[i] > val[j]) {
                swap (val[i], val[j]);
            }
        }
    for (int i = 0; i < val.size (); i++)
        while (cnt[i]--) cout << val[i] << " "; //đưa ra kết quả
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
77. DSA06020	TÌM KIẾM
/*Cho mảng A[] gồm n phần tử đã được sắp xếp. Hãy đưa ra 1 nếu X có mặt trong mảng A[], ngược lại đưa ra -1.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất đưa vào n, X là số các phần tử của mảng
A[] và số X cần tìm; dòng tiếp theo đưa vào n số A[i] (1≤i≤n) các số được viết cách nhau một vài khoảng trống.
T, n, A, X thỏa mãn ràng buộc: 1≤T≤100; 1≤N, X, A[i] ≤106.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
5 16                 1
2 4 7 9 16
7 98                 -1
1 22 37 47 54 88 96
*/
//Ý tưởng: duyệt cả mảng nếu có x thì in 1, không có in -1
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, x, res, a[1000005];

void init() { //hàm khởi tạo
    cin >> n >> x;
    for (long i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    res = -1; //đánh dấu là chưa tìm được x
    for (int i = 0; i < n; i++)
        if (a[i] == x) { //nếu tìm thấy x
            res = 1; //cập nhật kết quả
            break;
        }
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
78. DSA06021	TÌM KIẾM TRONG DÃY SẮP XẾP VÒNG
/*Một mảng được sắp được chia thành hai đoạn tăng dần được gọi là mảng sắp xếp vòng. Ví dụ mảng A[] =
{ 5, 6, 7, 8, 9, 10, 1, 2, 3, 4} là mảng sắp xếp vòng. Cho mảng A[] gồm n phần tử, hãy tìm vị trí của phần tử x trong
mảng A[] với thời gian log(n).
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất đưa vào n và x; dòng tiếp theo đưa vào n
số A[i]; các số được viết cách nhau một vài khoảng trống.
T, n, A[i], x  thỏa mãn ràng buộc: 1≤T≤100; 1≤N, x, A[i] ≤107.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
10 3                 9
5 6 7 8 9 10 1 2 3 4
10 3                 3
1 2 3 4 5 6 7 8 9 10
*/
/*Ý tưởng: đánh dấu giá trị đầu và cuối, chia mảng thành 2 đoạn nếu đúng bằng phần tử ở giữa đưa ra kết quả, nếu nhỏ hơn
phần tử giữa và lớn hơn phần tử đầu thì tìm ở nửa đầu, còn không tìm ở nửa sau*/
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, x, a[1000005];

void init() { //hàm khởi tạo
    cin >> n >> x;
    for (int i = 1; i <= n; i++) cin >> a[i];
}

int find(int l, int r) { //hàm tìm kiếm
    int m = (l + r) / 2; //chọn phần tử giữa
    if (a[m] == x) return m; //nếu bằng phần tử giữa trả về vi trí giữa
    else if (a[l] == x) return l; //nếu bằng phần tử trái trả về vi trí trái
    else if (a[r] == x) return r; //nếu bằng phần tử phải trả về vi trí phải
    if (a[m] > x) //nếu nhỏ hơn phần tủ giữa
        if (a[l] < x) return find (l + 1, m - 1); //nếu lớn hơn phần tử đầu tìm ở nửa trước
    return (m + 1, r - 1); //còn lại tìm ở nửa sau
}

void solve() { //hàm xử lý
    cout << find (1, n) << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
79. DSA06022	SỐ NHỎ NHẤT VÀ NHỎ THỨ HAI
/*Cho mảng A[] gồm n phần tử, hãy đưa ra số nhỏ nhất và số nhỏ thứ hai của mảng. Nếu không có số nhỏ thứ hai, hãy đưa ra
-1.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất đưa vào n là số phần tử của mảng A[];
dòng tiếp theo đưa vào n số A[i]; các số được viết cách nhau một vài khoảng trống.
T, n, A[i] thỏa mãn ràng buộc: 1≤T≤100; 1≤N, A[i] ≤107.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
10                   1 2
5 6 7 8 9 10 1 2 3 4
5                    -1
1 1 1  1  1
*/
//Ý tưởng: Sắp xếp lại mảng sau đó đưa ra 2 số nhỏ nhất, nếu số đầu bằng số cuối đưa ra -1
//Code:

#include<bits/stdc++.h>
using namespace std;

int n ,a[10000005];

void init() { //hàm khởi tạo
    cin >> n;
    for (long i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    sort (a, a + n); //sắp xếp lại mảng a
    if (a[0] == a[n - 1]) cout << "-1"; //nếu không có số nhỏ thứ 2
    else {
        for (int i = 0; i < n - 1; i++)
            if (a[i] != a[i + 1]) {
                cout << a[i] << " " << a[i + 1]; //đưa ra e=kết quả
                break;
            }
    }
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
80. DSA07001	NGĂN XẾP 1
/*Cho một ngăn xếp các số nguyên. Các thao tác gồm 3 lệnh: push, pop và show. Trong đó thao tác push kèm theo một giá
trị cần thêm (không quá 1000). Hãy viết chương trình ghi ra kết quả của các lệnh show.
Input: Gồm nhiều dòng, mỗi dòng chứa một lệnh push, pop hoặc show. Input đảm bảo số lượng phần tử trong stack khi nhiều
nhất cũng không vượt quá 200.
Output: Ghi ra màn hình các phần tử đang có trong stack theo thứ tự lưu trữ mỗi khi gặp lệnh show. Các số viết cách nhau
đúng một khoảng trống. Nếu trong stack không còn gì thì in ra dòng “empty”
Input                 Output
push 3
push 5
show                  3 5
push 7
show                  3 5 7
pop
pop
show                  3
*/
//Ý tưởng: sử dụng ctdl ngăn xếp
//Code:

#include <bits/stdc++.h>
using namespace std;

int n;
string str;
stack <int> s;

void solve() { //hàm xử ý
    while (cin >> str) {
        if (str == "push") { //nếu gặp push thêm dữ liệu vào stack
            cin >> n;
            s.push (n);
        } else if (str == "pop") s.pop (); //gặp pop thì xoá ở đỉnh của stack
        else { //nếu gặp show
            if (s.empty ()) cout << "empty" << endl; //nếu stack rỗng in empty
            else { //nếu stack không rỗng in ra các phần tử của stack
                vector <int> res;
                while (!s.empty ()) {
                    res.push_back (s.top ());
                    s.pop ();
                }
                for (int i = res.size () - 1; i >= 0; i--) {
                    cout << res[i] << " ";
                    s.push (res[i]);
                }
                cout << endl;
            }
        }
    }
}

int main() {
    solve ();
    return 0;
}
82. DSA07002	NGĂN XẾP 2
/*Yêu cầu bạn xây dựng một stack với các truy vấn sau đây:
“PUSH x”: Thêm phần tử x vào stack (0 ≤ x ≤ 1000).
“PRINT”: In ra phần tử đầu tiên của stack. Nếu stack rỗng, in ra “NONE”.
“POP”: Xóa phần tử đầu tiên của stack. Nếu stack rỗng, không làm gì cả.
Input:
Dòng đầu tiên là số lượng truy vấn Q (Q ≤ 100000).
Mỗi truy vấn có dạng như trên.
Output:
Với mỗi truy vấn “PRINT”, hãy in ra phần tử đầu tiên của stack. Nếu stack rỗng, in ra “NONE”.
Input                 Output
9
PUSH 1
PUSH 2
POP
PRINT                 1
PUSH 3
PRINT                 3
POP
POP
PRINT                 NONE
*/
// Ý tưởng: sử dụng ctdl ngăn xếp
//Code:

#include <bits/stdc++.h>
using namespace std;

stack <int> s;
string str;

void init() { //hàm khởi tạo
    cin >> str;
}

void solve() { //hàm xử ý
    if (str == "PUSH") {
        int n;
        cin >> n;
        s.push (n); //thêm dữ liệu vào stack
    } else if (str == "PRINT") { //in ra phần tử ở đỉnh của stack
        if (!s.empty ()) cout << s.top ();
        else cout << "NONE";
        cout << endl;
    } else { //xoá phần tử ở đỉnh của stack
        if (!s.empty ()) s.pop ();
    }
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
83. DSA07003	KIỂM TRA BIỂU THỨC SỐ HỌC
/*Cho biểu thức số học, hãy cho biết biểu thức số học có dư thừa các cặp ký hiệu ‘(’,’) ‘ hay không?
Input:
Dòng đầu tiên đưa vào số lượng bộ test T;
Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test là một biểu thức tiền tố exp.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Ràng buộc:
T, exp thỏa mãn ràng buộc: 1≤T≤100; 2≤length(exp)≤20.
Input                 Output
3
((a+b))               Yes
(a + (b)/c)           Yes
(a + b*(c-d))         No
*/
/*Ý tưởng: thêm các dấu ngoặc và toán tử vào stack, nếu gặp dấu ')' mà trước nó là dấu '(' thì trả về true, còn không
thì xoá hết các phần tử đến khi xoá dấu '(' đầu tiên*/
//Code:

#include <bits/stdc++.h>
using namespace std;

string str;

void init() { //hàm khởi tạo
    getline (cin, str); //lưu ý muôn nhập xâu có cả dấu ' ' phải dùng getline
}

void solve() { //hàm xử lý
    stack <char> s; //khai báo stack
    int check = 0; //khởi tạo biến check
    for (int i = 0; i < str.length (); i++) {
        if (str[i] == ')') { //nếu gặp dấu ')'
            if (s.top () == '(') { //nếu trước nó là '(' cập nhật check và dừng
                check = 1;
                break;
            } else {
                while (s.top () != '(') s.pop (); //xoá các toán tử
                s.pop (); //xoá dấu '(' đầu tiên
            }
        } else if (str[i] == '(' || str[i] == '+' || str[i] == '-' || str[i] == '*' || str[i] == '/') s.push (str[i]);
        //thêm các toán tử  và dấu '(' vào stack
    }
    //đưa ra kết quả
    if (check) cout << "Yes" << "\n";
    else cout << "No" << "\n";
}

int main() {
    int t;
    cin >> t;
    cin.ignore ();
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
84. Sửa lại dãy ngoặc 
/*Cho một xâu chỉ gồm các kí tự ‘(‘, ‘) và có độ dài chẵn. Hãy đếm số lượng dấu ngoặc cần phải đổi chiều ít nhất, sao
cho xâu mới thu được là một dãy ngoặc đúng.
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test gồm 1 xâu S có độ dài không vượt quá 100 000, chỉ gồm dấu ( và ).
Output:
Với mỗi test, in ra đáp án tìm được trên một dòng.
Input                 Output
4
))((                  2
((((                  2
(((())                1
)(())(((              3
*/
//Ý tưởng: nếu gặp dấu ')' mà trước nó không có '(' thì thực hiện đổi chiều
//Code:

#include <bits/stdc++.h>
using namespace std;

string str;
int res;

void init() { //hàm khởi tạo
    cin >> str;
}

void solve() { //hàm xử lý
    stack <char> s; //khai báo stack
    res = 0; //khởi tạo biến kết quả
    for (int i = 0; i < str.length (); i++) {
        if (s.empty () && str[i] == ')') {
            res++; //tăng số lần đổi chiều
            s.push ('('); //nếu gặp dấu ')' mà trước nó không có '(' thì thực hiện đổi chiều
        } else if (!s.empty () && str[i] == ')') s.pop (); //nếu gặp ')' mà trước nó có '(' thì xoá dấu '('
        else s.push ('('); //nếu gặp dấu '(' thì đưa vào stack
    }
    res += s.size () / 2; //cộng thêm số dấu ngoặc cần đổi chiều còn lại
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
84. DSA07009	BIẾN ĐỔI TIỀN TỐ - TRUNG TỐ
/*Hãy viết chương trình chuyển đổi biểu thức biểu diễn dưới dạng tiền tố về dạng trung tố.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T;
Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test là một biểu thức tiền tố exp.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Ràng buộc:
T, exp thỏa mãn ràng buộc: 1≤T≤100; 2≤length(exp)≤106.
Input                 Output
2
*+AB-CD               ((A+B)*(C-D))
*-A/BC-/AKL           ((A-(B/C))*((A/K)-L)
*/
//Ý tưởng: duyệt từ cuối về, string tmp = “(“ +Op1 + X + Op2 + “)”
//Code:

#include <bits/stdc++.h>
using namespace std;

string str;

bool isOperator(char x) { //hàm kiểm tra toán tử
    if (x == '+' || x == '-' || x == '*' || x == '/') return true;
    return false;
}

void init() { //hàm khởi tạo
    getline (cin, str);
}

void solve() { //hàm xử lý
    stack <string> s;
    for (int i = str.length () - 1; i >= 0; i--) {
        if (isOperator (str[i])) { //nếu gặp toán tử thực hiện thêm biểu thức trung tố tương ứng với stack
            string str1 = s.top (); //lấy ra toán hạng ở đỉnh stack
            s.pop (); //xoá toán hạng khỏi stack
            string str2 = s.top (); //lấy ra toán hạng ở đỉnh stack
            s.pop (); //xoá toán hạng khỏi stack
            string tmp = "(" + str1 + str[i] + str2 + ")"; //tạo biểu thức trung tố tương ứng
            s.push (tmp); //thêm biểu thức trung tố vào stack
        } else { //nếu gặp toán hạng
            string tmp = "";
            s.push (tmp + str[i]); //thêm toán hạng vào stack, lưu ý toán hạng phải ở kiểu string
        }
    }
    cout << s.top () << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    cin.ignore ();
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
85. DSA07010	BIẾN ĐỐI TIỀN TỐ - HẬU TỐ
/*Hãy viết chương trình chuyển đổi biểu thức biểu diễn dưới dạng tiền tố về dạng hậu tố.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T;
Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test là một biểu thức tiền tố exp.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Ràng buộc:
T, exp thỏa mãn ràng buộc: 1≤T≤100; 2≤length(exp)≤106.
Input                 Output
2
*+AB-CD               AB+CD-*
*-A/BC-/AKL           ABC/-AK/L-*
*/
//ý tưởng: duyệt từ cuối về, tmp = OP1 + OP2 + X;

#include <bits/stdc++.h>
using namespace std;

string str;

bool isOperator(char x) { //hàm kiểm tra toán tử
    if (x == '+' || x == '-' || x == '*' || x == '/') return true;
    return false;
}

void init() { //hàm khởi tạo
    getline (cin, str);
}

void solve() { //hàm xử lý
    stack <string> s;
    for (int i = str.length () - 1; i >= 0; i--) {
        if (isOperator (str[i])) { //nếu gặp toán tử
            string str1 = s.top (); //lấy toán hạng ở đỉnh stack
            s.pop (); //xoá toán hạng khỏi stack
            string str2 = s.top (); //lấy toán hạng ở đỉnh stack
            s.pop (); //xoá toán hạng khỏi stack
            string tmp = str1 + str2 + str[i]; //cập nhật biểu thức hậu tố tương ứng
            s.push (tmp);
        } else { //nếu gặp toán hạng đẩy toán hạng vào stack
            string tmp = "";
            s.push (tmp + str[i]); //lưu ý toán toán hạng ở kiểu string
        }
    }
    cout << s.top () << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    cin.ignore ();
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
86. DSA07013	TÍNH GIÁ TRỊ BIỂU THỨC HẬU TỐ
/*Hãy viết chương trình chuyển tính toán giá trị của biểu thức hậu tố.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T;
Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test là một biểu thức hậu tố exp. Các số xuất hiện trong biểu
thức là các số đơn có 1 chữ số.
Output:
Đưa ra kết quả mỗi test theo từng dòng, chỉ lấy giá trị phần nguyên.
Ràng buộc:
T, exp thỏa mãn ràng buộc: 1≤T≤100; 2≤length(exp)≤20.
Input                 Output
2
231*+9–               -4
875*+9-               34
*/
//Ý tưởng: duyệt từ đầu nếu gặp toán tử thì thực hiện phép toán của toán tử đó với 2 toán ở đỉnh stack
//Code:

#include <bits/stdc++.h>
using namespace std;

string str;

void init() { //hàm khởi tạo
    cin >> str;
}

void solve() { //hàm xử lý
    stack <int> s;
    for (int i = 0; i < str.length (); i++) { 
	//nếu gặp toán tử thực hiện phép toán tương ứng rồi thêm kết quả vào stack
        if (str[i] == '+') {
            int x = s.top ();
            s.pop ();
            int y = s.top ();
            s.pop ();
            s.push (y + x);
        } else if (str[i] == '-') {
            int x = s.top ();
            s.pop ();
            int y = s.top ();
            s.pop ();
            s.push (y - x);
        } else if (str[i] == '*') {
            int x = s.top ();
            s.pop ();
            int y = s.top ();
            s.pop ();
            s.push (x * y);
        } else if (str[i] == '/') {
            int x = s.top ();
            s.pop ();
            int y = s.top ();
            s.pop ();
            s.push (y / x);
        } else s.push ((int) (str[i] - '0')); //nếu gặp toán hạng thêm toán hạng vào stack
    }
    cout << s.top (); //đưa ra kết quả
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
87. DSA07014	TÍNH GIÁ TRỊ BIỂU THỨC TIỀN TỐ
/*Hãy viết chương trình tính toán giá trị của biểu thức tiền tố.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T;
Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test là một biểu thức tiền tố exp. Các số xuất hiện trong biểu
thức là các số đơn có 1 chữ số.
Output:
Đưa ra kết quả mỗi test theo từng dòng, chỉ lấy giá trị phần nguyên.
Ràng buộc:
T, exp thỏa mãn ràng buộc: 1≤T≤100; 2≤length(exp)≤20.
Input                 Output
2
-+8/632               8
-+7*45+20             25
*/
//Ý tưởng: duyệt từ cuối nếu gặp toán tử thì thực hiện phép toán của toán tử đó với 2 toán ở đỉnh stack
//Code:

#include <bits/stdc++.h>
using namespace std;

string str;

void init() { //hàm khởi tạo
    cin >> str;
}

void solve() { //hàm xử lý
    stack <int> s;
    for (int i = str.length () - 1; i >= 0; i--) {
        //nếu gặp toán tử thực hiện phép toán tương ứng rồi thêm kết quả vào stack
        if (str[i] == '+') {
            int x = s.top ();
            s.pop ();
            int y = s.top ();
            s.pop ();
            s.push (x + y);
        } else if (str[i] == '-') {
            int x = s.top ();
            s.pop ();
            int y = s.top ();
            s.pop ();
            s.push (x - y);
        } else if (str[i] == '*') {
            int x = s.top ();
            s.pop ();
            int y = s.top ();
            s.pop ();
            s.push (x * y);
        } else if (str[i] == '/') {
            int x = s.top ();
            s.pop ();
            int y = s.top ();
            s.pop ();
            s.push (x / y);
        } else s.push ((int) (str[i] - '0')); //nếu gặp toán hạng thêm toán hạng vào stack
    }
    cout << s.top () << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
88. DSA07027	PHẦN TỬ BÊN PHẢI ĐẦU TIÊN LỚN HƠN
/*Cho dãy số A[] gồm N phần tử. Với mỗi A[i], bạn cần tìm phần tử bên phải đầu tiên lớn hơn nó. Nếu không tồn tại, in ra
-1.
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test bắt đầu bởi số nguyên N (1 ≤ N ≤ 100000).
Dòng tiếp theo gồm N số nguyên A[i] (0 ≤ A[i] ≤ 109).
Output:
Với mỗi test, in ra trên một dòng N số R[i], với R[i] là giá trị phần tử đầu tiên lớn hơn A[i].
Input                 Output
3
4
4 5 2 25              5 25 25 -1
3
2 2 2                 -1 -1 -1
4
4 4 5 5               5 5 -1 -1
*/
/*Ý tưởng: duyệt từ cuối về thêm các phần tử theo thứ tự giảm dần vào stack. Khi đỉnh stack lớn hơn phần tử hiện tại thì
đưa ra kết quả, khi stack rỗng thì in -1*/
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, a[100005];

void init() { //hàm khởi tạo
     cin >> n;
    for (long i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    stack <int> s; //tạo 1 stack
    int res[n]; //tạo 1 vector kết quả
    for (int i = n - 1; i >= 0; i--) {
        while (!s.empty () && a[i] >= s.top ()) s.pop (); //xoá các phần tử trong stack không lớn hơn phần từ hiện tại
        if (s.empty ()) res[i] = -1; //nếu stack rỗng in -1
        else res[i] = s.top (); //in phần tử đầu tiên trong stack lớn hơn a[i] sau đó đưa a[i] vào stack
        s.push (a[i]);
    }
    for (int i = 0; i < n; i++) cout << res[i] << " "; //đưa ra kết quả
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
89. DSA08001	CẤU TRÚC DỮ LIỆU HÀNG ĐỢI 1
/*Ban đầu cho một queue rỗng. Bạn cần thực hiện các truy vấn sau:
Trả về kích thước của queue
Kiểm tra xem queue có rỗng không, nếu có in ra “YES”, nếu không in ra “NO”.
Cho một số nguyên và đẩy số nguyên này vào cuối queue.
Loại bỏ phần tử ở đầu queue nếu queue không rỗng, nếu rỗng không cần thực hiện.
Trả về phần tử ở đầu queue, nếu queue rỗng in ra -1.
Trả về phần tử ở cuối queue, nếu queue rỗng in ra -1.
Dữ liệu vào
Dòng đầu tiên chứa số nguyên T là số bộ dữ liệu, mỗi bộ dữ theo dạng sau.
Dòng đầu tiên chứa số nguyên n - lượng truy vấn (1 ≤ n ≤ 1000)
N dòng tiếp theo, mỗi dòng sẽ ghi loại truy vấn như trên, với truy vấn loại 3 sẽ có thêm một số nguyên, không quá 10^6.
Kết quả: In ra kết quả của các truy vấn..
Input                 Output
1
14
3 1
3 2
3 3
5                     1
6                     3
4
4
4
4
4
3 5
3 6
5                     5
1                     2
*/
//Ý tưởng: Sử dụng ctdl queue
//Code:

#include <bits/stdc++.h>
using namespace std;

int n;

void solve() { //hàm xử lý
    cin >> n;
    queue <int> q;
    while (n--) {
        int x;
        cin >> x;
        switch (x) {
            case 1:
                cout << q.size () << "\n"; //trả về kích thước của queue
                break;
            case 2:
                if (!q.empty ()) cout << "NO" << "\n"; //nếu queue không rỗng in ra NO
                else cout << "YES" << "\n"; //nếu queue rỗng in ra YES
                break;
            case 3:
                int y;
                cin >> y;
                q.push (y); //đẩy y vào đầu queue
                break;
            case 4:
                if (!q.empty ()) q.pop (); //xoá phần tử ở đầu queue nếu queue không rỗng
                break;
            case 5:
                if (!q.empty ()) cout << q.front () << "\n"; //nếu queue không rỗng in ra phần tử ở đầu queue
                else cout << -1 << "\n"; //nếu queue rỗng in ra -1
                break;
            case 6:
                if (!q.empty ()) cout << q.back () << endl; //queue không rỗng thì trả về phầ tử ở cuối queue
                else cout << -1 << endl; //nếu queue rỗng in ra -1
                break;
            default:
                break;
        }
    }
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        solve ();
    }
    return 0;
}
90. DSA08002	CẤU TRÚC DỮ LIỆU HÀNG ĐỢI 2
/*Yêu cầu bạn xây dựng một queue với các truy vấn sau đây:
“PUSH x”: Thêm phần tử x vào cuối của queue (0 ≤ x ≤ 1000).
“PRINTFRONT”: In ra phần tử đầu tiên của queue. Nếu queue rỗng, in ra “NONE”.
“POP”: Xóa phần tử ở đầu của queue. Nếu queue rỗng, không làm gì cả.
Dữ liệu vào:
Dòng đầu tiên là số lượng truy vấn Q (Q ≤ 100000).
Mỗi truy vấn có dạng như trên.
Kết quả:
Với mỗi truy vấn “PRINT”, hãy in ra phần tử đầu tiên của queue. Nếu queue rỗng, in ra “NONE”.
Input                 Output
9
PUSH 1
PUSH 2
POP
PRINTFRONT            2
PUSH 3
PRINTFRONT            2
POP
POP
PRINTFRONT            NONE
*/
//Ý tưởng: sử dụng ctdl queue
//Code:

#include <bits/stdc++.h>
using namespace std;

queue <int> q;

void solve() { //hàm xử lý
    string s;
    cin >> s;
    if (s == "PUSH") {
        int x;
        cin >> x;
        q.push (x); //đẩy phần tử vào cuối queue
    } else if (s == "POP") {
        if (!q.empty ()) q.pop (); //xoá phần tử ở đầu queue
    } else {
        if (!q.empty ()) cout << q.front () << " "; //in phần tử ở đầu queue
        else cout << "NONE";
        cout << endl;
    }
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        solve ();
    }
    return 0;
}
91. DSA08003	HÀNG ĐỢI HAI ĐẦU (DEQUEUE)
/*Yêu cầu bạn xây dựng một hàng đợi hai đầu với các truy vấn sau đây:
“PUSHFRONT x”: Thêm phần tử x vào đầu của dequeue (0 ≤ x ≤ 1000).
“PRINTFRONT”: In ra phần tử đầu tiên của dequeue. Nếu dequeue rỗng, in ra “NONE”.
“POPFRONT”: Xóa phần tử đầu của dequeue. Nếu dequeue rỗng, không làm gì cả.
“PUSHBACK x”: Thêm phần tử x vào cuối của dequeue (0 ≤ x ≤ 1000).
“PRINTBACK”: In ra phần tử cuối của dequeue. Nếu dequeue rỗng, in ra “NONE”.
“POPBACK”: Xóa phần tử cuối của dequeue. Nếu dequeue rỗng, không làm gì cả.
Dữ liệu vào:
Dòng đầu tiên là số lượng truy vấn Q (Q ≤ 100000).
Mỗi truy vấn có dạng như trên.
Kết quả:
Với mỗi truy vấn “PRINTFRONT” và “PRINTBACK”, hãy in ra kết quả trên một dòng.
Input                 Output
10
PUSHBACK 1
PUSHFRONT 2
PUSHBACK 3
PRINTFRONT            2
POPFRONT
PRINTFRONT            1
POPFRONT
PRINTBACK             3
POPFRONT
PRINTBACK             NONE
*/
//Ý tưởng: Sử dụng ctdl deque
//Code:

#include <bits/stdc++.h>
using namespace std;

string str;
deque <int> q;
int n;

void init() { //hàm khởi tạo
    cin >> str;
}

void solve() { //hàm xử lý
    if (str == "PUSHBACK") {
        cin >> n;
        q.push_back (n); //thêm n vào cuối queue
    } else if (str == "PUSHFRONT") {
        cin >> n;
        q.push_front (n); //thêm n vào đầu queue
    } else if (str == "PRINTFRONT") {
        if (!q.empty ()) cout << q.front () << endl; //in phần tử ở đầu queue
        else cout << "NONE" << endl; //nếu queue rỗng in NONE
    } else if (str == "POPFRONT") {
        if (!q.empty ()) q.pop_front (); //xoá phần tử ở đầu queue
    } else if (str == "PRINTBACK") {
        if (!q.empty () > 0) cout << q.back () << endl; //in phần tử ở cuối queue
        else cout << "NONE" << "\n"; //nếu queue rỗng in NONE
    } else if (str == "POPBACK") {
        if (!q.empty () > 0) q.pop_back (); //xoá phần tử ở cuỗi queue
    }
}

int main() {
    int t;
    cin >> t;
    cin.ignore ();
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
92. DSA08005	SỐ NHỊ PHÂN TỪ 1 ĐẾN N
/*Cho số tự nhiên n. Hãy in ra tất cả các số nhị phân từ 1 đến n.
Input:
Dòng đầu tiên ghi lại số lượng test T (T≤100).
Mỗi test là một số tự nhiên n được ghi trên một dòng (n≤10000).
Output:
Đưa ra kết quả mỗi test trên một dòng.
Input                 Output
2
2                     1 10
5                     1 10 11 100 101
*/
//Ý tưởng: sử dụng queue thêm từng số 0 và 1 vào phần tử ở đầu queue
//Code:

#include <bits/stdc++.h>
using namespace std;

int n;

void init() { //hàm khởi tạo
    cin >> n;
}

void solve() { //hàm xử lý
    queue <string> q;
    q.push ("1"); //thêm số đầu tiên vào queue
    while (n--) {
        cout << q.front () << " "; //in ra số nhị phân kế tiếp
        q.push (q.front () + "0"); //tạo ra 2 số nhị phân tiếp theo
        q.push (q.front () + "1");
        q.pop (); //xoá số đã in rồi ra khỏi queue
    }
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
93. DSA08006	SỐ 0 VÀ SỐ 9
/*Cho số tự nhiên N. Hãy tìm số nguyên dương X nhỏ nhất được tạo bởi số 9 và số 0 chia hết cho N. Ví dụ với N = 5 ta sẽ
tìm ra  X = 90.
Input:
Dòng đầu tiên ghi lại số lượng test T (T≤100).
Những dòng kế tiếp mỗi dòng ghi lại một test. Mỗi test là một số tự nhiên N được ghi trên một dòng (N≤100).
Output:
Đưa ra theo từng dòng số X nhỏ nhất chia hết cho N tìm được.
Input                Output
2
5                    90
7                    9009
*/
//Ý tưởng: sử dụng queue thêm từng số 0 và 9 vào phần tử ở đầu queue đến số đầu tiên thoả mãn điều kiện
//Code:

#include <bits/stdc++.h>
using namespace std;

int n;

void init() { //hàm khởi tạo
    cin >> n;
}

void solve() { //hàm xử lý
    queue <long long> q;
    q.push (9); //thêm số đầu tiên vào queue
    while (1) {
        if (q.front () % n == 0) { //kiểm tra điều kiện
            cout << q.front () << endl; //in ra kết quả
            break;
        }
        q.push (q.front () * 10 + 0); //tạo ra 2 số tiếp theo
        q.push (q.front () * 10 + 9);
        q.pop (); //xoá số đã kiểm tra rồi ra khỏi queue
    }
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
94. DSA08007	SỐ BDN 1
/*Ta gọi số nguyên dương K là một số BDN nếu các chữ số trong K chỉ bao gồm các 0 hoặc 1 có nghĩa. Ví dụ số K = 1, 10,
101. Cho số tự nhiên N (N<263). Hãy cho biết có bao nhiêu số BDN nhỏ hơn N. Ví dụ N=100 ta có 4 số BDN bao gồm các số:
1, 10, 11, 100.
Input:
Dòng đầu tiên ghi lại số tự nhiên T là số lượng Test;
T dòng kế tiếp mỗi dòng ghi lại một bộ Test. Mỗi test là một số tự nhiên N.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
3
10                   2
100                  4
200                  7
*/
//Ý tưởng: liệt kê các số BDN ra rồi đếm
//Code:

#include<bits/stdc++.h>
using namespace std;

long long n, cnt;

void init() {
    cin >> n;
}

void solve() { //hàm xử lý
    res = 0; //khởi tạo kết quả
    queue <long long> q;
    q.push (1); //thêm số đầu tiên vào queue
    while (1) {
        if (q.front () <= n) res++;
        else break;
        q.push (q.front () * 10 + 0); //tạo ra 2 số BDN tiếp theo
        q.push (q.front () * 10 + 1);
        q.pop (); //xoá số đã đếm tra rồi ra khỏi queue
    }
    cout << res << endl;
    // đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
95. DSA08008	SỐ BDN 2
/*Ta gọi số nguyên dương K là một số BDN nếu các chữ số trong K chỉ bao gồm các 0 hoặc 1 có nghĩa. Ví dụ số K =  101 là
số BDN, k=102 không phải là số BDN.
Số BDN của N là số P =M*N sao cho P là số BDN. Cho số tự nhiên N (N<1000), hãy tìm số BDN nhỏ nhất của N.
Ví dụ. Với N=2, ta tìm được số BDN của N là P = 5*2=10. N = 17 ta tìm được số BDN của 17 là P = 653*17=11101.
Input:
Dòng đầu tiên ghi lại số tự nhiên T là số lượng Test;
T dòng kế tiếp mỗi dòng ghi lại một bộ Test. Mỗi test là một số tự nhiên N.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
3
2                     100
12                    11100
17                    11101
*/
//Ý tưởng: tạo các số bdn sau đó kiểm tra, do số tạo thành có thể rất lớn nên khi kiểm tra ta chỉ lấy phần dư
//Code:

#include <bits/stdc++.h>
using namespace std;

int n;

void init() {
    cin >> n;
}

bool check(string s) { //hàm kiểm tra điều kiện
    long long tmp = 0;
    for (int i = 0; i < s.length (); i++) { //tìm phần dư của số hiện tại với n
        tmp = tmp * 10 + (s[i] - 48);
        tmp %= n;
    }
    if (tmp == 0) return true; //nếu chia hết trả về true
    else return false;
}

void solve() {
    queue <string> s;
    s.push ("1"); //tạo số bdn đầu tiên
    while (1) {
        string res = s.front ();
        s.pop ();
        if (check (res)) {
            cout << res << endl; //đưa ra kết quả
            break;
        }
        s.push (res + "0"); //tạo 2 số bdn mới
        s.push (res + "1");
    }
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
96. DSA09013	LIỆT KÊ CẠNH CẦU VỚI BFS
/*Cho đồ thị vô hướng liên thông G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Sử dụng thuật toán BFS, hãy đưa ra
tất cả các cạnh cầu của đồ thị?
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm |E| + 1 dòng: dòng đầu tiên đưa vào hai số |V|, |E| tương ứng
với số đỉnh và số cạnh; |E| dòng tiếp theo đưa vào các bộ đôi uÎV, vÎV tương ứng với một cạnh của đồ thị.
T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra danh sách các cạch cầu của mỗi test theo từng dòng. In ra đáp án theo thứ tự từ điển, theo dạng “a b …” với a < b
Input                 Output
1
5 5                   2 5 3 4
1 2
1 3
2 3
2 5
3 4
*/
//Ý tưởng: xoá từng cạnh sau đó kiểm tra xem đồ thị mới có số thành phần liên thông lớn hơn đồ thị cũ thì đó là cạnh cầu
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, vs[1005];
vector <int> adjacent[1005];
vector <pair <int, int> > edge;

void reset() { //hàm khởi tạo lại mảng visited
    for (int i = 1; i <= v; i ++) vs[i] = 0; //đánh dấu tất cả các đỉnh chưa được thăm
}

void init(){ //hàm khởi tạo
    cin >> v >> e; //nhập số đỉnh và cạnh
    reset (); //gọi hàm reset
    while (e--) {
        int x, y;
        cin >> x >> y;
        adjacent[x].push_back (y); //tạo ma trận kề
        adjacent[y].push_back (x);
        edge.push_back ({x, y}); //cạnh x,y
    }
}

int bfs() { //hàm đếm số đỉnh bằng bfs
    int u;
    queue <int> q;
    q.push (1); //đẩy đỉnh 1 vào hàng đợi
    int cnt = 1; //khởi tạo số đỉnh đã duyệt qua bằng 1
    while (!q.empty ()) {
        u = q.front (); //gán đỉnh u là phần tử đầu tiên của queue
        vs[u] = 1; //đánh dấu đỉnh u đã thăm
        q.pop (); //xoá đỉnh u khởi queue
        for (int i = 0; i < adjacent[u].size (); i++) { //đếm số đỉnh được duyệt qua
            int tmp = adjacent[u][i];
            if (!vs[tmp]) { //nếu đỉnh chưa thăm
                vs[tmp] = 1; //đánh dấu đã thăm
                cnt++; //tăng số đỉnh
                q.push (tmp); //đẩy đỉnh hiện tại vào queue
            }
        }
    }
    return cnt; //trả về số đỉnh
}

void solve() {
    for (int i = 0; i < edge.size (); i++) { //duyệt qua tất cả các cạnh
        int x = edge[i].first, y = edge[i].second; //gán 2 giá trị đỉnh đầu và đỉnh cuối của cạnh
        vector <int>::iterator i1, i2; //khai báo con trỏ
        i1 = find (adjacent[x].begin (), adjacent[x].end (), y); //tìm kiếm đỉnh kề tương ứng
        i2 = find (adjacent[y].begin (), adjacent[y].end (), x);
        adjacent[x].erase (i1); //thực hiện xoá cạnh đó khỏi đồ thị
        adjacent[y].erase (i2);
        reset (); //gọi hàm reset
        //do đồ thị G liên thông nên đồ thị tạo thành có số thành phần liên thông khác 1 thì có cạnh cầu tức bfs()!=v
        if (bfs () != v) cout << x << " " << y << " "; //đưa ra kết quả nếu đó là cạnh cầu
        adjacent[x].insert (i1, y); //thực hiện thêm lại cạnh vừa xoá vào đồ thị
        adjacent[y].insert (i2, x);
    }
    for (int i = 1; i <= v; i++) adjacent[i].clear (); //xoá ma trận kề
    edge.clear (); //xoá các cạnh kề
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
97. DSA10004	ĐƯỜNG ĐI VÀ CHU TRÌNH EULER VỚI ĐỒ THỊ VÔ HƯỚNG
/*Cho đồ thị vô hướng liên thông G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy kiểm tra xem đồ thị có đường đi
Euler hay chu trình Euler hay không?
Đường đi Euler bắt đầu tại một đỉnh, và kết thúc tại một đỉnh khác.
Chu trình Euler bắt đầu tại một đỉnh, và kết thúc chu trình tại chính đỉnh đó.
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào hai số |V|, |E| tương ứng với số
đỉnh,  số cạnh của đồ thị; Dòng tiếp theo đưa vào các bộ đôi uÎV, vÎV tương ứng với một cạnh của đồ thị.
T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra 1, 2, 0 kết quả mỗi test theo từng dòng tương ứng với đồ thị có đường đi Euler, chu trình Euler và trường hợp
không tồn tại.
Input                                                Output
2
6  10                                                2
1 2 1 3 2 3 2 4 2 5 3 4 3 5 4 5 4 6 5 6
6 9                                                  1
1  2 1  3 2  3 2  4 2  5 3  4 3  5 4  5 4  6
*/
/*Ý tưởng: G liên thông và mọi đỉnh u có bậc chẵn là đồ thị euler.G liên thông và số đỉnh u có bậc lẻ không vượt quá 2
là có đường đi euler.*/
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, res, cnt, vs[1005], deg[1005];
vector <int> adjacent[1005];

void init() { //hàm khởi tạo
    cin >> v >> e;
    for (int i = 1; i <= v; i++) deg[i] = 0; //khởi tạo số bậc của các đỉnh bằng 1
    while (e--) {
        int x, y;
        cin >> x >> y;
        adjacent[x].push_back (y); //tạo danh sách kề
        adjacent[y].push_back (x);
        deg[x]++; //tăng số bậc của x
        deg[y]++; //tăng số bậc của y
    }
}

void dfs(int u) { //hàm đếm số đỉnh được duyệt qua bằng dfs
    vs[u] = 1;
    for (int i = 0; i < adjacent[u].size (); i++) {
        int tmp = adjacent[u][i];
        if (vs[tmp] == 0) {
            cnt++;
            dfs (tmp);
        }
    }
}

void solve() {
    cnt = 0; //khởi tạo cnt
    for (int i = 1; i <= v; i++)
        if (deg[i] % 2 == 1) cnt++; //đếm số đỉnh bậc lẻ
    if (cnt > 2) res = 0; //nếu số đỉnh bậc lẻ lớn hơn 2 thì không là đồ thị euler và nửa euler
    else if (cnt == 0) { //nếu không có số đỉnh bậc lẻ thì kiểm tra tính liên thông
        res = 2; //đánh dấu là đồ thị euler
        cnt = 1; //khởi tạo cnt = 1
        for(int i=1;i<=v;i++) vs[i]=0; //đánh dấu tất cả các đỉnh chưa được thăm
        dfs (1); //duyệt dfs từ đỉnh 1
        if (cnt != v) res = 0; //nếu đồ thị không liên thông thì không phải đồ thị euler
    } else { //nếu số đỉnh bậc lẻ không lớn hơn 2
        res = 1;  //đánh dấu là đồ thị nửa euler
        cnt = 1;  //khởi tạo cnt = 1
        for(int i=1;i<=v;i++) vs[i]=0; //đánh dấu tất cả các đỉnh chưa được thăm
        dfs (1); //duyệt dfs từ đỉnh 1
        if (cnt != v) res = 0; if (cnt != v) res = 0; //nếu đồ thị không liên thông thì không phải đồ thị euler
    }
    for (int i = 1; i <= v; i++) adjacent[i].clear (); //xoá ma trận kề
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
98. DSA10005	CHU TRÌNH EULER TRONG ĐỒ THỊ CÓ HƯỚNG
/*Cho đồ thị có hướng liên thông yếu G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy kiểm tra xem đồ thị có chu
trình Euler hay không?
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào hai số |V|, |E| tương ứng với số
đỉnh,  số cạnh của đồ thị; Dòng tiếp theo đưa vào các bộ đôi uÎV, vÎV tương ứng với một cạnh của đồ thị.
T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra 1, 0 kết quả mỗi test theo từng dòng tương ứng với đồ thị có chu trình Euler và trường hợp không tồn tại đáp án.
Input                                        Output
2
6  10                                        1
1 2 2 4 2 5 3 1 3 2 4 3 4 5 5 3 5 6 6 4
3 3                                          0
1 2 2 3 1 3
*/
//Ý tưởng: đồ thị liên thông có bán bậc vào bằng bán bậc ra là đồ thị euler
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, res, vs[1005], degIn[1005], degOut[1005];
vector <int> adjacent[1005];

void init() { //hàm khởi tạo
    cin >> v >> e;
    for (int i = 0; i <= v; i++) {
        vs[i] = 0; //đánh dấu đỉnh chưa được thăm
        degIn[i] = 0; //khởi tạo bán bậc vào bằng 0
        degOut[i] = 0; //khởi tạo bán bậc ra bằng 0
    }
    int x, y;
    while (e--) {
        cin >> x >> y;
        degOut[x]++; //tăng bán bậc vào
        degIn[y]++; //tăng bán bậc ra
        adjacent[x].push_back (y); //tạo ma trận kề
        adjacent[y].push_back (x);
    }
}

int bfs(int u) { //hàm đếm số đỉnh được duyệt bằng bfs
    vs[u] = 1; //đánh dấu đã thăm 1
    queue <int> q;
    q.push (u); //đưa 1 vào queue
    int cnt = 1; //khởi tạo số đỉnh được duyệt qua bằng 1
    while (!q.empty ()) {
        u = q.front ();
        q.pop ();
        for (int i = 0; i < adjacent[u].size (); i++) {
            int tmp = adjacent[u][i];
            if (!vs[tmp]) { //nếu chưa được duyệt qua
                cnt++; //tăng số đỉnh
                vs[tmp] = 1; //đánh dấu đã duyệt qua
                q.push (tmp); //đẩy đỉnh đó vào queue
            }
        }
    }
    return cnt; //trả về số đỉnh
}

void solve() { //hàm xử lý
    int res = 1; //khởi tạo kết quả bằng 1
    for (int i = 1; i <= v; i++)
        if (degIn[i] != degOut[i]) { //nếu bán bậc vào khác bán bậc ra
            res = 0; //không phải đồ thị euler
            break;
        }
    if (res && bfs (1) != v) res = 0; //đồ thị không liên thông không phải euler
    for (int i = 0; i <= v; i++) adjacent[i].clear ();
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
99. DSA11008	KIỂM TRA NODE LÁ
/*Cho cây nhị phân, nhiệm vụ của bạn là kiểm tra xem tất cả các node lá của cây có cùng một mức hay không? Ví dụ với cây
dưới đây sẽ cho ta kết quả là Yes.
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào số N là số lượng cạnh của cây;
dòng tiếp theo đưa vào N bộ ba (u, v, x), trong đó u là node cha, v là node con, x= R nếu v là con phải, x=L nếu v là
con trái; u, v, x được viết cách nhau một vài khoảng trống.
T, N, u, v, thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤103; 1≤u, v≤104;
Input                               Output
2
2                                   1
1 2 R 1 3 L
4                                   0
10 20 L 10 30 R 20 40 L 20 60 R
*/
//Ý tưởng: tìm level của la đầu tiên. sau đó tìm level của các lá khác nếu khác trả về 0
//Code:

#include <bits/stdc++.h>
using namespace std;

struct Node { //tạo kiểu dữ liệu Node với gốc và 2 node con
    int data;
    Node *left, *right;
    Node (int x) { //tạo cây mới
        data = x; //x là gốc
        left = right = NULL; //chưa có cây con
    }
};

void makeNode(Node* root, int b, int c) { //hàm tạo cây mới
    if (c == 'L') root->left = new Node (b); //tạo cây con bên trái
    else root->right = new Node (b); //tạo cây con bên phải
}

void findNode(Node* root, int a, int b, int c) {        // hàm tìm node cha
    if (root == NULL) return;
    if (root->data == a) makeNode (root, b, c);        // nếu tìm thấy node cha tạo cây con
    else {
        findNode (root->left, a, b, c);                // tìm ở cây con bên trái
        findNode (root->right, a, b, c);                // tìm ở cây con bên phải
    }
}

int checkLevel(Node* root) { //hàm kiểm tra mức
    if (!root) return 1; //nếu câu rỗng trả về 1
    queue <pair <Node *, int> > q;
    q.push ({root, 0}); //đưa cây ban đầu vào queue
    int res = INT_MAX; //khởi tạo res
    while (!q.empty ()) {
        int level = q.front ().second + 1; //tăng level
        Node *tmp = q.front ().first; //tạo cây trung gian
        q.pop ();
        if (!tmp->left && !tmp->right) { //nếu là lá
            if (res == INT_MAX) res = level; //nếu là lá đầu tiên đưa ra cập nhật kết quả
            else if (level != res) return 0; //nếu cây khác mức trả về 1
        }
        if (tmp->left) q.push ({tmp->left, level}); //đưa cây con bên trái vào queue
        if (tmp->right) q.push ({tmp->right, level}); //đưa cây con bên phải vào queue
    }
    return 1; //nếu cây cùng mức trả về 1
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        Node *root = NULL; //tạo cây rỗng
        int a, b;
        char c;
        while (n--) {
            cin >> a >> b >> c;
            if (root == NULL) { //nếu cây rỗng tạo cây mới
                root = new Node (a); //tạo gốc mới
                makeNode (root, b, c); //tạo cây con
            } else findNode (root, a, b, c); //nếu cây không rỗng tìm cây hiện tại
        }
        cout << checkLevel (root) << endl;
    }
    return 0;
}
100. DSA04020	TÌM KIẾM NHỊ PHÂN
/*Cho dãy số A[] gồm có N phần tử đã được sắp xếp tăng dần và số K.
Nhiệm vụ của bạn là kiểm tra xem số K có xuất hiện trong dãy số hay không. Nếu có hãy in ra vị trí trong dãy A[], nếu
không in ra “NO”.
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 10).
Mỗi test bắt đầu bằng số nguyên N và K (N ≤ 100 000, 0 ≤ K ≤ 106).
Dòng tiếp theo gồm N số nguyên A[i] (0 ≤ A[i] ≤ 106), các phần tử là riêng biệt.
Output:
Với mỗi test in ra trên một dòng đáp án tìm được.
Input                Output
2
5 3                  3
1 2 3 4 5
6 5                  NO
0 1 2 3 9 10
*/
//Ý tưởng: chia đôi đoạn hiện tại ra sau đó tìm kiếm
//Code:

#include<bits/stdc++.h>
using namespace std;

int n,k;
int a[100005];

void init() { //hàm khởi tạo
    cin >> n >> k;
    for (int i = 1; i <= n; i++) cin >> a[i];
}

void find(int x, int y) { //hàm tìm kiếm k
    int z = (x + y) / 2; //chia đôi đoạn
    if (a[z] == k) { //nếu tìm thấy k đưa ra vị trí của k
        cout << z << endl;
        return;
    } else if (a[z] > k) { //nếu vị trí giữa lớn hơn k
        if (a[z - 1] < k) { //nếu trước nó nhỏ hơn k đưa ra NO
            cout << "NO" << endl;
            return;
        } else if (a[z - 1] == k) { //nếu trước nó đúng bằng k trả về vị trí đó
            cout << z - 1 << endl;
            return;
        }
        find (x, z - 1); //tìm kiếm đoạn trước
    } else { //nếu vị trí giữa nhỏ hơn k
        if (a[z + 1] == k) { //nếu sau nó đúng bằng k trả về vị trí đó
            cout << z + 1 << endl;
            return;
        } else if (a[z + 1] > k) { //nếu sau nó nhỏ hơn k đưa ra NO
            cout << "NO" << endl;
            return;
        }
        find (z + 1, y); //tìm kiếm đoạn sau
    }
}

void solve() { //hàm xử lý
    if (a[n] < k || a[1] > k) cout << "NO" << "\n"; //nếu k không trong phạm vi đưa ra NO
    else find (1, n); //tìm kiếm k
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
101. DSA08017	SỐ LỘC PHÁT 1
/*Một số được gọi là lộc phát nếu chỉ có 2 chữ số 6 và 8. Cho số tự nhiên N. Hãy liệt kê các số lộc phát có không quá N
chữ số.
Input:
Dòng đầu tiên ghi lại số tự nhiên T là số lượng bộ test (T<10);
T dòng kế tiếp mỗi dòng ghi số N (1<N<15).
Output:
In ra đáp án theo thứ tự giảm dần.
Input                 Output
2
2                     88 86 68 66 8 6
3                     888 886 868 866 688 686 668 666 88 86 68 66 8 6
*/
//Ý tưởng: Sử dụng hàng đợi sinh ra các số lộc phát có không quá n chữ số
//Code:

#include <bits/stdc++.h>
using namespace std;

int n;
vector <string> res;

void init() { //hàm khởi tạo
    cin >> n;
}

void solve() { //hàm xử lý
    queue <string> q;
    q.push ("6"); //đẩy vào 2 số lộc phát đầu tiên
    q.push ("8");
    res.push_back ("6"); //thêm 2 số lộc phát đầu tiên vào vector kết quả
    res.push_back ("8");
    while (1) {
        if (q.front ().length () == n) return; //nếu đã tìm đến số lộc phát có độ dài n thì dừng lại
        q.push (q.front () + "6"); //thêm 2 số lộc phát tiếp theo vào hàng đợi
        q.push (q.front () + "8");
        res.push_back (q.front () + "6"); //thêm 2 số lộc phát đó vào vector kết quả
        res.push_back (q.front () + "8");
        q.pop (); //xoá số lộc phát đã duyệt qua khỏi hàng đợi
    }
}

void print() { //hàm in
    for (int i = res.size () - 1; i >= 0; i--) cout << res[i] << " "; //đưa ra kết quả
    cout << endl;
    res.clear (); //làm mới vector kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
        print ();
    }
    return 0;
}
102. DSA08018   SỐ LỘC PHÁT 2
/*Một số được gọi là lộc phát nếu chỉ có 2 chữ số 6 và 8. Cho số tự nhiên N. Hãy liệt kê các số lộc phát có không quá N
chữ số.
Input:
Dòng đầu tiên ghi lại số tự nhiên T là số lượng bộ test (T<10);
T dòng kế tiếp mỗi dòng ghi số N (1<N<15).
Output:
Dòng đầu tiên là số lượng số lộc phát tìm được. Dòng thứ hai in đáp án theo thứ tự tăng dần.
Input                 Output
2
2                     6
                      6 8 66 68 86 88
3                     14
                      6 8 66 68 86 88 666 668 686 688 866 868 886 888
*/
//Ý tưởng: in ra số các số lộc phát. Sử dụng hàng đợi sinh ra các số lộc phát có không quá n chữ số sau đó in trực tiếp
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, res;

void init() { //hàm khởi tạo
    cin >> n;
}

void solve() { //hàm xử lý
    res = 0; //khởi tạo số các số lộc phát
    for (int i = 1; i <= n; i++) res += pow (2, i); //tính số các số lộc phát
    cout << res << endl;
    queue <string> q;
    q.push ("6"); //đẩy vào 2 số lộc phát đầu tiên
    q.push ("8");
    while (1) {
        if (q.front ().length () > n) break; //nếu đã tìm đủ số lộc phát có độ dài n thì dừng lại
        cout << q.front () << " ";
        q.push (q.front () + "6"); //thêm 2 số lộc phát tiếp theo vào hàng đợi
        q.push (q.front () + "8");
        q.pop (); //xoá số lộc phát đã duyệt qua khỏi hàng đợi
    }
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
103. DSA08019	SỐ LỘC PHÁT 3
/*Một số được gọi là lộc phát nếu chỉ có 2 chữ số 6 và 8. Cho số tự nhiên N. Hãy liệt kê các số lộc phát có không quá N
chữ số.
Input:
Dòng đầu tiên ghi lại số tự nhiên T là số lượng bộ test (T<10);
T dòng kế tiếp mỗi dòng ghi số N (1<N<15).
Output:
In ra đáp án theo thứ tự giảm dần.
Input                 Output
2
2                     88 86 68 66 8 6
3                     888 886 868 866 688 686 668 666 88 86 68 66 8 6
*/
//Ý tưởng: Sử dụng hàng đợi sinh ra các số lộc phát có không quá n chữ số
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, cnt;
vector <string> res;

void init() { //hàm khởi tạo
    cin >> n;
}

void solve() { //hàm xử lý
    cnt = 0; //khởi tạo số các số lộc phát
    for (int i = 1; i <= n; i++) cnt += pow (2, i); //tính số các số lộc phát
    cout << cnt << endl;
    queue <string> q;
    q.push ("6"); //đẩy vào 2 số lộc phát đầu tiên
    q.push ("8");
    res.push_back ("6"); //thêm 2 số lộc phát đầu tiên vào vector kết quả
    res.push_back ("8");
    while (1) {
        if (q.front ().length () == n) return; //nếu đã tìm đến số lộc phát có độ dài n thì dừng lại
        q.push (q.front () + "6"); //thêm 2 số lộc phát tiếp theo vào hàng đợi
        q.push (q.front () + "8");
        res.push_back (q.front () + "6"); //thêm 2 số lộc phát đó vào vector kết quả
        res.push_back (q.front () + "8");
        q.pop (); //xoá số lộc phát đã duyệt qua khỏi hàng đợi
    }
}

void print() { //hàm in
    for (int i = res.size () - 1; i >= 0; i--) cout << res[i] << " "; //đưa ra kết quả
    cout << endl;
    res.clear (); //làm mới vector kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
        print ();
    }
    return 0;
}
104. DSA03034	DÃY CON CHUNG
/*Cho dãy số A[], B[] và C[] là dãy không giảm và có lần lượt N, M, K phần tử. Nhiệm vụ của bạn là hãy tìm các phần tử
chung của 3 dãy số này.
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test gồm số nguyên N, M và K (1≤ N, M, K ≤ 100 000).
Dòng tiếp theo gồm N số nguyên A[i], rồi M số nguyên B[i] và K số nguyên C[i].
(0 ≤ A[i], B[i], C[i] ≤ 10^9).
Output:
Với mỗi test, in ra trên một dòng là đáp án thu được. Nếu không tìm được đáp án, in ra “NO”.
Input                      Output
3
6 5 8                      20 80
1 5 10 20 40 80
5 7 20 80 100
3 4 15 20 30 70 80 120
3 5 4                      5 5
1 5 5
3 4 5 5 10
5 5 10 20
3 3 3                      NO
1 2 3
4 5 6
7 8 9
*/
/*Ý tưởng: do các dãy xếp tăng dần nên nếu tìm được 2 phần tử bằng nhau thì chỉ cần duyệt 2 phần tử tiếp sau nó, nếu
phần tử của mảng thứ nhất nhỏ hơn phần tử của mảng thứ 2 thì duyệt luôn phần tử tiếp theo của mảng thứ nhất*/
//Code:

#include<bits/stdc++.h>
using namespace std;

vector <int> res;
int tmp [100005];

void init(int n, int a[] ) { //hàm khởi tạo giá trị của mảng
    for (int i = 0; i < n; i++) cin >> a[i];
}

void intersect( int n1, int a[], int n2, int b[] ) { //hàm tìm phần tử giao
    int index = 0;
    for (int i = 0; i < n1; i++)
        for (int j = index; j < n2; j++) {
            if (a[i] == b[j]) { //nếu tìm được phần tử giao
                res.push_back (a[i]); //đẩy phần tử đó vào vector kết quả
                index = j + 1; //tăng index lên 1 vì chỉ cần duyệt từ phần tử sau 2 phần tử hiện tại
                break;
            } else if (a[i] < b[j]) {
                /*nếu phần tử của mảng 1 nhỏ hơn mảng 2 thì tìm kiếm luôn tại phần tử tiếp theo
                của mảng 1 với phần tử hiện tại của mảng 2*/
                index = j;
                break;
            }
        }
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        res.clear ();
        int n1, n2, n3;
        cin >> n1 >> n2 >> n3;
        int a[n1], b[n2], c[n3];
        init (n1, a);
        init (n2, b);
        init (n3, c);
        intersect (n1, a, n2, b);
        if (res.size () == 0) cout << "NO" << endl; //nếu không có mảng giao đưa ra NO
        else {
            int k = 0;
            for (int i = 0; i < res.size (); i++) tmp[k++] = res[i]; //gán tmp là mảng giao của mảng a với mảng b
            res.clear ();
            intersect (k, tmp, n3, c); //tìm mảng giao của mảng tmp với mảng c
            if (res.size () == 0) cout << "NO" << endl; //nếu không có mảng giao đưa ra NO
            else {
                for (int i = 0; i < res.size (); i++) cout << res[i] << " "; //đưa ra mảng giao
                cout << endl;
            }
        }
    }
    return 0;
}
105. DSA03035	SẮP XẾP ĐƠN GIẢN
/*Cho một dãy số a[] có n phần tử gồm các số từ 1 đến n theo 1 thứ tự ngẫu nhiên. Nhiệm vụ của bạn là sắp xếp lại dãy số
này theo thứ tự tăng dần với điều kiện : ở mỗi bước sắp xếp, bạn chỉ được chọn 1 số ở 1 vị trí bất kì và chuyển số đó
lên đầu dãy hoặc về cuối dãy.
Hãy tính số bước tối thiểu cần thực hiện để hoàn thành việc sắp xếp.
Input
Dòng đầu tiên ghi 1 số n: số lượng phần tử của dãy a (1 ≤ n ≤ 100000)
Dòng tiếp theo gồm n số từ 1 đến n theo thứ tự ngẫu nhiên
Output
Một số nguyên duy nhất là số bước tối thiểu cần thực hiện để hoàn thành việc sắp xếp.
Input                 Output
5                     2
4 1 2 5 3
*/
//Ý tưởng: tìm dãy con tăng liên tiếp dài nhất ví dụ ở case đề bài là dãy 1 2 3, sau đó lấy n trừ đi độ dài đó
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, a[100005];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    int maxIncre = 1; //dãy luôn có giá trị nhỏ nhất là 1
    int cnt[n+1]={0}; //khởi tạo mảng đếm độ dài dãy con
    for (int i = 0; i < n; i++) {
        if (cnt[a[i] - 1] == 0) cnt[a[i]] = 1; //nếu phần tử a[i-1] không có trong 1 dãy con thì gán độ dài dãy con là 1
        else cnt[a[i]] = cnt[a[i] - 1] + 1; //nếu phần tử a[i-1] có trong 1 dãy con thì tăng độ dài dãy lên 1
        maxIncre = max (maxIncre, cnt[a[i]]); //cập nhật kết quả
    }
    cout << n - maxIncre ; //đưa ra kết quả
}

int main() {
    init ();
    solve ();
    return 0;
}
106. CTDL_001	THUẬT TOÁN SINH
/*
Một xâu nhị phân độ dài n được gọi là thuận nghịch hay đối xứng nếu đảo ngược xâu nhị phân đó ta vẫn nhận được chính nó.
Cho số tự nhiên n (n nhập từ bàn phím). Hãy viết chương trình liệt kê tất cả các xâu nhị phân thuận nghịch có độ dài n.
Hai phần tử khác nhau của xâu thuận nghịch được ghi cách nhau một vài khoảng trống.Ví dụ với n = 4 ta tìm được 4 xâu nhị
phân thuận nghịch như dưới đây.
0 0 0 0
0 1 1 0
1 0 0 1
1 1 1 1
*/
//Ý tưởng: chia đôi xâu làm 2 phần và sinh lần lượt ra 2 xâu nhị phân đối xứng nhau.
//Code:

#include<bits/stdc++.h>
using namespace std;
int n, OK, a[20];

void init() { //hàm khởi tạo cấu hình đầu tiên
    for (int i = 0; i < n; i++) a[i] = 0;
}

//hàm in ra cấu hình hiện tại
void print() { //hàm in kết quả
    for (int i = 0; i < n; i++) cout << a[i] << " ";
    cout << endl;
}

void solve() { //hàm xử lý
    if (n % 2 == 0) {
        init (); //khởi tạo cấu hình đầu tiên
        while (OK == 0) {
            print ();             //in ra cấu hình đầu tiên
            OK = 1;
            //sinh xâu nhị phân kế tiếp trong khoảng từ đầu mảng đến vị trí n/2-1
            for (int i = n / 2 - 1; i >= 0; i--) {
                if (a[i] == 0) {
                    a[i] = 1;
                    for (int j = i + 1; j < n / 2; j++) a[j] = 0;
                    OK = 0;
                    break;
                }
            }
            //sinh xâu nhị phân kế tiếp trong khoảng từ cuối mảng đến vị trí n/2
            for (int i = n / 2; i < n; i++) {
                if (a[i] == 0) {
                    a[i] = 1;
                    for (int j = n / 2; j < i; j++) a[j] = 0;
                    break;
                }
            }
        }
    } else {
        init ();  //khởi tạo cấu hình đầu tiên
        print (); //in ra cấu hình đầu tiên
        while (OK == 0) {
            OK = 1;
            //sinh xâu nhị phân kế tiếp trong khoảng từ đầu mảng đến vị trí n/2-1
            for (int i = n / 2 - 1; i >= 0; i--) {
                if (a[i] == 0) {
                    a[i] = 1;
                    for (int j = i + 1; j < n / 2; j++) a[j] = 0;
                    OK = 0;
                    break;
                }
            }
            //sinh xâu nhị phân kế tiếp trong khoảng từ cuối mảng đến vị trí n/2
            for (int i = n / 2 + 1; i < n; i++) {
                if (a[i] == 0) {
                    a[i] = 1;
                    for (int j = n / 2 + 1; j < i; j++) a[j] = 0;
                    break;
                }
            }
            //gán vị trí a[n/2] lần lượt bằng 0 và 1
            for (int k = 0; k < 2; k++) {
                a[n / 2] = k;
                if (OK == 0) {
                    print (); //in ra cấu hình hiện tại
                }
            }
        }
    }
}

int main() {
    cin >> n;
    OK = 0;
    solve ();
    return 0;
}
107. CTDL_002	Tổng dãy con = K
/*Cho dãy A[] gồm N số tự nhiên khác nhau và số tự nhiên K. Hãy viết chương trình liệt kê tất cả các dãy con của dãy số
A[] sao cho tổng các phần tử trong dãy con đó đúng bằng K. Dữ liệu vào trên bàn phím (n=5, K=50), 5 số dòng thứ 2 là các
phần tử dãy A:
    5                      50
    5                      10                    15                    20                    25
Các dãy con thoả mãn điều kiện tìm được liệt kê trên màn hình:
Mỗi dòng ghi lại một dãy con. Hai phần tử khác nhau của dãy con được viết cách nhau bởi một  khoảng trống.
Dòng cuối cùng ghi lại số các dãy con có tổng các phần tử đúng bằng K tìm được.
           10                    15                    25
           5                      20                    25
           5                      10                    15                    20
           3
*/
//Ý tưởng: Sử dụng quay lui với 1 là có sử dụng phần tử và 0 là không sử dụng phần tử
//Code: 

#include<bits/stdc++.h>
using namespace std;
int n, k, a[10];

int cnt=0; // bắt đầu thử từ vị trí i=0

void Try(int i, int sum, vector <int> res) { //hàm quay lui
    for (int j = 0; j < 2; j++) { //vòng lặp với 0 ứng với không sử dụng và 1 ứng với sử dụng
        if (j == 1) { //nếu a[i] được sử dụng thì đưa a[i] vào mảng kết quả
            res.push_back (a[i]);
            sum += a[i]; //tăng tổng lên a[i]
            if (sum == k) { //nếu tồng bằng k thì đưa ra kết quả và tăng biến đếm sau đó dừng duyệt nhánh này
                cnt++;
                for (int h = 0; h < res.size (); h++) cout << res[h] << " ";
                cout << endl;
                return;
            } else if (sum > k) return; //nếu tổng lớn hơn k thì dừng duyệt nhánh này
            else { //nếu tổng nhỏ hơn k và chưa duyệt hết mảng thì tiếp tục thử tại vị trí i+1
                if (i < n - 1) Try (i + 1, sum, res);
            }
            //sau khi dùng xong a[i] thì trả lại tổng trước đó và mảng trước đó
            sum -= a[i];
            res.pop_back ();
        } else { //nếu chưa sử dụng và chưa duyệt hết mảng thì tiếp tục thử tại vị trí i+1
            if (i < n - 1) Try (i + 1, sum, res);
        }
    }
}

int main() {
    cin >> n >> k;
    for (int i = 0; i < n; i++) cin >> a[i];
    sort (a, a + n); //sắp xếp lại mảng a
    vector <int> res; //khai báo mảng kết quả
    Try (0, 0, res); //thử tại i=0 và tổng bằng 0
    cout << cnt; //in ra tổng số trường hợp thoả mãn
    return 0;
}
108. DSA01019	HAHAHA
/*Khi chat chit vui vẻ, anh em chiến hữu thường hay gõ HAHA để thể hiện sự sảng khoái. Đôi khi cũng có thể gõ HAHAAAAA
chẳng hạn cho thêm phần nhấn mạnh.
Giả sử một xâu ký tự được coi là HAHA nếu thỏa mãn các điều kiện:
Ký tự đầu tiên phải là chữ H, ký tự cuối cùng phải là chữ A
Không có hai chữ H nào liền nhau
Cho trước độ dài N, hãy liệt kê tất cả các xâu ký tự HAHA theo thứ tự từ điển.
Input
Dòng đầu ghi số bộ test T (không quá 10)
Mỗi bộ test ghi độ dài N (2 <= N < 16)
Output
Với mỗi bộ test, ghi ra tất cả các xâu HAHA tìm được theo thứ tự từ điển, mỗi xâu viết trên một dòng.
Input                Output
2
2                    HA
4                    HAAA
                     HAHA
*/
//Ý tưởng: sinh ra tất cả các xâu sau đó kiểm tra xem xâu nào thoả mãn điều kiện thì in
//Code:

#include<bits/stdc++.h>
using namespace std;
int n;
char a[20];

void print() { //hàm in kết quả
    for (int i = 1; i <= n; i++) cout << a[i];
    cout << endl;
}

void init() { //hàm khởi tạo
    cin >> n;
}

void solve() { //hàm xử lý
    if (n == 2) cout << "HA" << endl; //n=2 và n=3 có đúng 1 xâu duy nhất
    else if (n == 3) cout << "HAA" << endl;
    else {
        a[1] = 'H', a[2] = 'A', a[n] = 'A';
        for (int i = 3; i < n; i++) a[i] = 'A';
        print (); //in ra xâu đầu tiên
        for (int i = n - 1; i >= 3; i--) { //sinh ra các xâu tiếp theo
            if (a[i] == 'A') {
                a[i] = 'H';
                for (int j = i + 1; j < n; j++) a[j] = 'A';
                int check = 1; //đánh dấu là xâu thoả mãn
                for (int i = 2; i < n - 1; i++)
                    if (a[i] == 'H' && a[i + 1] == 'H') {
                        check = 0; //nếu xâu không thoả mãn đánh dấu là không
                        break;
                    }
                if (check) print (); //nếu xâu thoả mãn thực hiện in
                i = n; //đặt lại i = n để sinh ra xâu tiếp theo
            }
        }
    }
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
109. DSA01020	XÂU NHỊ PHÂN TRƯỚC
/*Cho xâu nhị phân X[], nhiệm vụ của bạn là hãy đưa ra xâu nhị phân trước của X[]. Ví dụ X[] =”111111” thì xâu nhị phân
trước của X[] là “111110”. Với xâu X[] =“000001” thì xâu nhị trước của X[] là “000000”. Chú ý: nếu xâu dữ liệu trong
input là xâu đầu tiên thì trước nó sẽ là xâu cuối cùng.
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một xâu nhi phân X.
T, X[] thỏa mãn ràng buộc: 1≤T≤100; 1≤length(X)≤10^3.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
2
010101                010100
111111                111110
*/
//Ý tưởng: ngược với sinh xâu nhị phân kế tiếp
//Code:

#include <bits/stdc++.h>
using namespace std;

string str;

void init(){ //hàm khởi tạo
    cin>>str;
}

void solve() { //hàm xử lý
    int check = 0;
    for (int i = str.length () - 1; i >= 0; i--)
        if (str[i] == '1') { //tìm số 1 đầu tiên từ cuối lên
            str[i] = '0'; //chuyển nó thành số 0
            check = 1; //đánh dấu đã tìm được cấu hình kế tiếp
            for (int j = i + 1; j < str.length (); j++) str[j] = '1'; //chuyển tất cả các số sau nó thành 1
            break;
        }
    if (check == 0) //đưa ra kết quả
        for (int i = 0; i < str.length (); i++) cout << "1";
    else cout << str;
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
110. DSA03022	TÍCH LỚN NHẤT
/*Cho dãy số A gồm N phần tử là các số nguyên. Hãy tính tích lớn nhất của 2 hoặc 3 phần tử trong dãy.
Input
Dòng đầu tiên ghi số N (3 ≤ N ≤ 10000)
Dòng thứ 2 ghi N số của dãy A (|Ai| ≤ 1000)
Outpput
Ghi ra kết quả trên một dòng
Input                Output
6                    250
5 10 -2 3 5 2
*/
//Ý tưởng: Thử tất cả các trường hợp có thể xảy ra của input sau đó lập tích lớn nhất của từng trường hợp
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, a[10005];

void init() { //hàm khởi tạo
    cin >> n;
    for (long i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    sort (a, a + n); //sắp xếp lại mảng
    long long res;
    if (a[n - 1] <= 0) res = a[0] * a[1]; //nếu tất cả phần tử đều âm thì tích bằng tích của 2 số nhỏ nhất
    else if (a[n - 3] > 0) { //nếu 3 phần tử cuối đều lớn hơn 0
        if (a[0] * a[1] < a[n - 3] * a[n - 2]) res = a[n - 1] * a[n - 2] * a[n - 3]; //so sánh tích 2 số min và max
        else res = a[0] * a[1] * a[n - 1];
    } else if (a[n - 2] <= 0 && a[n - 1] > 0) res = a[0] * a[1] * a[n - 1]; //nếu chỉ có 1 số nguyên dương
    else if (a[n - 3] <= 0 && a[n - 2] > 0) { //nếu có 2 số nguyên dương
        if (a[0] * a[1] > a[n - 2]) res = a[0] * a[1] * a[n - 1]; //so sánh tích 2 số min với số lớn thứ 2
        else res = a[n - 2] * a[n - 1];
    }
    cout << res << endl; //đưa ra kết quả
}

int main() {
    init ();
    solve ();
    return 0;
}
111. DSA01025	ĐẶT TÊN
/*Vương quốc PTIT sử dụng bảng chữ cái gồm N chữ cái Latinh viết hoa. Quy tắc đặt tên của gia đình Hoàng gia  PTIT là
chọn ra K chữ cái (không trùng nhau) và sắp xếp lại theo thứ tự từ điển.
Hãy liệt kê tất cả các cái tên có thể có của gia đình Hoàng gia PTIT
Input
Dòng đầu ghi số bộ test T (không quá 10)
Mỗi bộ test ghi 2 số N và K (3 < K < N < 16)
Output
Với mỗi bộ test, ghi ra tất cả các cái tên có thể được tạo ra, mỗi kết quả viết trên một dòng.
Input                 Output
1                     AB
4 2                   AC
                      AD
                      BC
                      BD
                      CD
*/
//Ý tưởng: sử dụng quay lui với 1 là có sử dụng và 0 là không sử dụng
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, k, a[20];

void Try(int i, int cnt) { //hàm quay lui
    for (int j = 1; j >= 0; j--) {
        if (j == 1) {
            cnt++; //tăng số ký tự
            a[cnt] = i; //cập nhật tên
            if (cnt == k) { //nếu đủ số ký tự thì in
                for (int i = 1; i <= k; i++) {
                    char tmp = a[i];
                    cout << tmp;
                }
                cout << endl;
            } else if (cnt < k) { //nếu chưa đủ ký tự thực hiện quay lui nếu vẫn còn có ký tự trong phạm vi
                if (i < 64 + n) Try (i + 1, cnt);
            } else return; //nếu quá số ký tự thì dừng nhánh
            cnt--;
        } else { //nếu không sử dụng thực hiện quay lui nếu vẫn còn có ký tự trong phạm vi
            if (i < 64 + n) Try (i + 1, cnt);
        }
    }
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        cin >> n >> k;
        Try (65, 0);
    }
    return 0;
}
112. CTDL_005	XÓA DỮ LIỆU TRONG DSLK ĐƠN
//
// Created by khanh on 10/04/2021.
//
/*
Cho danh sách liên kết đơn lưu giữ các số nguyên được quản lý bởi con trỏ First. Viết chương trình con xóa tất cả các
phần tử có giá trị bằng x trong danh sách liên kết đơn; chương trình con trả về số lượng các phần tử đã xóa. Sau khi xóa
xong, liệt kê các phần tử còn lại trong danh sách liên kết đơn First. Ví dụ: Ta có Input sau:
14 : là số lượng phần tử trong danh sách
1 1 1 4 5 1 1 1 1 7 1 8 1 9   : là 14 phần tử
1 : là số cần xóa
Output :  4 5 7 8 9
*/
//Ý tưởng: tìm x và xoá
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, x, a[1005];

void init() { //hàm khởi tạo
    cin >> n;
    for (long i = 0; i < n; i++) cin >> a[i];
    cin >> x;
}

void solve() { //hàm xử lý
    for (long i = 0; i < n; i++)
        if (a[i] != x) cout << a[i] << " "; //nếu a[i] khác x thì in ra kết quả
}

int main() {
    init ();
    solve ();
    return 0;
}
113. CTDL_006	LỌC DỮ LIỆU TRÙNG TRONG DSLK ĐƠN
#include <bits/stdc++.h>
using namespace std;

int n, a[1005];
vector <int> b;

void init() { //hàm khởi tạo
    cin >> n; //nhập vào mảng a và sao chép mảng a vào vector b
    for (long i = 0; i < n; i++) {
        cin >> a[i];
        b.push_back (a[i]);
    }
}

void solve() { //hàm xử lý
    sort (b.begin (), b.end ()); //sắp xếp vector b
    for (long i = 1; i < b.size (); i++) //tìm các số xuất hiện trong b
        if (b[i] == b[i - 1]) {
            b.erase (b.begin () + i); //xoá các số trùng
            i = 0;
        }
    while (b.size () > 0) { //vòng lặp cho đến khi kích thước của b bằng 0
        for (long i = 0; i < n; i++) {
            for (long j = 0; j < b.size (); j++) {
                if (a[i] == b[j]) { //nếu xuất hiện b[j] trong a[i] thì in ra a[i] và xoá phần tử đó khỏi vector b
                    cout << a[i] << " ";
                    b.erase(b.begin()+j); //xoá phần tử đã được xuất
                }
            }
        }
    }
}

int main() {
    init ();
    solve ();
    return 0;
}
114. DSA07023	ĐẢO TỪ
/*Cho xâu ký tự S. Nhiệm vụ của bạn là đảo ngược các từ trong S. Ví dụ S =  “I like this program very much”, ta nhận
được kết quả là “much very program this like I”.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test là một xâu ký tự S.
T, S thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ Length(S)≤103.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Ví dụ:
Input:                                  Output:
2
I like this program very much           much very program this like I
much very program this like I           I like this program very much
*/
//Ý tưởng: đẩy các từ vào ngắn xếp sau đó in ra đỉnh của ngăn xếp cho đến khi ngăn xếp rỗng
//Code:

#include<bits/stdc++.h>
using namespace std;

string str;

void init() { //hàm khởi tạo
    getline (cin, str);
}

void solve() { //hàm xử lý
    stack <string> s;
    string tmp = "";
    for (int i = 0; i < str.length (); i++) {
        if (str[i] != ' ') tmp += str[i]; //nếu là ký tự thuộc 1 từ cập nhật chuỗi trung gian
        else {
            s.push (tmp); //nếu đã duyệt hết tử đẩy từ đó vào ngăn xếp
            tmp = ""; //gán lại chuỗi trung gian
        }
    }
    s.push (tmp); //đẩy từ cuối cùng vào ngăn xếp
    while (!s.empty ()) {
        cout << s.top () << " "; //in ra kết quả
        s.pop ();
    }
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    cin.ignore ();
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
115. DSA06040	GIAO CỦA BA DÃY SỐ
/*Cho ba dãy số A[], B[], C[] gồm N1, N2, N3 phần tử đã được sắp xếp. Hãy đưa ra các phần tử có mặt trong cả ba dãy theo
thứ tự tăng dần. Nếu không có đáp án, in ra -1.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm bốn dòng: dòng thứ nhất đưa vào N1, N2, N3 là số phần tử của
mảng A[], B[], C[]; các dòng tiếp theo đưa vào 3 dãy A[], B[], C[].
Ràng buộc: 1≤T≤100; 1≤ N1, N2, N3 ≤106, 0≤ A[i], B[j], C[k] ≤1018.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                   Output
1
6 5 8                   20 80
1 5 10 20 40 80
6 7 20 80 100
3 4 15 20 30 70 80 120
*/
/*Ý tưởng: do các dãy xếp tăng dần nên nếu tìm được 2 phần tử bằng nhau thì chỉ cần duyệt 2 phần tử tiếp sau nó, nếu
phần tử của mảng thứ nhất nhỏ hơn phần tử của mảng thứ 2 thì duyệt luôn phần tử tiếp theo của mảng thứ nhất*/
//Code:

#include<bits/stdc++.h>
using namespace std;

vector <long long> res;
long long tmp [1000005];

void init(int n, long long a[] ) { //hàm khởi tạo giá trị của mảng
    for (int i = 0; i < n; i++) cin >> a[i];
}

void intersect( int n1, long long a[], int n2, long long b[] ) { //hàm tìm phần tử giao
    int index = 0;
    for (int i = 0; i < n1; i++)
        for (int j = index; j < n2; j++) {
            if (a[i] == b[j]) { //nếu tìm được phần tử giao
                res.push_back (a[i]); //đẩy phần tử đó vào vector kết quả
                index = j + 1; //tăng index lên 1 vì chỉ cần duyệt từ phần tử sau 2 phần tử hiện tại
                break;
            } else if (a[i] < b[j]) {
                /*nếu phần tử của mảng 1 nhỏ hơn mảng 2 thì tìm kiếm luôn tại phần tử tiếp theo
                của mảng 1 với phần tử hiện tại của mảng 2*/
                index = j;
                break;
            }
        }
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        res.clear ();
        int n1, n2, n3;
        cin >> n1 >> n2 >> n3;
        long long a[n1], b[n2], c[n3];
        init (n1, a);
        init (n2, b);
        init (n3, c);
        intersect (n1, a, n2, b);
        if (res.size () == 0) cout << -1 << endl; //nếu không có mảng giao đưa ra -1
        else {
            int k = 0;
            for (int i = 0; i < res.size (); i++) tmp[k++] = res[i]; //gán tmp là mảng giao của mảng a với mảng b
            res.clear ();
            intersect (k, tmp, n3, c); //tìm mảng giao của mảng tmp với mảng c
            if (res.size () == 0) cout << -1 << endl; //nếu không có mảng giao đưa ra -1
            else {
                for (int i = 0; i < res.size (); i++) cout << res[i] << " "; //đưa ra mảng giao
                cout << endl;
            }
        }
    }
    return 0;
}
116. DSA09021	CHUYỂN MA TRẬN KỀ SANG DANH SÁCH KỀ
/*Ma trận kề A của một đồ thị vô hướng là một ma trận chỉ có các số 0 hoặc 1 trong đó A[i][j] = 1 có ý nghĩa là đỉnh i
kề với đỉnh j (chỉ số tính từ 1).
Danh sách kề thì liệt kê các đỉnh kề với đỉnh đó theo thứ tự tăng dần.
Hãy chuyển biểu diễn đồ thị từ dạng ma trận kề sang dạng danh sách kề.
Input: Dòng đầu tiên chứa số nguyên n – số đỉnh của đồ thị (1 < n ≤ 1000). n dòng tiếp theo, mỗi dòng có n số nguyên có
giá trị 0 và 1 mô tả ma trận kề của đồ thị.
Output:  Gồm n dòng, dòng thứ i chứa các số nguyên là đỉnh có nối với đỉnh i và được sắp xếp tăng dần. Dữ liệu đảm bảo
mỗi đỉnh có kết nối với ít nhất 1 đỉnh khác.
Input                 Output
3
0 1 1                 2 3
1 0 1                 1 3
1 1 0                 1 2
*/
//Ý tưởng: duyệt ma trận nếu a[i][j] bằng 1 thì tồn tại cạnh
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, a[1005][1005];
vector <int> res[1005];

void init(){ //hàm khởi tạo
    cin>>n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
            cin>>a[i][j];
            if(a[i][j]==1) res[i].push_back (j); //tạo danh sách kề
        }
}

void solve() { //hàm xử lý
    for (int i = 1; i <= n; i++) { //
        for (int j = 0; j < res[i].size (); j++)
            cout << res[i][j] << " "; //đưa ra kết quả
        cout << endl;
    }
}

int main() {
    init ();
    solve ();
    return 0;
}
117. DSA09020	CHUYỂN DANH SÁCH KỀ SANG MA TRẬN KỀ
/*Cho đơn đồ thị vô hướng có n đỉnh dưới dạng danh sách kề.
Hãy biểu diễn đồ thị bằng ma trận kề.
Input: Dòng đầu tiên chứa số nguyên n – số đỉnh của đồ thị (1 ≤  n ≤  1000). n dòng tiếp theo, dòng thứ i chứa các số
nguyên là các đỉnh kề với đỉnh i.
Output:  Ma trận kề của đồ thị.
Input                Output
3
2 3                  0 1 1
1 3                  1 0 1
1 2                  1 1 0
*/
//Ý tưởng: gặp cạnh nào thì gán cạnh tương ứng ở ma trận kề bằng 1
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, a[1005][1005];

void init() { //hàm khởi tạo
    cin >> n;
    cin.ignore ();
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            a[i][j] = 0; //gán tất cả giá trị của ma trận kề bằng 0
    for (int i = 1; i <= n; i++) {
        string str;
        getline (cin, str); //nhập vào danh sách đỉnh kề
        str += " ";
        int x = 0;
        for (int j = 0; j < str.length (); j++) //chuyển đổi đỉnh kể sang int sau đó gán giá trị ở ma trận kề bằng 1
            if (str[j] != ' ') x = x * 10 + (int) (str[j] - '0');
            else {
                a[i][x] = 1;
                x = 0;
            }
    }
}

void solve() { //hàm xử lý
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++)
            cout << a[i][j] << " "; //đưa ra kết quả
        cout << endl;
    }
}

int main() {
    init ();
    solve ();
    return 0;
}
118. DSA09022	DFS TRÊN ĐỒ THỊ CÓ HƯỚNG
/*Cho đồ thị có hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy viết thuật toán duyệt theo chiều sâu bắt đầu
tại đỉnh uÎV (DFS(u)=?)
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào ba số |V|, |E|, uÎV tương ứng
với số đỉnh, số cạnh và đỉnh bắt đầu duyệt; Dòng tiếp theo đưa vào các bộ đôi uÎV, vÎV tương ứng với một cạnh của đồ thị
T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤200; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra danh sách các đỉnh được duyệt theo thuật toán DFS(u) của mỗi test theo khuôn dạng của ví dụ dưới đây.
Input                                   Output
1
6 9 5                                   5 4 3 1 2 6
1 2 2 5 3 1 3 2 3 5 4 3 5 4 5 6 6 3
*/
//Ý tưởng: thực hiện thuật toán dfs được học ở môn toán rời rạc 2
//Code:

#include <bits/stdc++.h>
using namespace std;
int v, e, first, vs[1005];
vector <int> adjacent[1005];

void init() { //hàm khởi tạo
    cin >> v >> e >> first;
    int i, j;
    while (e--) {
        cin >> i >> j;
        adjacent[i].push_back (j); //tạo ma trận kề
    }
}

void dfs(int u) { //hàm dfs
    cout << u << " "; //in đỉnh hiện tại
    vs[u] = 1; //đánh dấu đã thăm
    for (int i = 0; i < adjacent[u].size (); i++) {
        int tmp = adjacent[u][i];
        if (!vs[tmp]) dfs (tmp); //nếu chưa được thăm gọi dfs tại đỉnh đó
    }
}

void solve() { //hàm xử lý
    memset (vs, 0, sizeof (vs)); //đánh dấu tất cả chưa được thăm
    dfs (first); //duyệt dfs từ đỉnh đầu vào
    for (int i = 1; i <= v; i++) adjacent[i].clear (); //làm mới ma trận kề
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
119. DSA09024	BFS TRÊN ĐỒ THỊ CÓ HƯỚNG
/*Cho đồ thị có hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy viết thuật toán duyệt theo chiều rộng bắt
đầu tại đỉnh uÎV (BFS(u)=?)
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào ba số |V|, |E|, uÎV tương ứng
với số đỉnh, số cạnh và đỉnh bắt đầu duyệt; Dòng tiếp theo đưa vào các bộ đôi uÎV, vÎV tương ứng với một cạnh của đồ thị.
T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤200; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra danh sách các đỉnh được duyệt theo thuật toán BFS(u) của mỗi test theo khuôn dạng của ví dụ dưới đây
Input                                   Output
1
6  9  1                                 1 2 5 4 6 3
1 2 2 5 3 1 3 2 3 5 4 3 5 4 5 6 6 4
*/
//Ý tưởng: sử dụng thuật toán bfs được học ở môn toán rời rạc 2
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, first, vs[1005];
queue <int> q;
vector <int> a[1005];

void bfs(int u) { //hàm bfs
    q.push (u); //đẩy đỉnh đầu tiên vào hàng đợi
    vs[u] = 1; //đánh dấu đã duyệt qua đỉnh đó
    while (!q.empty ()) {
        u = q.front ();
        cout << u << " "; //in ra đỉnh được duyệt tới
        q.pop (); //xoá đỉnh đã duyệt qua khỏi hàng đợi
        for (int i = 0; i < a[u].size (); i++) { //tìm tất cả các đỉnh chưa được duyệt qua là đỉnh kề của đỉnh hiện tại
            int tmp = a[u][i];
            if (vs[tmp] == 0) {
                q.push (tmp); //đẩy đỉnh tìm thấy vào hàng đợi
                vs[tmp] = 1; //đánh dấu đã duyệt qua
            }
        }
    }
}

void init() { //hàm khởi tạo
    cin >> v >> e >> first;
    while (e--) {
        int i, j;
        cin >> i >> j;
        a[i].push_back (j); //tạo ma trận kề
    }
}

void solve() { //hàm xử lý
    for (int i = 1; i <= v; i++) vs[i] = 0; //đánh dấu tất cả các đỉnh chưa được duyệt qua
    bfs (first); //thực hiện bfs tại đỉnh first
    for (int i = 1; i <= v; i++) a[i].clear (); //làm mới ma trận kề
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
120. DSA09025	TÌM ĐƯỜNG ĐI THEO DFS VỚI ĐỒ THỊ CÓ HƯỚNG
/*Cho đồ thị có hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy tìm đường đi từ đỉnh sÎV đến đỉnh tÎV trên
đồ thị bằng thuật toán DFS.
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào bốn số |V|, |E|, sÎV, tÎV tương
ứng với số đỉnh, số cạnh,  đỉnh u, đỉnh v; Dòng tiếp theo đưa vào các bộ đôi uÎV, vÎV tương ứng với một cạnh của đồ thị.
T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra đường đi từ đỉnh s đến đỉnh t của mỗi test theo thuật toán DFS của mỗi test theo khuôn dạng của ví dụ dưới đây.
Nếu không có đáp án, in ra -1.
Input                                   Output
1
6  9  1  6                              1 2 5 6
1 2 2 5 3 1 3 2 3 5 4 3 5 4 5 6 6 4
*/
//Ý tưởng: Sử dụng thuật toán dfs để duyệt. Nếu tìm thấy đỉnh kết thúc đưa ra đường đi
#include <bits/stdc++.h>
using namespace std;

int v, e, first, last, vs[1005], previous[1005];
vector <int> a[1005];
vector <int> res;

void dfs(int u){ //hàm dfs
    if(vs[last]==1) return; //nếu đã tìm thấy đường đi thì dừng lại
    vs[u]=1; //đánh dấu đỉnh đã được thăm
    for(int i=0;i<a[u].size();i++){ //tìm đỉnh chưa được thăm kề với đỉnh hiện tại
        int tmp=a[u][i];
        if(!vs[tmp]){
            previous[tmp]=u; //cập nhật đường đi
            dfs(tmp); //gọi dfs tại đỉnh vừa tìm thấy
        }
    }
}

void init(){
    cin >> v >> e >> first >> last;
    while (e--) {
        int x, y;
        cin >> x >> y;
        a[x].push_back (y);
    }
}

void solve() {
    for (int i = 1; i <= v; i++) vs[i] = 0; //đánh dấu đỉnh chưa được thăm
    for (int i = 1; i <= v; i++) previous[i] = 0; //đánh dấu không có đỉnh trước
    dfs (first); //gọi dfs tại đỉnh đầu tiên
    if (vs[last] == 0) cout << "-1"; //nếu không có đường đi đưa ra -1
    else { //nếu có đường đi sắp xếp lại theo chiều xuôi
        res.clear ();
        while (last > 0) { //nếu không còn đỉnh trước đó thì đã duyệt hết đường đi
            res.push_back (last); //nếu tìm được đỉnh trước đó thì tìm tiếp đỉnh trước nó
            last = previous[last];
        }
        for (int i = res.size () - 1; i >= 0; i--) cout << res[i] << " "; //đưa ra kết quả
    }
    cout << endl;
    for (int i = 1; i <= v; i++) a[i].clear (); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
121. DSA09026	ĐƯỜNG THI THEO BFS TRÊN ĐỒ THỊ CÓ HƯỚNG
/*Cho đồ thị có hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy tìm đường đi từ đỉnh uÎV đến đỉnh vÎV trên
đồ thị bằng thuật toán BFS.
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào bốn số |V|, |E|, sÎV, tÎV tương
ứng với số đỉnh, số cạnh,  đỉnh u, đỉnh v; |E| Dòng tiếp theo đưa vào các bộ đôi uÎV, vÎV tương ứng với một cạnh của đồ
thị. T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra đường đi từ đỉnh s đến đỉnh t của mỗi test theo thuật toán BFS của mỗi test theo khuôn dạng của ví dụ dưới đây.
Nếu không có đáp án, in ra -1.
Input                                    Output
1
6 9 1 6                                  1 2 5 6
1 2 2 5 3 1 3 2 3 5 4 3 5 4 5 6 6 4
*/
//Ý tưởng: duyệt bfs nếu tìm thấy đỉnh cuối thì đưa ra đường đi
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, first, last, vs[1005], previous[1005];
queue <int> q;
vector <int> a[1005];

void bfs(int u) { //hàm bfs
    q.push(u); //đẩy đỉnh đầu tiên vào hàng đợi
    vs[u] = 1; //đánh dấu đỉnh đã được duyệt qua
    while (! q.empty()) {
        u = q.front();
        q.pop();
        for (int i = 0; i < a[u].size(); i ++) { //tìm các đỉnh chưa được thăm kề với đỉnh hiện tại
            int tmp = a[u][i];
            if (vs[tmp] == 0) {
                q.push(tmp); //nếu tìm thấy đẩy nó vào hàng đợi
                vs[tmp] = 1; //đánh dấu đã được thăm
                previous[tmp] = u; //cập nhật đường đi
                if (tmp == last) return; //nếu tìm thấy đỉnh cuối dừng lại
            }
        }
    }
}

void init() {
    cin >> v >> e >> first >> last;
    while (e--) {
        int i, j;
        cin >> i >> j;
        a[i].push_back (j); //tạo ma trận kề
    }
}

void solve() {
    for (int i = 1; i <= v; i++) vs[i] = 0; //đánh dấu đỉnh chưa được thăm
    for (int i = 1; i <= v; i++) previous[i] = 0; //đánh dấu không có đỉnh trước
    bfs (first); //gọi bfs tại đỉnh đầu tiên
    if (previous[last] == 0) cout << "-1"; //nếu không có đường đi đưa ra -1
    else { //nếu có đường đi sắp xếp lại theo chiều xuôi của đường đi
        vector <int> res;
        while (last > 0) { //nếu không còn đỉnh trước đó thì đã duyệt hết đường đi
            res.push_back (last); //nếu tìm được đỉnh trước đó thì tìm tiếp đỉnh trước nó
            last = previous[last];
        }
        for (int i = res.size () - 1; i >= 0; i--) cout << res[i] << " "; //đưa ra kết quả
    }
    cout << endl;
    while (!q.empty ()) q.pop (); //làm mới hàng đợi
    for (int i = 1; i <= v; i++) a[i].clear (); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
122. DSA09027	KIỂM TRA ĐƯỜNG ĐI
/*Cho đồ thị vô hướng có N đỉnh và M cạnh. Có Q truy vấn, mỗi truy vấn yêu cầu trả lời câu hỏi giữa 2 đỉnh x và y có tồn
tại đường đi tới nhau hay không?
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test gồm 2 số nguyên N, M (1 ≤ N, M ≤ 1000).
M dòng tiếp theo, mỗi dòng gồm 2 số nguyên u, v cho biết có cạnh nối giữa đỉnh u và v.
Dòng tiếp là số lượng truy vấn Q (1 ≤ Q ≤ 1000).
Q dòng tiếp theo, mỗi dòng gồm 2 số nguyên x và y.
Output:  Với mỗi truy vấn, in ra “YES” nếu có đường đi từ x tới y, in ra “NO” nếu ngược lại.
Input                 Output
1
6 5
1 2
2 3
3 4
1 4
5 6
2
1 5                  NO
2 4                  YES
*/
//Ý tưởng: duyệt dfs hoặc bfs. Nếu đỉnh cuối không có đỉnh trước đó thì không có đường đi
//Code:

#include<bits/stdc++.h>
using namespace std;

int v, e, first, last, vs[1005], previous[1005];
vector <int> a[1005];

void dfs(int u) { //hàm dfs
    vs[u] = 1; //đánh dấu đỉnh được thăm
    if (vs[last]) return;//nếu đã có đường đi thì dừng lại
    for (int i = 0; i < a[u].size (); i++) { //tìm tất cả các đỉnh chưa được thăm kề với đỉnh hiện tại
        int t = a[u][i];
        if (vs[t] == 0) {
            previous[t] = u; //cập nhật đường đi nếu tìm thấy
            dfs (t); //gọi dfs tại đỉnh đó
        }
    }
}

void init() { //hàm khởi tạo
    cin >> v >> e;
    while (e--) {
        int i, j;
        cin >> i >> j;
        a[i].push_back (j); //tạo ma trận kề
        a[j].push_back (i);
    }
}

void solve() { //hàm xử lý
    int q;
    cin >> q; //nhập vào truy vấn
    while (q--) {
        cin >> first >> last;
        for (int i = 1; i <= v; i++) {
            vs[i] = 0; //đánh dấu đỉnh chưa được thăm
            previous[i] = 0; //đánh dấu không có đỉnh trước đó
        }
        dfs (first); //duyệt dfs tại đỉnh đầu
        if (previous[last] == 0) cout << "NO";//nếu không có đỉnh trước đó là không có đường đi
        else cout << "YES";//ngược lại là có đường đi
        cout << endl;
    }
    for (int i = 1; i <= v; i++) a[i].clear (); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
123. DSA07019	HÌNH CHỮ NHẬT LỚN NHẤT
/*Cho N cột, mỗi cột có chiều cao bằng H[i]. Bạn hãy tìm hình chữ nhật lớn nhất bị che phủ bởi các cột?
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test bắt đầu bởi số nguyên N (N ≤ 100 000).
Dòng tiếp theo gồm N số nguyên H[i] (1 ≤ H[i] ≤ 10^9).
Output:
Với mỗi test, in ra diện tích hình chữ nhật lớn nhất tìm được.
Input                 Output
2
7                     12
6 2 5 4 5 1 6
3                     6
2 2 2
*/
/*Ý tưởng: đi qua tất cả các thanh từ trái sang phải, duy trì một chồng các thanh. Mỗi thanh được đẩy để xếp chồng một
lần. Một thanh được bật ra từ ngăn xếp khi một thanh có chiều cao nhỏ hơn được nhìn thấy. Khi một thanh được bật lên,
tính diện tích có thanh bật lên là thanh nhỏ nhất. Làm cách nào để chúng ta có được các chỉ mục trái và phải của thanh
bật lên - chỉ mục hiện tại cho chúng ta biết 'chỉ mục bên phải' và chỉ mục của mục trước đó trong ngăn xếp là
'chỉ mục bên trái'.*/
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, a[100005];

void init(){ //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử ý
    long long res = 0, x, y, mul;
    int i = 0; //bắt đầu duyệt từ 0
    stack <int> s; //ngắn xếp lưu các chỉ mục của hình chữ nhật hiện tại
    while (i < n) { //duyệt qua từng cột
        if (s.size () == 0 || a[s.top ()] <= a[i]) { //nếu ngăn xếp rỗng hoặc cột hiện tại không lớn hơn cột ở đỉnh của ngăn xếp
            s.push (i); //đẩy chỉ mục của cột đó vào stack
            i++; //tăng i để duyệt cột tiếp theo
        } else {
            x = s.top (); //lấy ra chỉ mục của cột ở đỉnh của ngăn xếp
            s.pop ();
            if (s.size () > 0) y = s.top (); //nếu ngăn xếp không rỗng lấy ra chỉ mục của cột ở đỉnh của ngắn xếp
            //nếu ngắn xếp rỗng thì chiều rộng chỉnh bằng chỉ mục hiện tại,  còn không thì bằng số cột từ y đến x
            mul = a[x] * (s.empty () ? i : i - y - 1);
            res = max (res, mul); //cập nhất giá trị lớn nhất
        }
    }
    //tính diện tích hình chữ nhật cuối cùng
    while (s.size () > 0) {
        x = s.top ();
        s.pop ();
        if (s.size () > 0) y = s.top ();
        mul = a[x] * (s.empty () ? i : i - y - 1);
        res = max (res, mul);
    }
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
124. DSA09005	BFS TRÊN ĐỒ THỊ VÔ HƯỚNG
/*Cho đồ thị vô hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy viết thuật toán duyệt theo chiều rộng bắt
đầu tại đỉnh uÎV (BFS(u)=?)
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào ba số |V|, |E|, uÎV tương ứng
với số đỉnh, số cạnh và đỉnh bắt đầu duyệt; Dòng tiếp theo đưa vào các bộ đôi uÎV, vÎV tương ứng với một cạnh của đồ thị.
T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤200; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra danh sách các đỉnh được duyệt theo thuật toán BFS(u) của mỗi test theo khuôn dạng của ví dụ dưới đây.
Input                                 Output
1
6 9 1                                 1 2 3 5 4 6
1 2 1 3 2 3 2 5 3 4 3 5 4 5 4 6 5 6
*/
//Ý tưởng: sử dụng thuật toán bfs được học ở môn toán rời rạc 2
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, first, vs[1005];
queue <int> q;
vector <int> a[1005];

void bfs(int u) { //hàm bfs
    q.push (u); //đẩy đỉnh đầu tiên vào hàng đợi
    vs[u] = 1; //đánh dấu đã duyệt qua đỉnh đó
    while (!q.empty ()) {
        u = q.front ();
        cout << u << " "; //in ra đỉnh được duyệt tới
        q.pop (); //xoá đỉnh đã duyệt qua khỏi hàng đợi
        for (int i = 0; i < a[u].size (); i++) { //tìm tất cả các đỉnh chưa được duyệt qua là đỉnh kề của đỉnh hiện tại
            int tmp = a[u][i];
            if (vs[tmp] == 0) {
                q.push (tmp); //đẩy đỉnh tìm thấy vào hàng đợi
                vs[tmp] = 1; //đánh dấu đã duyệt qua
            }
        }
    }
}

void init() { //hàm khởi tạo
    cin >> v >> e >> first;
    while (e--) {
        int i, j;
        cin >> i >> j;
        a[i].push_back (j); //tạo ma trận kề
        a[j].push_back (i);
    }
}

void solve() { //hàm xử lý
    for (int i = 1; i <= v; i++) vs[i] = 0; //đánh dấu tất cả các đỉnh chưa được duyệt qua
    bfs (first); //thực hiện bfs tại đỉnh first
    for (int i = 1; i <= v; i++) a[i].clear (); //làm mới ma trận kề
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
125. DSA09006	ĐƯỜNG ĐI THEO DFS VỚI ĐỒ THỊ VÔ HƯỚNG
/*Cho đồ thị vô hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy tìm đường đi từ đỉnh sÎV đến đỉnh tÎV trên
đồ thị bằng thuật toán DFS.
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào bốn số |V|, |E|, sÎV, tÎV tương
ứng với số đỉnh, số cạnh,  đỉnh u, đỉnh v; Dòng tiếp theo đưa vào các bộ đôi uÎV, vÎV tương ứng với một cạnh của đồ thị.
T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra đường đi từ đỉnh s đến đỉnh t của mỗi test theo thuật toán DFS của mỗi test theo khuôn dạng của ví dụ dưới đây.
Nếu không có đáp án, in ra -1.
Input                                Output
1
6  9 1 6                             1 2 3 4 5 6
1 2 1 3 2 3 2 5 3 4 3 5 4 5 4 6 5 6
*/
//Ý tưởng: Sử dụng thuật toán dfs để duyệt. Nếu tìm thấy đỉnh kết thúc đưa ra đường đi
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, first, last, vs[1005], previous[1005];
vector <int> a[1005];
vector <int> res;

void dfs(int u){ //hàm dfs
    if(vs[last]==1) return; //nếu đã tìm thấy đường đi thì dừng lại
    vs[u]=1; //đánh dấu đỉnh đã được thăm
    for(int i=0;i<a[u].size();i++){ //tìm đỉnh chưa được thăm kề với đỉnh hiện tại
        int tmp=a[u][i];
        if(!vs[tmp]){
            previous[tmp]=u; //cập nhật đường đi
            dfs(tmp); //gọi dfs tại đỉnh vừa tìm thấy
        }
    }
}

void init() {
    cin >> v >> e >> first >> last;
    while (e--) {
        int x, y;
        cin >> x >> y;
        a[x].push_back (y);
        a[y].push_back (x);
    }
}

void solve() {
    for (int i = 1; i <= v; i++) vs[i] = 0; //đánh dấu đỉnh chưa được thăm
    for (int i = 1; i <= v; i++) previous[i] = 0; //đánh dấu không có đỉnh trước
    dfs (first); //gọi dfs tại đỉnh đầu tiên
    if (vs[last] == 0) cout << "-1"; //nếu không có đường đi đưa ra -1
    else { //nếu có đường đi sắp xếp lại theo chiều xuôi
        res.clear ();
        while (last > 0) { //nếu không còn đỉnh trước đó thì đã duyệt hết đường đi
            res.push_back (last); //nếu tìm được đỉnh trước đó thì tìm tiếp đỉnh trước nó
            last = previous[last];
        }
        for (int i = res.size () - 1; i >= 0; i--) cout << res[i] << " "; //đưa ra kết quả
    }
    cout << endl;
    for (int i = 1; i <= v; i++) a[i].clear (); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
126. DSA09007	ĐƯỜNG ĐI THEO BFS TRÊN ĐỒ THỊ VÔ HƯỚNG
/*Cho đồ thị vô hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy tìm đường đi từ đỉnh sÎV đến đỉnh tÎV trên
đồ thị bằng thuật toán BFS.
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào bốn số |V|, |E|, sÎV, tÎV tương
ứng với số đỉnh, số cạnh,  đỉnh u, đỉnh v; Dòng tiếp theo đưa vào các bộ đôi uÎV, vÎV tương ứng với một cạnh của đồ thị.
T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra đường đi từ đỉnh s đến đỉnh t của mỗi test theo thuật toán BFS của mỗi test theo khuôn dạng của ví dụ dưới đây.
Nếu không có đáp án, in ra -1.
Input                                   Output
1
6 9 1 6                                 1 2 5 6
1 2 1 3 2 3 2 5 3 4 3 5 4 5 4 6 5 6
*/
//Ý tưởng: duyệt bfs nếu tìm thấy đỉnh cuối thì đưa ra đường đi
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, first, last, vs[1005], previous[1005];
queue <int> q;
vector <int> a[1005];

void bfs(int u) { //hàm bfs
    q.push(u); //đẩy đỉnh đầu tiên vào hàng đợi
    vs[u] = 1; //đánh dấu đỉnh đã được duyệt qua
    while (! q.empty()) {
        u = q.front();
        q.pop();
        for (int i = 0; i < a[u].size(); i ++) { //tìm các đỉnh chưa được thăm kề với đỉnh hiện tại
            int tmp = a[u][i];
            if (vs[tmp] == 0) {
                q.push(tmp); //nếu tìm thấy đẩy nó vào hàng đợi
                vs[tmp] = 1; //đánh dấu đã được thăm
                previous[tmp] = u; //cập nhật đường đi
                if (tmp == last) return; //nếu tìm thấy đỉnh cuối dừng lại
            }
        }
    }
}

void init() {
    cin >> v >> e >> first >> last;
    while (e--) {
        int i, j;
        cin >> i >> j;
        a[i].push_back (j); //tạo ma trận kề
        a[j].push_back (i);
    }
}

void solve() {
    for (int i = 1; i <= v; i++) vs[i] = 0; //đánh dấu đỉnh chưa được thăm
    for (int i = 1; i <= v; i++) previous[i] = 0; //đánh dấu không có đỉnh trước
    bfs (first); //gọi bfs tại đỉnh đầu tiên
    if (previous[last] == 0) cout << "-1"; //nếu không có đường đi đưa ra -1
    else { //nếu có đường đi sắp xếp lại theo chiều xuôi của đường đi
        vector <int> res;
        while (last > 0) { //nếu không còn đỉnh trước đó thì đã duyệt hết đường đi
            res.push_back (last); //nếu tìm được đỉnh trước đó thì tìm tiếp đỉnh trước nó
            last = previous[last];
        }
        for (int i = res.size () - 1; i >= 0; i--) cout << res[i] << " "; //đưa ra kết quả
    }
    cout << endl;
    while (!q.empty ()) q.pop (); //làm mới hàng đợi
    for (int i = 1; i <= v; i++) a[i].clear (); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
127. DSA09008	ĐẾM SỐ THÀNH PHẦN LIÊN THÔNG	
/*Cho đồ thị vô hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy tìm số thành phần liên thông của đồ thị.
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào hai số |V|, |E| tương ứng với số
đỉnh và số cạnh; Dòng tiếp theo đưa vào các bộ đôi uÎV, vÎV tương ứng với một cạnh của đồ thị.
T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra số thành phần liên thông của đồ thị.
Input                     Output
1
6 6                       2
1 2 1 3 2 3 3 4 3 5 4 5
*/
//Ý tưởng: duyệt qua các đỉnh nếu chưa được thăm thì gọi dfs hoặc bfs tại đỉnh đó, khi duyệt hết tức là đã tạo 1 tplt
//Code:

#include<bits/stdc++.h>
using namespace std;
int v, e, cnt, a[1005][1005], vs[1005];

void dfs(int u) { //hàm dfs
    vs[u] = 1; //đánh dấu đã thăm
    for (int i = 1; i <= v; i++) { //tìm tất cả các đỉnh chưa thăm kề với đỉnh hiện tại
        if (vs[i] == 0 && a[u][i] == 1) {
            vs[i] = 1;
            dfs (i); //gọi dfs tại đỉnh đó
        }
    }
}

void init() { //hàm khởi tạo
    cin >> v >> e;
    memset (a, 0, sizeof (a));
    while (e--) {
        int i, j;
        cin >> i >> j;
        a[i][j] = 1; //tạo ma trận kề
        a[j][i] = 1;
    }
}

void solve() { //hàm xử lý
    memset (vs, 0, sizeof (vs));
    cnt = 0; //khởi tạo số thành phần liên thông bằng 0
    for (int i = 1; i <= v; i++) {
        if (vs[i] == 0) {
            cnt++; //tăng số thành phần liên thông
            dfs (i); //gọi dfs tại đỉnh chưa được thăm
        }
    }
    cout << cnt << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
128. DSA09018	LIỆT KÊ ĐỈNH TRỤ
/*Cho đồ thị vô hướng liên thông G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy đưa ra tất cả các đỉnh trụ của đồ
thị?
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào hai số |V|, |E| tương ứng với số
đỉnh và số cạnh; Dòng tiếp theo đưa vào các bộ đôi uÎV, vÎV tương ứng với một cạnh của đồ thị.
T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra danh sách các đỉnh trụ của mỗi test  theo từng dòng.
Input                 Output
1
5 5                   2 3
1 2 1 3 2 3 2 5 3 4
*/
//Ý tưởng: đỉnh trụ là khi xóa u và các cạnh liên thuộc sẽ tạo ra một đồ thị mới có nhiều thành phần liên thông hơn G.
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, res, vs[1005];
vector <int> a[1005];

void reset() { //hàm làm mới
    for (int i = 1; i <= v; i++) vs[i] = 0; //đánh dấu tất cả các đỉnh chưa được thăm
    vs[res] = 1; //đánh dấu đỉnh hiện tại đã đươc thăm coi như đã xoá đỉnh hiện tại
}

void dfs(int u) { //hàm dfs
    vs[u] = 1; //đánh dấu đỉnh đã được thăm
    for (int i = 0; i < a[u].size (); i++) { //tìm tất cả các đỉnh chưa được thăm kề với đỉnh hiện tại
        int tmp = a[u][i];
        if (!vs[tmp]) dfs (tmp); //nếu tìm thấy đỉnh gọi hàm dfs tại đỉnh đó
    }
}

void init(){ //hàm khởi tạo
    cin >> v >> e;
    while (e --) {
        int i, j;
        cin >> i >> j;
        a[i].push_back(j); //tạo ma trận kề
        a[j].push_back(i);
    }
}

void solve() { //hàm xử lý
    for (res = 1; res <= v; res++) { //duyệt qua tất cả các đỉnh
        reset (); //gọi hàm làm mới
        if (res == 1) dfs (2); //nếu là đỉnh 1 thì tìm dfs tại đỉnh 2 do xoá đỉnh 1
        else dfs (1); //nếu khác 1 thì gọi tại 1
        for (int i = 1; i <= v; i++) {
            if (!vs[i]) {
                cout << res << " "; //nếu đồ thị mới không liên thông thì đỉnh nó là đỉnh trụ
                break;
            }
        }
    }
    for (int i = 1; i <= v; i++) a[i].clear (); //làm mới ma trận kề
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
129. DSA09019	KIỂM TRA CHU TRÌNH
/*Cho đồ thị vô hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy kiểm tra xem đồ thị có tồn tại chu trình hay
không?
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào hai số |V|, |E| tương ứng với số
đỉnh,  số cạnh của đồ thị; Dòng tiếp theo đưa vào các bộ đôi uÎV, vÎV tương ứng với một cạnh của đồ thị.
T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra YES hoặc “NO” kết quả test theo từng dòng tương ứng với đồ thị tồn tại hoặc không tồn tại chu trình.
Input                                  Output
1
6  9                                   YES
1 2 1 3 2 3 2 5 3 4 3 5 4 5 4 6 5 6
*/
//Ý tưởng: duyệt dfs, nếu đỉnh được thăm khác với đỉnh trước của đỉnh hiện tại thì tồn tại chu trình
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, vs[1005], check;
vector <int> a[1005];

void dfs(int u, int prev) { //hàm dfs
    if (check) return; //nếu đã tìm thấy chu trình thì dừng lại
    vs[u] = 1; //đánh dấu đã được thăm
    for (int i = 0; i < a[u].size (); i++) { //tìm tất cả các đỉnh chưa được thăm kề với đỉnh hiện tại
        int tmp = a[u][i];
        if (vs[tmp] == 0) dfs (tmp, u); //nếu tìm thấy đỉnh gọi dfs tại đó và đánh dấu u là đỉnh trước nó
        else if (tmp != prev) { //nếu tồn tại chu trình đánh dấu đã tìm thấy
            check = 1;
            return;
        }
    }
}

void init() { //hàm khởi tạo
    cin >> v >> e;
    while (e--) {
        int x, y;
        cin >> x >> y;
        a[x].push_back (y); //tạo ma trận kề
        a[y].push_back (x);
    }
}

void solve() { //hàm xử lý
    check = 0;
    for (int i = 1; i <= v; i++) {
        memset (vs, 0, sizeof (vs));
        dfs (i, 0); //gọi dfs tại đỉnh hiện tại
        if (check == 1) {
            cout << "YES" << endl; //đưa ra kết quả
            break;
        }
    }
    if (check == 0) cout << "NO" << endl;
    for (int i = 1; i <= v; i++) a[i].clear (); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
130. DSA01016	PHÂN TÍCH SỐ 1
/*Cho số nguyên dương N. Nhiệm vụ của bạn là hãy liệt kê tất cả các cách phân tích số tự nhiên N thành tổng các số tự
nhiên nhỏ hơn hoặc bằng N. Phép hoán vị vủa một cách được xem là giống nhau. Ví dụ với N = 5 ta có kết quả là: (5),
(4, 1), (3, 2), (3, 1, 1), (2, 2, 1), (2, 1, 1, 1), (1, 1, 1, 1, 1) .
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một số tự nhiên N được viết trên một dòng.
T, n thỏa mãn ràng buộc: 1≤T, N≤10.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
4                    (4) (3 1) (2 2) (2 1 1) (1 1 1 1)
5                    (5) (4 1)  (3 2)  (3 1 1) (2 2 1)  (2 1 1 1)  (1 1 1 1 1)
*/
/*Ý tưởng: duyệt từ phải qua nếu gặp số khác 1 thì giảm số đó đi 1 sau đó kiểm tra xem có thể thêm bao nhiêu số như vậy
sau nó, nếu tổng vẫn chưa bằng n thì bù thêm vào để tổng bằng n*/
//Code:

#include<bits/stdc++.h>
using namespace std;

int n ,a[10];

void init() { //hàm khởi tạo
    cin >> n;
}

void print(int k) { //hàm in
    cout << "(";
    for (int i = 0; i < k - 1; i++) cout << a[i] << " ";
    cout << a[k - 1] << ")" << " ";
}

void solve() { //hàm xử lý
    a[0] = n; //khởi tạo cấu hình đầu
    int k = 1;
    print (k); //đưa ra cấu hình đầu
    int sum = 0; //khởi tạo biến tính tổng còn lại
    for (int i = k - 1; i >= 0; i--) {
        if (a[i] != 1) { //nếu tìm được số khác 1
            a[i]--; //giảm số đó đi 1
            sum++; //cập nhật tổng còn lại
            int x = sum / a[i]; //kiểm tra xem còn có thể thêm bao nhiêu số a[i] đằng sau nó
            for (int j = i + 1; j <= i + x; j++) a[j] = a[i]; //thêm vào x số a[i]
            k = i + x + 1; //cập nhật độ rộng của cấu hình
            if (sum % a[i] != 0) { //kiểm tra xem tổng đã bằng n chưa
                a[k] = sum % a[i]; //nếu chưa bằng thì bù thêm vào để bằng n
                k++; //cập nhật độ rộng của cấu hình
            }
            print (k); //đưa ra cấu hình tiếp theo
            sum = 0; //trả lại tổng còn lại và i để sinh cấu hình kế tiếp
            i = k;
        } else sum++; //nếu tìm thấy số 1 thì tăng tổng còn lại
    }
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
131. DSA01012	MÃ GRAY 1
/*Số nhị phân được xem là cách mặc định biểu diễn các số. Tuy nhiên, trong nhiều ứng dụng của điện tử và truyền thông
lại dùng một biến thể của mã nhị phân đó là mã Gray. Mã Gray độ dài n có mã đầu tiên là n số 0, mã kế tiếp của nó
là một xâu nhị phân độ dài n khác biệt với xâu trước đó một bít. Ví dụ với n=3 ta có 23 mã Gray như sau: 000, 001,
011, 010, 110, 111, 101, 100. Hãy viết chương trình liệt kê các mã Gray có độ dài n.
Input:
Dòng đầu tiên là số lượng test T.
T dòng kế tiếp ghi lại mỗi dòng một test. Mỗi test là một số tự nhiên n.
T, n thỏa mãn ràng buộc: 1≤T, n≤10.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
3                    000 001 011 010 110 111 101 100
4                    0000 0001 0011 0010 0110 0111 0101 0100 1100 1101 1111 1110 1010 1011 1001 1000
*/
//Ý tưởng: sinh ra mã nhị phân sau đó chuyển đổi mã nhị phân đó thành mã gray theo công thức
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, a[10];

void init() {
    cin >> n;
}

void solve() {
    for (int i = 0; i < n; i++) a[i] = 0;  //khởi tạo cấu hình ban đầu
    for (int i = 0; i < n; i++) cout << a[i]; //in ra cấu hình ban đầu
    cout << " ";
    for (int i = n - 1; i >= 0; i--) { //sinh ra các mã nhị phân
        if (a[i] == 0) {
            a[i] = 1;
            for (int j = i + 1; j < n; j++) a[j] = 0;
            cout<<a[0];
            for (i = 1; i < n; i++) { //chuyển đổi mã nhị phân thành mã gray bằng công thức sau đó in
                if (a[i] + a[i - 1] == 1) cout << "1";
                else cout << "0";
            }
            cout << " ";
            i = n; //cập nhật lại i để duyệt lại từ đầu
        }
    }
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
132. DSA01017	MÃ GRAY 3
/*Số nhị phân được xem là cách mặc định biểu diễn các số. Tuy nhiên, trong nhiều ứng dụng của điện tử và truyền thông
lại dùng một biến thể của mã nhị phân đó là mã Gray. Mã Gray độ dài n có mã đầu tiên là n số 0, mã kế tiếp của nó
là một xâu nhị phân độ dài n khác biệt với xâu trước đó một bít. Ví dụ với n=3 ta có 23 mã Gray như sau: 000, 001,
011, 010, 110, 111, 101, 100. Hãy viết chương trình chuyển đổi một xâu mã nhị phân X có độ dài n thành một xâu mã
Gray.
Input:
Dòng đầu tiên là số lượng test T.
T dòng kế tiếp ghi lại mỗi dòng một test. Mỗi test là một xâu nhị phân độ dài n.
T, n thỏa mãn ràng buộc: 1≤T, n≤10.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
01001                01101
01101                01011
*/
/*Ý tưởng: bit đầu tiên của mã nhị phân cũng là của ma gray các bit i còn lại được tính bằng cách lấy tổng 
không nhớ của bit i và i+1 của mã nhị phân*/
//Code:

#include<bits/stdc++.h>
using namespace std;

string str;

void init() { //hàm khởi tạo
    cin >> str;
}

void solve() { //hàm xử lý
    cout << str[0]; //bit đầu tiên của mã nhị phân cũng là của ma gray
    //các bit i còn lại được tính bằng cách lấy tổng không nhớ của bit i và i+1 của mã nhị phân
    for (int i = 0; i < str.length () - 1; i++) {
        if ((str[i] - 48) + (str[i + 1] - 48) == 1) cout << "1";
        else cout << "0";
    }
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
133. DSA01013	MÃ GRAY 2  
/*Số nhị phân được xem là cách mặc định biểu diễn các số. Tuy nhiên, trong nhiều ứng dụng của điện tử và truyền thông
lại dùng một biến thể của mã nhị phân đó là mã Gray. Mã Gray độ dài n có mã đầu tiên là n số 0, mã kế tiếp của nó
là một xâu nhị phân độ dài n khác biệt với xâu trước đó một bít. Ví dụ với n=3 ta có 23 mã Gray như sau: 000, 001,
011, 010, 110, 111, 101, 100. Hãy viết chương trình chuyển đổi một xâu mã Gray X có độ dài n thành một xâu mã nhị
phân.
Input::
Dòng đầu tiên là số lượng test T.
T dòng kế tiếp ghi lại mỗi dòng một test. Mỗi test là một xâu mã Gray độ dài n.
T, n thỏa mãn ràng buộc: 1≤T, n≤10.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
01101                01001
01011                01101
*/
/*Ý tưởng: bit đầu tiên của mã nhị phân cũng là bit đầu tiên của mã gray,các bit i còn lại là tổng không nhớ giữa bit
i-1 của mã gray và bit i của mã nhị phân*/
//Code:

#include<bits/stdc++.h>
using namespace std;

string str;

void init() { //hàm khởi tạo
    cin >> str;
}

void solve() { //hàm xử lý
    vector <int> res; //tạo vector kết quả
    res.push_back (str[0] - 48); //bit đầu tiên của mã nhị phân cũng là bit đầu tiên của mã gray
    //các bit i còn lại là tổng không nhớ giữa bit i-1 của mã gray và bit i của mã nhị phân
    for (int i = 1; i < str.length (); i++) {
        if (res[i - 1] + (str[i] - 48) == 1) res.push_back (1);
        else res.push_back (0);
    }
    for (int i = 0; i < res.size (); i++) cout << res[i];  //in ra kết quả
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
134. DSA01009	XÂU AB ĐẶC BIỆT
/*Một xâu kí tự S = (s1, s2, .., sn) được gọi là xâu AB độ dài n nếu với mọi siÎS thì si hoặc là kí tự A hoặc si là
kí tự B . Ví dụ xâu S = “ABABABAB” là một xâu AB độ dài 8. Cho số tự nhiên N và số tự nhiên K (1£K<N£15 được nhập từ bàn
phím), hãy viết chương trình liệt kê tất cả các xâu AB có độ dài N chứa duy nhất một dãy K kí tự A liên tiếp.
Dữ liệu vào chỉ có một dòng ghi hai số N và K.
Kết quả ghi ra màn hình theo khuôn dạng:
Dòng đầu tiên ghi lại số các xâu AB thỏa mãn yêu cầu bài toán;
Những dòng kế tiếp, mỗi dòng ghi lại một xâu AB thỏa mãn. Các xâu được ghi ra theo thứ tự từ điển.
INPUT                OUTPUT
5 3                  5
                     AAABA
                     AAABB
                     ABAAA
                     BAAAB
                     BBAAA
*/
//Ý tưởng: sinh ra tất cả các xâu, sau đó kiểm tra xem có thoả mãn không
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, k, res, a[15];
vector <int> b;


void init() { //hàm khởi tạo
    cin >> n >> k;
    for (int i = 0; i < n; i++) a[i] = 0; //khởi tạo cấu hình đầu tiên
}

void print() { //hàm in
    cout << res << endl; //in ra kết quả
    for (int i = 0; i < b.size (); i++) {
        if (b[i] == 0) cout << "A";
        else cout << "B";
        if (i % n == n - 1) cout << endl; //nếu in xong 1 cặp thì xuống dòng
    }
}

void solve(int dem, int cnt) { //hàm xử lý
    res = 0;
    for (int i = n - 1; i >= 0; i--) { //sinh xâu nhị phân kế tiếp
        if (a[i] == 0) {
            a[i] = 1;
            for (int j = i + 1; j < n; j++) a[j] = 0;

            for (int j = 0; j < n; j++) {
                if (a[j] == 0) dem++; //đếm số cặp có A kí tự A liền nhau
                else {
                    if (dem == k) cnt++;
                    if (cnt > 1) break;
                    dem = 0;
                }
            }
            if (dem == k) cnt++;
            if (cnt == 1) {  //nếu số cặp đúng bằng 1 thì cập nhật kết quả và chuyển các phần tử vào vector b
                for (int j = 0; j < n; j++) b.push_back (a[j]);
                res++;
            }
            dem = 0, cnt = 0, i = n; //gán lại các giá trị để bắt đầu vòng lặp tiếp để tìm các xâu nhị phân tiếp theo
        }
    }
}

int main() {
    init ();
    solve (0, 0);
    print ();
    return 0;
}
135. DSA01010	TẬP QUÂN SỰ
/*Tại Chương Mỹ Resort, vào nửa đêm, cả trung đội nhận lệnh tập trung ở sân. Mỗi chiến sỹ được đánh số từ 1 đến N
(1<N<40). Giám thị yêu cầu chọn ra một dãy K chiến sỹ để tập đội ngũ và cứ lần lượt duyệt hết tất cả các khả năng chọn K
người như vậy từ nhỏ đến lớn (theo số thứ tự). Bài toán đặt ra là cho một nhóm K chiến sỹ hiện đang phải tập đội ngũ,
hãy tính xem trong lượt chọn K người tiếp theo thì mấy người trong nhóm cũ sẽ được tạm nghỉ. Nếu đã là nhóm cuối cùng
thì tất cả đều sẽ được nghỉ.
Dữ liệu vào: Dòng đầu ghi số bộ test, không quá 20. Mỗi bộ test viết trên hai dòng
Dòng 1: hai số nguyên dương N và K (K<N)
Dòng 2 ghi K số thứ tự của các chiến sỹ đang phải tập đội ngũ (viết từ nhỏ đến lớn)
Kết quả: Với mỗi bộ dữ liệu in ra số lượng chiến sỹ được tạm nghỉ.
Input                Output
3
5 3                  1
1 3 5
5 3                  2
1 4 5
6 4                  4
3 4 5 6
*/
//Ý tưởng: sinh ra tổ hợp kế tiếp sau đó đếm xem có mấy giá trị được thay đổi
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, k, cnt, a[40], used[40];

void init() { //hàm khởi tạo
    cin >> n >> k;
    for (int i = 1; i <= k; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    memset (used, 0, sizeof (used));
    cnt = 0;
    for (int i = k; i > 0; i--) { //sinh ra tổ hợp kế tiếp
        if (a[i] != n - k + i) {
            a[i]++;
            if(!used[a[i]]) cnt++; //tăng số người được nghỉ
            for (int j = i + 1; j <= k; j++) {
                a[j] = a[i] + j - i;
                if (!used[a[j]]) cnt++; //tăng số người được nghỉ
            }
            break;
        } else used[a[i]] = 1;
    }
    if (!cnt) cout << k << endl; //nếu là cấu hình cuối cùng thì tất cả đều được nghỉ
    else cout << cnt << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
136. DSA01011	HOÁN VỊ TIẾP THEO CỦA CHUỖI SỐ	
/*Hãy viết chương trình nhận vào một chuỗi (có thể khá dài) các ký tự số và đưa ra màn hình hoán vị kế tiếp của các ký
tự số đó (với ý nghĩa là hoán vị có giá trị lớn hơn tiếp theo nếu ta coi chuỗi đó là một giá trị số nguyên). Chú ý: Các
ký tự số trong dãy có thể trùng nhau.
Ví dụ:               123 -> 132
279134399742 -> 279134423799
Cũng có trường hợp sẽ không thể có hoán vị kế tiếp. Ví dụ như khi đầu vào là chuỗi 987.
Dữ liệu vào: Dòng đầu tiên ghi số nguyên  t là số bộ test (1 ≤ t ≤ 1000).  Mỗi bộ test có một dòng, đầu tiên là số thứ
tự bộ test, một dấu cách, sau đó là chuỗi các ký tự số, tối đa 80 phần tử.
Kết quả: Với mỗi bộ test hãy đưa ra một dòng gồm thứ tự bộ test, một dấu cách, tiếp theo đó là hoán vị kế tiếp hoặc
chuỗi “BIGGEST” nếu không có hoán vị kế tiếp.
Input                Output
3
1 123                1 132
2 279134399742       2 279134423799
3 987                3 BIGGEST
*/
//Ý tưởng: Sinh ra hoán vị kế tiếp của dãy số
//Code:

#include<bits/stdc++.h>
using namespace std;

int n;
string str;

void init() { //hàm khởi tạo
    cin >> n;
    cin >> str;
}

void solve() { //hàm xử lý
    cout << n << " ";
    int check = 1;
    for (int i = str.length () - 1; i > 0; i--) { //sinh hoán vị kế tiếp
        if (str[i - 1] < str[i]) {
            for (int j = str.length () - 1; j >= i; j--) {
                if (str[j] > str[i - 1]) {
                    swap (str[j], str[i - 1]);
                    break;
                }
            }
            int l = i, r = str.length () - 1;
            while (l < r) {
                swap (str[l], str[r]);
                l++;
                r--;
            }
            for (int i = 0; i < str.length (); i++) cout << str[i]; //đưa ra kết quả
            cout << endl;
            check = 0; //đánh dấu đã tìm được hoán vị kế tiếp
            break;
        }
    }
    if (check == 1) cout << "BIGGEST" << endl; //không tìm được hoán vị kế tiếp
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
137. DSA02008	CHỌN SỐ TỪ MA TRẬN VUÔNG CẤP N
/*Cho ma trận vuông Ci,j cấp N (1<= i, j <= N<=10) gồm N^2 số tự nhiên và số tự nhiên K (các số trong ma trận không nhất
thiết phải khác nhau và đều không quá 100, K không quá 10^4). Hãy viết chương trình lấy mỗi hàng, mỗi cột duy nhất một
phần tử sao cho tổng các phần tử này đúng bằng K.
Dữ liệu vào: Dòng 1 ghi hai số N và K. N dòng tiếp theo ghi ma trận C.
Kết quả: dòng đầu ghi số cách tìm được. Mỗi dòng tiếp theo ghi một cách theo vị trí của số đó trong lần lượt từng hàng
của ma trận. Xem ví dụ để hiểu rõ hơn.
INPUT                               OUTPUT
3 10
2 4 3                               2
1 3 6                               1 3 2
4 2 4                               3 2 1
*/
//Ý tưởng: sinh ra các hoán vị của n sau đó kiểm tra tại vị trí tương ứng của ma trận nếu tổng bằng k thì đua ra kết quả
#include<bits/stdc++.h>
using namespace std;
int n, k, s=0, a[20][20], b[20];
bool used[20]={0};
vector<int>res;

void Try(int pos) { //hàm quay lui
    for (int i = 1; i <= n; i++) {
        if (used[i] == 0) {
            b[pos] = i;
            used[i] = 1;
            //khi tìm được 1 cấu hình sẽ kiểm tra xem tổng của các vị trí trên ma trận có bằng k không
            if (pos == n) {
                s = 0;
                for (int j = 1; j <= n; j++) s += a[j][b[j]];
                if (s == k)
                    for (int j = 1; j <= n; j++) res.push_back (b[j]);
            } else Try (pos + 1);
            used[i] = 0;
        }
    }
}

void init() {
    cin >> n >> k;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++) cin >> a[i][j];
}

void solve() {
    Try (1);
    cout << res.size () / n;  //in ra số cặp
    for (int i = 0; i < res.size (); i++) {  //in ra kết quả
        if (i % n == 0) cout << endl;
        cout << res[i] << " ";
    }
}

int main() {
    init ();
    solve ();
    return 0;
}
138. DSA01015	TÌM BỘI SỐ
/*Cho số nguyên N. Nhiệm vụ của bạn cần tìm số nguyên X nhỏ nhất là bội của N, và X chỉ chứa hai chữ số 0 và 9.
Input: Dòng đầu tiên là số lượng bộ test T (T ≤ 10000). Mỗi bộ test chứa số nguyên N trên một dòng (1 ≤ N ≤ 500).
Output:  Với mỗi test in ra đáp án tìm được trên một dòng.
Input                Output
3
2                    90
5                    90
11                   99
*/
//ý tưởng: sinh ra số tiếp theo nếu là bội số thì đưa ra kết quả
//Code:

#include<bits/stdc++.h>
using namespace std;

int n;
vector<long long>b;

void init() { //hàm khởi tạo
    cin >> n;
}

void solve() { //hàm xử lý
    //sinh ra các số tiếp theo sử dụng thuật toán sinh xâu nhị phân kế tiếp
    int a[18] = {0};
    for (int i = 17; i >= 0; i--) {
        if (a[i] == 0) {
            a[i] = 9;
            for (int j = i + 1; j < 18; j++) a[j] = 0;
            long long x = 0;
            for (int j = 0; j < 18; j++) x = x * 10 + a[j];
            b.push_back (x);
            i = 18;
        }
    }
}

void print() { //hàm đưa ra kết quả
    for (int i = 0; i < b.size (); i++) {
        if (b[i] % n == 0) {
            cout << b[i] << endl;
            break;
        }
    }
}

int main() {
    int t;
    cin >> t;
    solve ();
    while (t--) {
        init ();
        print ();
    }
    return 0;
}
139. DSA02004	DI CHUYỂN TRONG MÊ CUNG 2
/*Cho một mê cung bao gồm các khối được biểu diễn như một ma trận nhị phân A[N][N]. Một con chuột đi từ ô đầu tiên góc
trái (A[0][0]) đến ô cuối cùng góc phải (A[N-1][N-1]) theo nguyên tắc:
Down (D): Chuột được phép xuống dưới nếu ô dưới nó có giá trị 1.
Right (R): Chuột được phép sang phải dưới nếu ô bên phải nó có giá trị 1.
Left (L): Chuột được phép sang trái dưới nếu ô bên trái nó có giá trị 1.
Up (U): Chuột được phép lên trên nếu ô trên nó có giá trị 1.
Hãy đưa ra tất cả các hành trình của con chuột trên mê cung. Đưa ra -1 nếu chuột không thể đi đến đích.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất đưa vào số N là kích cỡ của mê cung;
dòng tiếp theo đưa vào ma trận nhị phân A[N][N].
T, N, A[i][j] thỏa mãn ràng buộc: 1≤T ≤10; 2≤N≤8; 0≤A[i][j] ≤1.
Output:
Đưa ra các xâu ký tự được sắp xếp, trong đó mỗi xâu là một đường đi của con chuột trong mê cung. In ra đáp án theo thứ
tự từ điển. Đưa ra -1 nếu chuột không đi được đến đích.
Input                                   Output
3
4
1 0 0 0                                 DRDDRR
1 1 0 1
0 1 0 0
0 1 1 1
4
1 0 0 0                                 DDRDRR DRDDRR
1 1 0 1
1 1 0 0
0 1 1 1
5
1 0 0 0 0                               DDRRURRDDD DDRURRRDDD DRDRURRDDD DRRRRDDD
1 1 1 1 1
1 1 1 0 1
0 0 0 0 1
0 0 0 0 1
*/
//Ý tưởng: tìm kiếm tại 4 hướng sử dụng mảng đánh dấu đã thăm
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, a[100][100], used[100][100];
vector <string> res;

void Try(int i, int j, string str) { //hàm quay lui
    if (i == n - 1 && j == n - 1) {
        res.push_back (str); //nếu đã đến đích thì thêm đường đi vào kết quả
        return;
    }
    if (i < n - 1 && a[i + 1][j] == 1 && used[i + 1][j] == 0) { //nếu bên dưới có lối đi và chưa đi qua thì đi xuống
        used[i][j] = 1;
        Try (i + 1, j, str + "D"); //thêm D vào chuỗi lối đi
        used[i][j] = 0;  //trả lại khi chưa đi qua
    }
    if (j < n - 1 && a[i][j + 1] == 1 && used[i][j + 1] == 0) { //nếu bên phải có lối đi và chưa đi qua thì đi sang
        used[i][j] = 1;
        Try (i, j + 1, str + "R"); //thêm R vào chuỗi lối đi
        used[i][j] = 0; //trả lại khi chưa đi qua
    }
    if (j > 0 && a[i][j - 1] == 1 && used[i][j - 1] == 0) { //nếu bên trái có lối đi và chưa đi qua thì đi sang
        used[i][j] = 1;
        Try (i, j - 1, str + "L"); //thêm L vào chuỗi lối đi
        used[i][j] = 0; //trả lại khi chưa đi qua
    }
    if (i > 0 && a[i - 1][j] == 1 && used[i - 1][j] == 0) {  //nếu bên trên có lối đi và chưa đi qua thì đi lên
        used[i][j] = 1;
        Try (i - 1, j, str + "U"); //thêm U vào chuỗi lối đi
        used[i][j] = 0;  //trả lại khi chưa đi qua
    }
}

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++) {
            cin >> a[i][j];
            used[i][j] = 0;
        }
}

void solve() { //hàm xử lý
    res.clear ();   //làm trống vector kết quả
    if (a[0][0] == 0 || a[n - 1][n - 1] == 0) cout << -1; //không tồn tại đường đi
    else {
        Try (0, 0, "");
        if (res.size () == 0) cout << -1; //không tồn tại đường đi
        else {
            sort (res.begin (), res.end ());
            for (int i = 0; i < res.size (); i++) cout << res[i] << " "; //đưa ra kết quả
        }
    }
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
140. DSA02007	ĐỔI CHỖ CÁC CHỮ SỐ
/*Cho số tự nhiên K và xâu ký tự các chữ số S.  Nhiệm vụ của bạn là đưa ra số lớn nhất bằng cách thực hiện nhiều nhất K
lần đổi chỗ các ký tự trong S. Ví dụ K =3 và S = “1234567” ta được “7654321”.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất là số K; dòng tiếp theo là xâu ký tự S.
T, K, S thỏa mãn ràng buộc: 1≤T ≤100; 1≤K≤10; 1≤.lenght(S)≤7.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
3
4
1234567               7654321
3
3435335               5543333
2
1034                  4301
*/
//Ý tưởng: thứ tự đổi chỗ là từ phần tử đầu tiên, duyệt từ cuối về nếu tìm được phần tủ lớn hơn ta thực hiện đổi chỗ
//Code: 

#include <bits/stdc++.h>
using namespace std;

int k;
string str;

void init() {
    cin >> k;
    cin >> str;
}

void solve() {
    for (int i = 0; i < str.length (); i++) { //bắt đầu đổi chỗ từ phần tử đầu
        //khởi tạo giá trị và vị trí lớn nhất hiện tại là phần tử cuối cùng
        int max = str[str.length () - 1], pos = str.length () - 1;
        for (int j = str.length () - 1; j > i; j--) {
            if (str[j] > max) {  //tìm được giá trị lớn hơn thì cập nhật giá trị và vị trí
                max = str[j];
                pos = j;
            }
        }
        //nếu giá trị đó lớn hơn giá trị đang chờ đổi chỗ và k > 0 thì thực hiện đổi chỗ và giảm k
        if (max > str[i] && k > 0) {
            swap (str[i], str[pos]);
            k--;
        }
    }
    cout << str << endl;
}

int main () {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
141. DSA02013	SỐ NGUYÊN TỐ
/*Cho ba số N, P, S. Trong đó, P là một số nguyên tố. Nhiệm vụ của bạn là đưa ra tất cả N số nguyên tố tính từ P có tổng
bằng S. Ví dụ với S = 28, P=7, N =2 ta có kết quả 11 + 17 = 28. Với N = 3, P = 2, S = 23 ta có kết quả : {3, 7, 13},
{5, 7, 11}
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là bộ ba số S, P, N được viết trên một dòng.
S, P, N thỏa mãn ràng buộc: 1≤T ≤100; 1 ≤ N ≤ 10; 2≤S, P≤200.
Output:
Với mỗi test, dòng đầu tiên in ra số lượng đáp án tìm được. Mỗi dòng tiếp theo in ra kết quả tìm được theo thứ tự từ điển
Input                Output
2
2  7  28             1
                     11 17
3  2  23             2
                     3 7 13
                     5 7 11
*/
//Ý tưởng: tạo mảng các số nguyên tố, sau đó thực hiện quay lui với 1 là sử dụng và 0 là không sử dụng
//Code:

#include<bits/stdc++.h>
using namespace std;

vector <int> prime;
int n, p, s, cnt;
vector <int> res;

bool isPrime(int x) { //hàm kiểm tra số nguyên tố
    for (int i = 2; i <= sqrt (x); i++)
        if (x % i == 0) return false;
    return true;
}

void Try(int i, int dem, int sum, vector <int> b) { //hàm quay lui
    if (prime[i] > p) {
        for (int j = 1; j >= 0; j--) {
            if (j == 1) { //nếu sử dụng
                sum += prime[i]; //tăng tổng
                dem++; //tăng số các số sử dụng
                b.push_back (prime[i]); //cập nhật mảng lưu trữ các số
                if (sum == s && dem == n) { //nếu thoả mãn
                    cnt++; //tăng số cặp
                    for (int h = 0; h < b.size (); h++) res.push_back (b[h]); //cập nhật kết quả
                    return;
                } else if (sum < s) { //nếu chưa tìm xong
                    if (i + 1 < prime.size ()) Try (i + 1, dem, sum, b); //gọi lại hàm quay lui
                } else return; //nếu không thoả mãn dừng lại
                sum -= prime[i]; //trả lại giá trị trước đó để duyệt trường hợp không sử dụng
                dem--; //
                b.pop_back ();
            } else Try (i + 1, dem, sum, b); //gọi hàm quay lui tiếp
        }
    } else Try (i + 1, dem, sum, b); //duyệt số tiếp theo
}

void init() { //hàm khởi tạo
    cin >> n >> p >> s;
}

void makePrime() { //hàm tạo số nguyên tố
    for (int i = 2; i <= 200; i++)
        if (isPrime (i)) prime.push_back (i);
}

void solve() { //hàm xử lý
    cnt = 0;
    vector <int> b;
    res.clear (); //làm mới kết quả
    Try (0, 0, 0, b); //gọi hàm quay lui
    cout << cnt << endl;
    for (int i = 0; i < res.size (); i++) { //đưa ra kết quả
        if (i % n != n - 1) cout << res[i] << " ";
        else {
            cout << res[i] << endl;
        }
    }
}

int main() {
    int t;
    cin >> t;
    makePrime ();
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
142. DSA02017	SẮP XẾP QUÂN HẬU 2
/*Cho một bàn cờ 8 x 8, mỗi ô có một giá trị A[i][j] nhất định (0 ≤ A[i][j] ≤ 100), tương ứng với điểm số đạt được nếu
như bạn đặt một quân cờ vào đó.
Nhiệm vụ của bạn là đặt 8 quân hậu lên bàn cờ, sao cho không có 2 quân nào ăn nhau, và số điểm đạt được là lớn nhất.
Input: Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test gồm 8 dòng, mỗi dòng 8 số nguyên mô tả bàn cờ.
Output:  Với mỗi test, in ra đáp án trên một dòng
Input                    Output
1
1 2 3 4 5 6 7 8          260
9 10 11 12 13 14 15 16
17 18 19 20 21 22 23 24
25 26 27 28 29 30 31 32
33 34 35 36 37 38 39 40
41 42 43 44 45 46 47 48
48 50 51 52 53 54 55 56
57 58 59 60 61 62 63 64
*/
//Ý tưởng: giống sắp xếp quân hậu 1 thêm bước tính điểm
//Code:

#include<bits/stdc++.h>
using namespace std;

int res, a[20], p[20][20];

void init() { //hàm khởi tạo
    for(int i=1;i<=8;i++)
        for(int j=1;j<=8;j++)
            cin>>p[i][j];
}

bool check(int x,int y) { //hàm kiểm tra đặt quân hậu có bị ăn không
    for (int i = 1; i < x; i++)
        if (a[i] == y || abs (i - x) == abs (a[i] - y)) //công thức kiểm tra, nên vẽ hình để nhìn
            return false;
    return true;
}

void Try(int i) { //hàm quay lui
    for (int j = 1; j <= 8; j++) {
        if (check (i, j)) { //nếu đặt được quân hậu
            a[i] = j; //thực hiện đặt quân hậu
            if (i == 8) {
                int point = 0;
                for (int x = 1; x <= 8; x++) point += p[x][a[x]];
                res = max (res, point);
            } else Try (i + 1); //nếu chưa đặt đủ n quân hậu gọi hàm đệ quy
        }
    }
}

void solve() {
    res=0;
    Try (1); //gọi hàm quay lui
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
143. DSA01014	TẬP HỢP
/*Xét tất cả các tập hợp các số nguyên dương có các phần tử khác nhau và không lớn hơn số n cho trước. Nhiệm vụ của bạn
là hãy đếm xem có tất cả bao nhiêu tập hợp có số lượng phần tử bằng k và tổng của tất cả các phần tử trong tập hợp bằng
s? Các tập hợp là hoán vị của nhau chỉ được tính là một.
Ví dụ với n = 9, k = 3, s = 23, {6, 8, 9} là tập hợp duy nhất thỏa mãn.
Input:  Gồm nhiều bộ test (không quá 100 test).
Mỗi bộ test gồm 3 số nguyên n, k, s với 1 ≤ n ≤ 20, 1 ≤ k ≤ 10 và 1 ≤ s ≤ 155. Input kết thúc bởi 3 số 0.
Output:  Với mỗi test in ra số lượng các tập hợp thỏa mãn điều kiện đề bài.
Input                 Output
9 3 23                1
9 3 22                2
10 3 28               0
16 10 107             20
20 8 102              1542
20 10 105             5448
20 10 155             1
3 4 3                 0
4 2 11                0
0 0 0
*/
//Ý tưởng: tìm số tổ hợp chập k của n có tổng bằng s
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, k, s, cnt, a[25];
int main() {
    while (1) {
        cin >> n >> k >> s;
        if (n == 0 && k == 0 && s == 0) break;
        if (n < k) cout << "0" << endl; //không tồn tại n<k
        else {
            cnt = 0; //khởi tạo biến đếm bằng 0
            int sum = 0;
            for (int i = 1; i <= k; i++) { //khởi tạo tổ hợp đầu tiên
                a[i] = i;
                sum += i; //tính tổng của tổ hợp đó
            }
            if (sum == s) cout << "1" << endl; //nếu tổng bằng s thì chỉ có 1 tổ hợp thoả mãn
            else {
                while (1) {
                    int i = k;
                    sum = 0;
                    while (i > 0 && a[i] == n - k + i) i--; //sinh ra tổ hợp kế tiếp
                    if (i > 0) {
                        a[i]++;
                        for (int j = i + 1; j <= k; j++) a[j] = a[i] + j - i;
                        for (int j = 1; j <= k; j++) sum += a[j];
                        if (sum == s) cnt++; //tăng số trường hợp thoả mãn
                    } else break;
                }
                cout << cnt << endl; //đưa ra kết quả
            }
        }
    }
    return 0;
}
144. DSA03007	GIÁ TRỊ NHỎ NHẤT CỦA BIỂU THỨC	
/*Cho mảng A[], B[] đều có N phần tử. Nhiệm vụ của bạn là tìm giá trị nhỏ nhất của  biểu thức P = A[0]*B[0] + A[1]*B[1]
+ ..+A[N-1]*B[N-1] bằng cách tráo đổi vị trí các phần tử của cả mảng A[] và B[].
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 3 dòng: dòng thứ nhất đưa vào số phần tử của mảng N; dòng tiếp
theo đưa vào N số A[i]; dòng cuối cùng đưa vào N số B[i] các số được viết cách nhau một vài khoảng trống.
T, N, A[i], B[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤ N ≤107; 0≤A[i], B[i] ≤1018.
Output:
Đưa ra kết quả mỗi test theo từng dòng
Input                Output
2
7                    45
1 6 3 4 5 2 7
1 1 1 2 3 4 3
7                    27
1 6 3 5 5 2 2
0 1 9 0 1 2 3
*/
//Ý tưởng: sắp xếp lại 2 mảng rồi nhân tương ứng
//Code:

#include<bits/stdc++.h>
using namespace std;

int n;
long long a[1000005],b[1000005];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
    for (int i = 0; i < n; i++) cin >> b[i];
}

void solve() { //hàm xử lý
    sort (a, a + n); //sắp xếp lại 2 mạng
    sort (b, b + n);
    long long res = 0; //khởi tạo kết quả
    for (long i = 0; i < n; i++) res += a[i] * b[n - i - 1]; //cập nhật kết quả
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
145. DSA03008	SẮP XẾP CÔNG VIỆC 1
/*Cho hệ gồm N hành động. Mỗi hành động được biểu diễn như một bộ đôi <Si, Fi> tương ứng với thời gian bắt đầu và thời
gian kết thúc của mỗi hành động. Hãy tìm phương án thực hiện nhiều nhất các hành động được thực hiện bởi một máy hoặc
một người sao cho hệ không xảy ra mâu thuẫn.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 3 dòng: dòng thứ nhất đưa vào số lượng hành động N; dòng tiếp
theo đưa vào N số Si tương ứng với thời gian bắt đầu mỗi hành động; dòng cuối cùng đưa vào N số Fi tương ứng với thời
gian kết thúc mỗi hành động; các số được viết cách nhau một vài khoảng trống.
T, N, Si, Fi thỏa mãn ràng buộc: 1≤T≤100;  1≤N, Fi, Si≤1000.
Output:
Đưa số lượng lớn nhất các hành động có thể được thực thi bởi một máy hoặc một người.
Input                Output
1
6                    4
1  3  0  5  8  5
2  4  6  7  9  9
*/
//Ý tưởng: sắp xếp tăng dần theo thời gian kết thúc sau đó đếm số công việc lớn nhất có thể
//Code:

#include<bits/stdc++.h>
using namespace std;

struct data{ //kiểu dữ liệu struct chứa 2 phần tử bắt đầu và kết thúc của mỗi công việc
    int si,fi;
};

int cmp(data x, data y) { //hàm so sánh 2 giá trị
    if (x.fi < y.fi) return 1;
    return 0;
}

int n, res;
data a[1005];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i].si;
    for (int i = 0; i < n; i++) cin >> a[i].fi;
}

void solve() { //hàm xử lý
    sort (a, a + n, cmp); //sắp xếp tăng dần theo thời gian kết thúc
    res = 1;
    int k = 0;
    for (int i = 1; i < n; i++) { //đếm số công việc có thể
        if (a[i].si >= a[k].fi) { //nếu thòi gian bắt đầu lớn hơn hoặc bằng thời gian kết thúc thì tăng số công việc
            res++;
            k = i;
        }
    }
    cout << res << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
146. DSA03009	SẮP XẾP CÔNG VIỆC 2
/*Cho N công việc. Mỗi công việc được biểu diễn như một bộ 3 số nguyên dương <JobId, Deadline, Profit>, trong đó JobId
là mã của việc, Deadline là thời gian kết thúc của việc, Profit là lợi nhuận đem lại nếu hoàn thành việc đó đúng thời
gian. Thời gian để hoàn toàn mỗi công việc là 1 đơn vị thời gian. Hãy cho biết lợi nhuận lớn nhất có thể thực hiện các
việc với giả thiết mỗi việc được thực hiện đơn lẻ.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất là số lượng Job N; phần thứ hai đưa vào
3×N số tương ứng với N job.
T, N, JobId, Deadline, Profit thỏa mãn ràng buộc:1≤T≤100;  1≤N≤1000; 1≤ JobId ≤1000; 1≤ Deadline ≤1000;1≤ Profit ≤1000.
Output:
Đưa số lượng công việc tương ứng và lợi nhuận lớn nhất có thể đạt được.
Input                Output
2
4                    2 60
1 4 20
2 1 10
3 1 40
4 1 30
5                    2 127
1 2 100
2 1 19
3 2 27
4 1 25
5 1 15
*/
//Code:

#include<bits/stdc++.h>
using namespace std;

int main() {
    int t;
    cin >> t;
    while (t--) {
        int a[1001];
        int b[1001];
        int n;
        cin >> n;
        //khai báo dealine tối đa và số công việc tối đa thực hiện được
        int max = 0, count = 0;
        for (int i = 0; i < n; i++) {
            int j;
            cin >> j >> a[i] >> b[i];
            //tìm dealine tối đa
            if (a[i] > max) max = a[i];
        }
        //sắp xếp theo thứ tự số lợi nhuận đạt được
        for (int i = 0; i < n - 1; i++) {
            for (int j = i + 1; j < n; j++) {
                if (b[i] > b[j]) {
                    swap (b[i], b[j]);
                    swap (a[i], a[j]);
                }
            }
        }
        long res = 0;
        //mảng kiểm tra thời gian đó đã làm công việc nào chưa
        bool used[1001] = {false};
        for (int i = n - 1; i >= 0; i--) {
            //nếu dealine tối đa còn lại nhỏ hơn 1 thì dừng vòng lặp
            if (max <= 0) break;
            /*
            nếu dealine lớn hơn dealine tối đa thì kiểm tra nếu tại thời gian tối đa đã làm 1 công việc thì tiếp tục trừ
            đến khi có thời gian chưa làm
            nếu dealine nhỏ hơn dealine tối đa thì kiểm tra xem tại thời gian của dealine đã làm 1 công việc thì tiếp
            tục trừ đến khi có thời gian chưa làm
            */
            if (a[i] >= max) {
                while (used[max] == true) max--;
                /*
                nếu dealine tối đa lớn hơn 0 thì ghi nhận công việc tăng lợi nhuận, đánh dấu thời gian đó đã được làm
                sau đó giảm dealine tối đa xuống 1 và tăng số công việc đã làm lên 1
                */
                if (max > 0) {
                    res += b[i];
                    used[max] = true;
                    count++;
                    max--;
                }
            } else if (a[i] < max) {
                int x = a[i];
                while (used[x] == true) x--;
                /*
                nếu dealine lớn hơn 0 thì ghi nhận công việc tăng lợi nhuận, đánh dấu thời gian đó đã được làm và tăng
                số công việc đã làm lên 1
                */
                if (x > 0) {
                    res += b[i];
                    used[x] = true;
                    count++;
                }
            }
        }
        //in ra kết quả
        cout << count << " " << res << "\n";
    }
    return 0;
}
147. DSA03011	NỐI DÂY 2
/*Cho N sợi dây với độ dài khác nhau được lưu trong mảng A[]. Nhiệm vụ của bạn là nối N sợi dây thành một sợi sao cho
tổng chi phí nối dây là nhỏ nhất. Biết chi phí nối sợi dây thứ i và sợi dây thứ j là tổng độ dài hai sợi dây A[i] và
A[j]. Dữ liệu vào
Dòng đầu ghi số bộ test T (T<10). Mỗi bộ test gồm 2 dòng. Dòng đầu tiên là số nguyên N (N ≤ 2*106).
Dòng tiếp theo gồm N số nguyên dương c[i] ( 1 ≤ A[i] ≤ 109).
Kết quả
In ra đáp án của bộ test trên từng dòng, theo modulo 109+7.
Input                 Output
7                     59
2 4 1 2 10 2 3
*/
//Ý tưởng: Ghép 2 sợi dây có chi phí nhỏ nhất trong các sợi dây còn lại sử dụng hàng đợi ưu tiên
//Code:

#include <bits/stdc++.h>
using namespace std;

long n, res, m=1e9+7;
priority_queue<long, vector<long>, greater<long> >q;

void init() { //hàm khởi tạo
    cin >> n;
    long tmp;
    for (long i = 0; i < n; i++) {
        cin >> tmp;
        q.push (tmp); //đưa phần tử vào queue
    }
}

void solve() { //hàm xử lý
    res = 0; //khởi tạo res=0
    while (q.size () > 1) { //nếu q có nhiều hơn 1 phần tử tức là vẫn có thể nối
        long x = q.top (); //lấy phần tử ở đỉnh của queue
        q.pop (); //xoá phần tử đó
        long y = q.top (); //lấy phần tử ở đỉnh của queue
        q.pop (); //xoá phần tử đó
        long long z = x + y; //cộng 2 phần tử lấy ra lại
        q.push (z % m); //đưa sợi dây được nối vào queue
        res = (res + z) % m; //cập nhật kết quả
    }
    cout << res << endl; //đưa ra kết quả
    q.pop (); //làm trống queue
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
148. DSA03016	SỐ NHỎ NHẤT
/*Cho hai số nguyên dương S và D, trong đó S là tổng các chữ số và D là số các chữ số của một số. Nhiệm vụ của bạn là
tìm số nhỏ nhất thỏa mãn S và D? Ví dụ với S = 9, D = 2 ta có số nhỏ nhất thỏa mãn S và D là 18.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là bộ 2 số S và D được viết trên một dòng.
T, S, D thỏa mãn ràng buộc: 1≤T≤100;  1≤ S,D≤1000.
Output:
Đưa ra kết quả mỗi test theo từng dòng. Nếu không có đáp án, in ra -1.
Input                Output
2
9 2                  18
20 3                 288
*/
//Ý tưởng: chèn từ cuối lên số lớn nhất có thể
//Code:

#include<bits/stdc++.h>
using namespace std;

int m, s;

void init() { //hàm khởi tạo
    cin >> m >> s;
}
 
void solve() { //hàm xử lý
    if (m > s*9) cout << "-1" << endl; //nếu không thể tạo số đưa ra -1
    else if (m / 9 == s) { //nếu tổng đúng bằng s chữ số 9 in ra s chữ số 9
        for (int i = 1; i <= s; i++) cout << "9";
        cout << endl;
    } else if (m / 9 < s && m != 0) {
        if (m % 9 == 0) { //nếu tổng chia hết cho 9
            cout << "1"; //chữ số đầu tiên bắt đầu bằng số 1
            for (int i = 1; i < s - m / 9; i++) cout << "0"; //in ra số các chữ số còn lại là 0
            cout << "8"; //số 8 đứng trước số 9
            for (int i = 1; i < m / 9; i++) cout << "9"; //in các chữ số là 9 tối ở cuối tối đa có thể
            cout << endl;
        } else { //nếu tổng không chia hết cho 9
            if (s - m / 9 == 1) { //nếu có thể chèn s-1 chữ số 9
                cout << m % 9; //in ra phần dư của m cho 9
                for (int i = 0; i < m / 9; i++) cout << "9"; //in ra s-1 chữ số 9
                cout << endl;
            } else {
                cout << "1"; //chữ số dầu tiên là 1
                for (int i = 1; i < s - m / 9 - 1; i++) cout << "0"; //in ra các chữ số còn lại là 0
                cout << m % 9 - 1; //in ra tổng còn lại
                for (int i = 1; i <= m / 9; i++) cout << "9"; //in ra số chữ số 9 tối đa có thể
                cout << endl;
            }
        }
    } else if (m == 0 && m / 9 < s) cout << "0" << endl; //nếu tổng bằng 0 và có số chữ số khác 0 thì in 0
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
149. DSA03017	GIÁ TRỊ NHỎ NHẤT CỦA XÂU
/*Cho xâu ký tự S. Ta gọi giá trị của xâu S là tổng bình phương số lần xuất hiện mỗi ký tự trong S. Hãy tìm giá
trị nhỏ nhất của xâu S sau khi thực hiện K lần loại bỏ ký tự.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất là số K; phần thứ hai là một xâu
ký tự S được viết trên một dòng.
T, S, K thỏa mãn ràng buộc: 1≤T≤100;  1≤length(S)≤10000; 1≤K≤1000.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                          Output
2
2
ABCCBC                         6
2
AAAB                           2
*/
//Ý tưởng: sắp xếp theo số lần xuất hiện tăng dần, sau đó xoá dần từ cuối đi 1 các số có số lần xuất hiện lớn nhất
//Code:

#include<bits/stdc++.h>
using namespace std;

int k;
string str;

void init(){ //hàm khởi tạo
    cin >> k;
    cin >> str;
}

void solve() { //hàm xử lý
    //sắp xếp lại xâu để đếm số lần xuất hiện
    sort (str.begin (), str.end ());
    //vector a lưu số lần xuất hiện
    vector <int> a;
    a.push_back (0);
    a.push_back (1);
    //vector b lưu số phần tử có cùng số lần xuất hiện
    vector <int> b;
    b.push_back (0);
    //đếm số lần xuất hiện
    for (int i = 1; i < str.length (); i++) {
        if (str[i] == str[i - 1]) {
            a[a.size () - 1]++;
        } else {
            a.push_back (1);
        }
    }
    //sắp xếp tăng dấn số lần xuất hiện
    sort (a.begin (), a.end ());
    //chuyển vector a ứng với số lần xuất hiện và vector b ứng với số phần tử có cùng số lần xuất hiện
    b.push_back (1);
    for (int i = 2; i < a.size (); i++) {
        //nếu bằng số đứng trước thì tăng số lần xuấn hiện ở vector b lên 1 và xoá phần tử đó của vector a
        if (a[i] == a[i - 1]) {
            b[b.size () - 1]++;
            a.erase (a.begin () + i);
            i--;
        } else {
            //nếu gặp phần tử khác thì đánh dấu nó xuất hiện 1 lần
            b.push_back (1);
        }
    }
    //nếu k lớn hơn 0 thực hiện xoá
    while (k > 0) {
        /*
        nếu tích của hiệu số lần xuất hiện lớn nhất và số lần xuất hiện lớn thứ 2 với số phần tử có số lần
        xuất hiện lớn nhất nhỏ hơn hoặc bằng k thì xoá hết để số lần xuất hiện lớn nhất và lớn thứ 2 bằng
        nhau. Khi đó số lần xuất hiện lớn thứ 2 sẽ là lớn nhất và tổng số phần tử cũng tăng 1 khoảng bằng
        số phần tử của số lần xuất hiện lớn nhất trước đó. Xoá phần tử ở cuối của 2 vector và giảm k để tiếp
        tục vòng lặp
        */
        if ((a[a.size () - 1] - a[a.size () - 2]) * b[b.size () - 1] <= k) {
            //giảm k
            k -= (a[a.size () - 1] - a[a.size () - 2]) * b[b.size () - 1];
            //cập nhật số phần tử lớn nhất
            b[b.size () - 2] += b[b.size () - 1];
            //xoá đi 2 phần tử ở cuối vector
            a.pop_back ();
            b.pop_back ();
        } else {
            /*
            nếu tích của hiệu số lần xuất hiện lớn nhất và số lần xuất hiện lớn thứ 2 với số phần tử có số lần
            xuất hiện lớn nhất lớn hơn k thì trừ số lần xuất hiện lớn nhất đi 1 khoảng bằng với chia nguyên của k
            cho số phần tử có số lần xuất hiện lớn nhất. Khi đó k sẽ còn là phần dư của k cho số phần tử có số
            lần xuất hiện lớn nhất. Tiếp tục trừ đi số phần tử đúng bằng giá trị chia dư đó 1 đơn vị. Khi đó có
            2 trường hợp xảy ra là giá trị sau khi trừ đúng bằng số lần xuất hiện nhiều thứ 2 thì ta tăng số phần tử
            có số lần xuất hiện nhiều thứ 2 lên sau đó cập nhật số phần tử xuất hiện nhiều nhất. Trường hợp còn lại
            thì ta cập nhật số phần tử xuất hiện lớn nhất và thêm vào vector a số lần xuất hiện nhiều thứ 2 bằng số
            lần xuất hiện nhiều nhất trừ đi 1 và với số phần tử tương ứng ở vector b là số phần dư bên trên
            */
            // giảm số lần xuất hiện lớn nhất
            a[a.size () - 1] -= k / b[b.size () - 1];
            //trường hợp đầu
            if (a[a.size () - 1] - 1 == a[a.size () - 2]) {
                //tăng số phần tử xuất hiện nhiều thứ 2
                b[b.size () - 2] += k % b[b.size () - 1];
                //cập nhật lại số phần tử xuất hiện nhiều nhất
                b[b.size () - 1] -= k % b[b.size () - 1];
            } else {
                //trường hợp 2
                //thêm vào số lần xuất hiện nhiều thứ 2
                a.push_back (a[a.size () - 1] - 1);
                //thêm vào số lần xuất hiện của số phần tử xuất hiện nhiều thứ 2
                b.push_back (k % b[b.size () - 1]);
                //cập nhật lại số phần tử có số lần xuất hiện nhiều nhất
                b[b.size () - 2] -= k % b[b.size () - 2];
            }
            //gán k =0 để kết thúc vòng lặp
            k = 0;
        }
    }
    //khai báo kết quả
    long long res = 0;
    //cập nhật kết quả
    for (int i = 0; i < a.size (); i++) {
        res += b[i] * pow (a[i], 2);
    }
    //in ra kết quả
    cout << res << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
150. DSA03018	SỐ MAY MẮN
/*Hoàng yêu thích các số may mắn. Ta biết rằng một số là số may mắn nếu biểu diễn thập phân của nó chỉ chứa các chữ số
may mắn là 4 và 7. Ví dụ, các số 47, 744, 4 là số may mắn và 5, 17, 467 không phải. Hoàng muốn tìm số may mắn bé nhất có
tổng các chữ số bằng n. Hãy giúp anh ấy
Dữ liệu vào: Dòng đầu ghi số bộ test, mỗi bộ test có một dòng chứa số nguyên n (1<=n<=10^6) — tổng các chữ
số của số may mắn cần tìm.
Kết quả: In ra trên 1 dòng số may mắn bé nhất, mà tổng các chữ số bằng n. Nếu không tồn tại số thỏa mãn, in ra -1.
Input                 Output
2
11                    47
10                    -1
 */
//Ý tưởng: tạo ra tối đa số các số 7 ở cuối
//Code:

#include <bits/stdc++.h>
using namespace std;

int n;

void init() { //hàm khởi tạo
    cin >> n;
}

void solve() { //hàm xử lý
    int r = n / 7; // khởi tạo số chữ số 7 tối đa
    int l = 0;  // khởi tạo số chữ số 4 là 0
    int sum = r * 7; // sum là tổng các chữ số hiện tại
    while (1) {  // vòng lặp luôn đúng
        //khi tổng bằng n thì dừng vòng lặp, nếu nhỏ hơn n thì tăng thêm 1 chữ số 4, nếu lớn hơn n thì giảm 1 chữ số 7
        if (sum == n) break;
        else if (sum < n) {
            sum += 4;
            l++;
        } else {
            sum -= 7;
            r--;
        }
        if (r == 0 || l == n / 4) break; //khi số chữ số 7 còn 0 hoặc số chứ số 4 tối đa thì dừng vòng lặp
    }
    if (sum == n) { // nếu tổng bằng n thì in ra số tìm được
        for (int i = 0; i < l; i++) cout << "4"; //liệt kê các chữ số 4 ở trước
        for (int i = 0; i < r; i++) cout << "7"; // liệt kê các chữ số 7 ở sau
    } else cout << "-1"; //không thì in ra -1
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
151. DSA03019	PHÂN SỐ ĐƠN VỊ
/*Một phân số đơn vị nếu tử số của phân số đó là 1. Mọi phân số nguyên dương đều có thể biểu diễn thành tổng các phân số
đơn vị. Ví dụ 2/3 = 1/2  + 1/6. Cho phân số nguyên dương P/Q bất kỳ (P < Q), hãy biểu diễn phân số nguyên dương thành
tổng phân số đơn vị với số hạng tử là ít nhất.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là bộ đôi tử số P và mẫu số Q của phân số nguyên dương được viết
trên một dòng.
T, P, Q thỏa mãn ràng buộc: 1≤T≤100;  1≤P, Q≤100.
Output:
Đưa ra đáp án tìm được trên 1 dòng, theo dạng “1/a + 1/b + …”
Input                Output
2
2 3                  1/2 + 1/6
1 3                  1/3
*/
//Ý tưởng: in ra theo công thức đến khi kết quả về 0
//Code:

#include<bits/stdc++.h>
using namespace std;

long long p,q;

void init() { //hàm khởi tạo
    cin >> p >> q;
}

void solve(){ //hàm xử lý
    while(1){
        if(q%p==0){ //nếu là phân số tối giản
            cout<<"1/"<<q/p;
            break;
        }else{ //nếu chưa tối giản
            long long n=q/p+1; //đưa ra phân số đơn vị tiếp theo
            cout<<"1/"<<n<<" + ";
            p=p*n-q; //cập nhật p và q mới bằng cách trừ quy đồng
            q*=n;
        }
    }
    cout<<endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
152. DSA03020	BIỂU THỨC ĐÚNG
/*Cho một mảng S gồm 2×N ký tự, trong đó có N ký tự ‘[’ và N ký tự ‘]’. Xâu S được gọi là viết đúng nếu S có dạng S2[S1]
trong đó S, S2 là các xâu viết đúng. Nhiệm vụ của bạn là tìm số các phép đổi chỗ ít nhất các ký tự kề nhau của xâu S
viết sai để  S trở thành viết đúng. Ví dụ với xâu S =”[]][][” ta có số phép đổi chỗ kề nhau ít nhất là 2.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một xâu S viết sai theo nguyên tắc kể trên.
T, S thòa mãn ràng buộc: 1≤T≤100; 1≤length(S)≤100000.
Output:
Đưa kết quả trên một dòng.
Input                 Output
2
[]][][                2
[][][]                0
*/
// Ý tưởng: nếu gặp ngoặc ] mà không có ngoặc [ trước nó thì phải đổi chỗ
//Code:

#include <bits/stdc++.h>
using namespace std;

long swapCount(string chars) { //hàm tính số phép đổi chỗ
    int countLeft = 0, countRight = 0;
    int swap = 0, imbalance = 0;
    for (int i = 0; i < chars.length (); i++) {
        if (chars[i] == '[') {
            countLeft++; //tăng số ngoặc trái
            if (imbalance > 0) { //nếu số ngoặc phải sai chỗ trước nó lớn hơn 0 thì thực hiện đổi chỗ
                swap += imbalance;
                imbalance--; //giảm đi 1 ngoặc phải sai chỗ
            }
        } else if (chars[i] == ']') {
            countRight++; //tăng số ngoặc phải
            imbalance = (countRight - countLeft); //cập nhật số ngoặc phải bị sai
        }
    }
    return swap;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        string str;
        cin >> str;
        cout << swapCount (str) << endl;
    }
}
153. DSA04007	HỆ CƠ SỐ K
/*Cho hai số A, B ở hệ cơ số K. Hãy tính tổng hai số đó ở hệ cơ số K.
Input: Dòng đầu ghi số bộ test T (T<10). Mỗi bộ test ghi 3 số K,A,B.
(2≤K≤10; A và B nếu biểu diễn trong hệ cơ số 10 đều nhỏ hơn 109)
Output: In ra tổng của A và B trong hệ cơ số K
Input                Output
1
2 1 10               11
*/
//Ý tưởng: chuyển đổi sang hệ 10 cộng sau đó chuyển về hệ k
//Code:

#include<bits/stdc++.h>
using namespace std;

int k;
string str1, str2;

void init() { //hàm khởi tạo
    cin >> k;
    cin >> str1;
    cin >> str2;
}

void solve() { //hàm xử lý
    long long sum = 0;
    int dem = 0;
    for (int i = str1.length () - 1; i >= 0; i--) { //chuyển số thứ 1 nhất về hệ 10 sau đó cộng rồi bổ sung vào sum
        sum += (str1[i] - 48) * pow (k, dem);
        dem++;
    }
    dem = 0;
    for (int i = str2.length () - 1; i >= 0; i--) { //chuyển số thứ 2 về hệ 10 rồi bổ sung vào sum
        sum += (str2[i] - 48) * pow (k, dem);
        dem++;
    }
    vector <int> res;
    while (sum > 0) { //chuyển đổi về hệ cơ số k
        int x = sum % k;
        res.push_back (x);
        sum /= k;
    }
    for (int i = res.size () - 1; i >= 0; i--) cout << res[i]; //đưa ra kết quả
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    cin.ignore ();
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
154. DSA04013	SẮP XẾP KANGURU
/*Có N con kanguru trong vườn thú, con thứ i có chiều cao bằng A[i]. Con kanguru có chiều cao X có thể chứa được một con
có chiều cao bằng Y trong túi của nó nếu như X >= 2*Y.Một con đã chứa một con kanguru rồi, thì không thể nhảy vào túi
một con kanguru khác.Bầy Kanguru rất thích chơi trốn tìm, vì vậy chúng thường xuyên nhảy vào túi của nhau. Các bạn hãy
tính toán xem trong trường hợp tối ưu, số con kanguru nhìn thấy trong vườn thú ít nhất bằng bao nhiêu?
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test gồm số nguyên N (1 ≤ N ≤ 100 000).
Dòng tiếp theo gồm N số nguyên A[i] (1 ≤ A[i] ≤ 100 000).
Output:
Với mỗi test, in ra đáp án trên một dòng.
Input                Output
2
8
2 5 7 6 9 8 4 2      5
8
9 1 6 2 6 5 8 3      5
*/
//Ý tưởng: sắp xếp lại mảng sau đó duyệt từ cuối và giữa mảng, nếu thoả mãn điều kiện thì giảm số kanguru
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, a[100005];

void init() {
    cin >> n;
    for (long i = 0; i < n; i++) cin >> a[i];
}

void solve() {
    sort (a, a + n); //sắp xếp lại mảng a
    //khởi tại vị trí bên phải là vị cuối cùng, vị trí bên trái là vị trí giữa và biến đêm số cặp bằng 0
    long r = n - 1, l = n / 2 - 1, count = 0;
    while (1) { //vòng lặp luôn đúng
        if (a[r] >= 2 * a[l]) { //thoả mãn điều kiện thì tăng số cặp lên 1 sau đó giảm vị trí phải và trái đi 1
            count++;
            r--;
            l--;
        } else l--; //không thoả mãn thì giảm vị trí bên trái đi 1
        if (l == -1 || r == n / 2 - 1) break; // nếu phần tử phải hoặc trái vượt quá giá trị tối thiểu thì dừng vòng lặp
    }
    //in ra kết quả
    cout << n - count << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
155. DSA04008	SỐ FIBONACCI THỨ N
/*Dãy số Fibonacci được xác định bằng công thức như sau:
F[0] = 0, F[1] = 1;
F[n] = F[n-1] + F[n-2] với mọi n >= 2.
Các phần tử đầu tiên của dãy số là 0, 1, 1, 2, 3, 5, 8, ...
Nhiệm vụ của bạn là hãy xác định số Fibonaci thứ n. Do đáp số có thể rất lớn, in ra kết quả theo modulo 109+7.
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 1000).
Mỗi test bắt gồm một số nguyên N (1 ≤ N ≤ 109).
Output:
Với mỗi test, in ra đáp án trên một dòng.
Input                 Output
3
2                     1
6                     8
20                    6765
*/
//Ý tưởng: sử dụng công thức tính số fibonacci thứ n bằng tích các ma trận
//Code:

#include <bits/stdc++.h>
using namespace std;

long m=1e9+7;

void multiply(long F[2][2], long M[2][2]) { //hàm nhân 2 ma trận
    long x = (F[0][0] % m * M[0][0] % m + F[0][1] % m * M[1][0] % m) % m;
    long y = (F[0][0] % m * M[0][1] % m + F[0][1] % m * M[1][1] % m) % m;
    long z = (F[1][0] % m * M[0][0] % m + F[1][1] % m * M[1][0] % m) % m;
    long w = (F[1][0] % m * M[0][1] % m + F[1][1] % m * M[1][1] % m) % m;
    F[0][0] = x;
    F[0][1] = y;
    F[1][0] = z;
    F[1][1] = w;
}

void power(long F[2][2], long n) { //hàm đệ quy luỹ thừa của ma trận
    if (n == 0 || n == 1) return;
    long M[2][2] = {{1, 1},
                    {1, 0}};
    power (F, n / 2); //a^n=a^(n/2)*a^(n/2) với n chẵn và a^n=a^(n/2)*a^(n/2)*a với n lẻ
    multiply (F, F); //nhân các ma trận lại
    if (n % 2 != 0) multiply (F, M);
}

long fib(long n) { //hàm tính fibonacci thứ n
    long F[2][2] = {{1, 1},
                    {1, 0}};
    if (n == 0) return 0;
    power (F, n - 1);
    return F[0][0] % m;
}
 
int main() {
    int t;
    cin >> t;
    while (t--) {
        long n;
        cin >> n;
        cout << fib (n) << endl;
    }
    return 0;
}
156. DSA04009	LŨY THỪA MA TRẬN 1
/*Cho ma trận vuông A kích thước N x N. Nhiệm vụ của bạn là hãy tính ma trận X = A^K với K là số nguyên cho trước.
Đáp số có thể rất lớn, hãy in ra kết quả theo modulo 1e9+7.
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 100).
Mỗi test bắt gồm một số nguyên N và K (1 ≤ N ≤ 10, 1 ≤ K ≤ 1e9) là kích thước của ma trận và số mũ.
Output:
Với mỗi test, in ra kết quả của ma trận X.
Input:                Output:
2
2 5
1 1                   8 5
1 0                   5 3
3 1000000000
1 2 3                 597240088 35500972 473761863
4 5 6                 781257150 154135232 527013321
7 8 9                 965274212 272769492 580264779
*/
//Ý tưởng: sử dụng công thức nhân 2 ma trận
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, k, m=1e9+7;
long long a[10][10],repa[10][10];

void mul(long long a[][10], long long b[][10]) { //hàm nhân 2 ma trận
    long long tmp[10][10] = {0}; //khai báo một ma trận trung gian
    for (int i = 0; i < n; i++) //nhân ma trận a và b
        for (int j = 0; j < n; j++)
            for (int k = 0; k < n; k++)
                tmp[i][j] += (a[i][k] % m * b[k][j] % m) % m; //nhân hàng và cột và thực hiện chia dư cho m
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            a[i][j] = tmp[i][j] % m; //gán ma trận a bằng ma trận trung gian vừa tìm
}

void power(long long a[][10], int k) { //hàm tính luỹ thừa
    if (k == 1) return; //nếu k=1 thì a không thay đổi
    power (a, k / 2); //nếu k>1 tính luỹ thừa của a và k/2
    mul (a, a); //nhân 2 luỹ thừa của a và k/s với nhau
    /*
    nếu k%2=0 thì a^n=a^(n/2)*a^(n/2)
    nếu k%2=1 thì a^n=a^(n/2)*a^(n/2)*a
    */
    if (k % 2 == 1) mul (a, repa);
}

void init() {
    cin >> n >> k;
    //nhập vào ma trận a và tạo 1 nhân bản của nó
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++) {
            cin >> a[i][j];
            repa[i][j] = a[i][j];
        }
}

void solve() { //hàm xử lý
    power (a, k); //gọi hàm tính luỹ thừa của ma trận a
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++)
            cout << a[i][j] << " "; //in ra kết quả
        cout << endl;
    }
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
157. DSA04012	TÍCH ĐA THỨC
/*Cho hai đa thức P và Q được biểu diễn như một mảng bao gồm các hệ số của đa thức. Ví dụ với P(x) = 5 + 0x1 +10x2 + 6x3
được biểu diễn như mảng P[] ={5, 0, 10, 6}. Hãy đưa ra đa thức R = P×Q theo các hệ số của R với cách biểu diễn như trên.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 3 dòng: dòng thứ nhất đưa vào hai số M, N tương ứng với lũy thừa
lớn nhất của đa thức P và Q; dòng tiếp theo đưa vào M số là hệ số của đa thức P; dòng cuối cùng đưa vào M số là hệ số của đa thức Q.
T, M, N, P[i], Q[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤M, N≤100; 1≤P[i], Q[i]≤100.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
4 3                  2 0 10 4 12 8
1 0 3 2
2 0 4
5 4                  4 36 14 39 79 23 34 35
1 9 3 4 7
4 0 2 5
*/
//Ý tưởng: nhân phá như bình thường
//Code:

#include<bits/stdc++.h>
using namespace std;

int n,m;
int a[105], b[105];

void init() { //hàm khởi tạo
    cin >> n >> m;
    for (int i = 0; i < n; i++) cin >> a[i];
    for (int i = 0; i < m; i++) cin >> b[i];
}

void solve() { //hàm xử lý
    int res[m + n - 1] = {0}; //khởi tạo vector kết quả
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            res[i + j] += a[i] * b[j]; //thực hiện khai triển nhân đa thức
    for (int i = 0; i < m + n - 1; i++) cout << res[i] << " "; //đưa ra kết quả
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
158. DSA04011	TÍCH HAI SỐ NHỊ PHÂN
/*Cho hai xâu nhị phân biểu diễn hai số. Nhiệm vụ của bạn là đưa ra tích của hai số. Ví dụ với xâu S1=”1100” và
S2=”1010” ta sẽ có kết quả là 120.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 2 hai xâu nhị phân S1, S2 được viết trên một dòng.
T, S1, S2 thỏa mãn ràng buộc: 1≤T≤100;  1≤ length(S1), length(S2)≤30.
Output:
Đưa ra tích của mỗi test theo từng dòng
Input                Output
2
1100 01              12
01 01                1
*/
//Ý tưởng: đưa về dạng thập phân rồi nhân
//Code:

#include<bits/stdc++.h>
using namespace std;

long a, b;
string str1;
string str2;

void init() { //hàm khởi tạo
    cin >> str1;
    cin >> str2;
}

void solve() { //hàm xử lý
    a = 0, b = 0;
    //chuyển 2 số về dạng thập phân
    for (int i = str1.length () - 1; i >= 0; i--) a += (str1[i] - 48) * pow (2, str1.length () - i - 1);
    for (int i = str2.length () - 1; i >= 0; i--) b += (str2[i] - 48) * pow (2, str2.length () - i - 1);
    long long res = a * b; //nhân 2 số
    cout << res << endl;//đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
159. DSA05018	XÂU CON ĐỐI XỨNG DÀI NHẤT
/*Cho xâu S chỉ bao gồm các ký tự viết thường và dài không quá 1000 ký tự.
Hãy tìm xâu con đối xứng dài nhất của S.
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 10).
Mỗi test gồm một xâu S có độ dài không vượt quá 1000, chỉ gồm các kí tự thường.
Output:  Với mỗi test, in ra đáp án tìm được.
Input                 Output
2
abcbadd               5
aaaaa                 5
*/
//Ý tưởng: chọn từng chỉ mục là vị trí giữa của xâu đối xứng
//Code:

#include <bits/stdc++.h>
using namespace std;

string str;
int n, l, r, res;

void init() { //hàm khởi tạo
    cin.ignore ();
    cin >> str;
    n = str.length ();
}

void solve() { //hàm xử lý
    res = 1; //xâu đối xứng ngắn nhất luôn là 1
    for (int i = 0; i < n; i++) { //chọn từng chỉ mục là vị trí giữa
        l = i, r = i;
        while (l > 0 && r < n - 1) {
            l--;
            r++;
            if (str[l] != str[r]) { //nếu kết thúc phần đối xứng dừng lại
                l++;
                r--;
                break;
            }
        }
        res = max (res, r - l + 1); //cập nhật kết quả
    }
    for (int i = 0; i < n - 1; i++) { //chọn từng chỉ mục là vị trí giữa
        if (str[i] == str[i + 1]) {
            l = i, r = i + 1;
            while (l > 0 && r < n - 1) {
                l--;
                r++;
                if (str[l] != str[r]) { //nếu kết thúc phần đối xứng dừng lại
                    l++;
                    r--;
                    break;
                }
            }
            res = max (res, r - l + 1); //cập nhật kết quả
        }
    }
    cout << res << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
160. DSA05019	HÌNH VUÔNG LỚN NHẤT
/*Cho một bảng số N hàng, M cột chỉ gồm 0 và 1. Bạn hãy tìm hình vuông có kích thước lớn nhất, sao cho các số trong hình
vuông toàn là số 1.
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 10).
Mỗi test bắt đầu bởi 2 số nguyên N, M (1 ≤ N, M ≤ 500).
N dòng tiếp theo, mỗi dòng gồm M số mô tả một hàng của bảng.
Output:
Với mỗi test, in ra đáp án là kích thước của hình vuông lớn nhất tìm được trên một dòng.
Input                 Output
2
6 5                   3
0 1 1 0 1
1 1 0 1 0
0 1 1 1 0
1 1 1 1 0
1 1 1 1 1
0 0 0 0 0
2 2                   0
0 0
0 0
*/
//Ý tưởng: sử dụng công thức quy hoạc động
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, m, a[505][505], d[505][505];

void init() { //hàm khởi tạo
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) {
            cin >> a[i][j];
            d[i][j] = a[i][j];
        }
}

void solve() { //hàm xử lý
    int res = 0;
    //áp dụng công thức quy hoạch động, hãy chạy code trên giấy để hiểu
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (a[i][j] != 0) {
                if (a[i][j] == a[i - 1][j - 1] && a[i][j] == a[i][j - 1] && a[i][j] == a[i - 1][j]) {
                    d[i][j] = min (d[i - 1][j - 1], d[i - 1][j]);
                    d[i][j] = min (d[i][j], d[i][j - 1]) + 1;
                }
                res = max (res, d[i][j]);
            }
        }
    }
    cout << res << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
161. DSA05020	ĐƯỜNG ĐI NHỎ NHẤT
/*Cho bảng A[] kích thước N x M (N hàng, M cột). Bạn được phép đi xuống dưới, đi sang phải và đi xuống ô chéo dưới. Khi
đi qua ô (i, j), điểm nhận được bằng A[i][j].
Hãy tìm đường đi từ ô (1, 1) tới ô (N, M) sao cho tổng điểm là nhỏ nhất.
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test gồm số nguyên dương N và M.
N dòng tiếp theo, mỗi dòng gồm M số nguyên A[i][j] (0 ≤ A[i] ≤ 1000).
Output:
Với mỗi test, in ra độ dài dãy con tăng dài nhất trên một dòng.
Input                Output
1
3 3                  8
1 2 3
4 8 2
1 5 3
*/
//Ý tưởng: sử dụng công thức quy hoạch động xác định xem tại vị trí tiếp theo nếu được chọn hay không chọn sẽ tối ưu hơn
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, m, a[1005][1005], dp[1005][1005];

void init() { //hàm khởi tạo
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            cin >> a[i][j];
}

void solve(){ //hàm xử lý
    for (int i = 0 ; i <= n ; i++)
        for (int j = 0 ; j <= m ; j++) {
            if (i == 0 || j == 0) dp[i][j] = INT_MAX; //khởi tạo điểm ban đầu
            else {
                if (i == 1 && j == 1) dp[i][j] = a[i][j]; //bắt đầu tại điểm (1,1);
                else {
                    dp[i][j] = min (dp[i - 1][j], dp[i][j - 1]); //kiểm tra xem nên đi từ ô nào đến vị trí hiện tại
                    dp[i][j] = min (dp[i][j], dp[i - 1][j - 1]) + a[i][j];
                }
            }
        }
    cout << dp[n][m] << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
162. DSA05014	CATALAN NUMBER
/*Catalan Number là dãy số thỏa mãn biểu thức:
Dưới đây là một số số Catalan với n=0, 1,2,.. : 1, 1, 2, 5, 14, 42, 132, 429,… Cho số tự nhiên N. Nhiệm vụ của bạn là
đưa ra số Catalan thứ N.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một số nguyên n.
T, n thỏa mãn ràng buộc: 1 ≤ T ≤ 100;  1 ≤ n ≤ 100.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
3
5                     42
4                     14
10                    16796
*/
//Ý tưởng: sử dụng công thức số catalan, viết 2 hàm cộng và nhân 2 số lớn
//Code:

#include <bits/stdc++.h>
using namespace std;

int n;
vector <string> dp;

string mul(string s1, string s2) { //hàm nhân 2 số lớn
    //nhân theo quy tắc nhân
    int n1 = s1.length ();
    int n2 = s2.length ();
    int res[n1 + n2];
    memset (res, 0, sizeof (res));
    for (int i = s1.length () - 1; i >= 0; i--)
        for (int j = s2.length () - 1; j >= 0; j--)
            res[i + j + 1] += (s1[i] - '0') * (s2[j] - '0');
    for (int i = n1 + n2 - 1; i >= 0; i--)
        if (res[i] > 9) {
            res[i - 1] += res[i] / 10;
            res[i] %= 10;
        }
    string ans = "";
    if (res[0] != 0) ans += to_string (res[0]);
    for (int i = 1; i < n1 + n2; i++) ans += to_string (res[i]);
    return ans;
}

string add(string s1, string s2) { //hàm cộng 2 số lớn
    if (s1.length () > s2.length ()) {
        string tmp = s1;
        s1 = s2;
        s2 = tmp;
    }
    int n1 = s1.length ();
    int n2 = s2.length ();
    int res[n2 + 1];
    res[0] = 0;
    for (int i = n2 - 1; i >= n2 - n1; i--) res[i + 1] = (s1[i - (n2 - n1)] - '0') + (s2[i] - '0');
    for (int i = 0; i < n2 - n1; i++) res[i + 1] = (s2[i] - '0');
    for (int i = n2; i > 0; i--)
        if (res[i] > 9) {
            res[i - 1]++;
            res[i] -= 10;
        }
    string ans = "";
    if (res[0] != 0) ans += to_string (res[0]);
    for (int i = 1; i <= n2; i++) ans += to_string (res[i]);
    return ans;
}

void init() {
    cin >> n;
}

void solve() { //hàm xử lý
    dp.push_back ("1");
    for (int i = 1; i <= 100; i++) {
        string tmp = "";
        for (int j = 0; j < i; j++) tmp = add (tmp, mul (dp[j], dp[i - j - 1])); //tính số catalan thứ i
        dp.push_back (tmp);
    }
}

void print() { //hàm in
    cout << dp[n] << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    solve();
    cin.ignore();
    while (t --) {
        init();
        print();
    }
    return 0;
}
163. DSA05015	TÍNH P(N,K)
/*P(n, k) là số phép biểu diễn các tập con có thứ tự gồm k phần tử của tập gồm n phần tử. Số P(n, k) được định nghĩa
theo công thức sau
Cho số hai số n, k. Hãy tìm P(n,k) theo modulo 109+7.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một cặp số n, k được viết trên một dòng.
T, n, k thỏa mãn ràng buộc: 1 ≤ T ≤ 100;  1 ≤ n,k ≤ 1000.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
2
5 2                   20
4 2                   12
*/
//Ý tưởng: tính theo công thức đã cho
//Code:

#include <bits/stdc++.h>
using namespace std;

long res, m=1e9+7, long a[1005];
int n, k;

void init() { //hàm khởi tạo
    cin >> n >> k;
}

void solve() { //hàm xử lý
    if (k > n) res = 0;
    else {
        res = 1;
        for (int i = n - k + 1; i <= n; i++) { //tính số p(n,k) theo công thức
            res *= i;
            res %= m;
        }
    }
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    a[0] = 1;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
164. DSA05016	SỐ UGLY
/*Số Ugly là các số chỉ có ước số là 2, 3, 5. Theo qui ước số 1 cũng là 1 số Ugly. Dưới đây là 11 số Ugly đầu tiên:
1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15. Cho số tự nhiên N, nhiệm vụ của bạn là tìm số Ugly thứ N.
Input:  Dòng đầu tiên đưa vào số lượng bộ test T.  Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một số tự
nhiên N được viết trên một dòng. T, N thỏa mãn ràng buộc: 1 ≤ T ≤ 100;  1 ≤ N ≤ 104.
Output: Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
2
10                    12
4                     4
*/
//Ý tưởng: thực hiện vét cạn sinh ra các số ugly
//Code:

#include <bits/stdc++.h>
using namespace std;

unsigned long long a[10005], x1 = 1, x2 = 1, x3 = 1;
long n;

int main() {
    int t;
    cin >> t;
    a[1] = 1;
    for (long i = 2; i <= 10005; i++) {
        a[i] = min (a[x1] * 2, min (a[x2] * 3, a[x3] * 5)); //tìm xem số nào là số ugly tiếp theo
        if (a[i] == a[x1] * 2) x1++;
        if (a[i] == a[x2] * 3) x2++;
        if (a[i] == a[x3] * 5) x3++;
    }
    while (t--) {
        cin >> n;
        cout << a[n] << "\n"; //đưa ra kết quả
    }
    return 0;
}
165. DSA05003	DÃY CON CHUNG DÀI NHẤT CỦA BA XÂU
#include <bits/stdc++.h>
using namespace std;

int x, y, z;
string str1, str2, str3;

void init() { //hàm khởi tạo
    cin >> x >> y >> z;
    cin >> str1 >> str2 >> str3;
}

void solve() { //hàm xử lý
    int res[x + 1][y + 1][z + 1];
    for (int i = 0; i <= x; i++)
        for (int j = 0; j <= y; j++)
            for (int k = 0; k <= z; k++) {
                if (i == 0 || j == 0 || k == 0) res[i][j][k] = 0;
                else if (str1[i - 1] == str2[j - 1] && str2[j - 1] == str3[k - 1])
                    res[i][j][k] = res[i - 1][j - 1][k - 1] + 1;
                else res[i][j][k] = max (res[i - 1][j][k], max (res[i][j - 1][k], res[i][j][k - 1]));
            }
    cout << res[x][y][z] << endl;
}

int main() {
    int t;
    cin >> t;
    cin.ignore ();
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
166. DSA05006	TỔNG LỚN NHẤT CỦA DÃY CON TĂNG DẦN
/*Cho dãy số A[] gồm N số. Nhiệm vụ của bạn là tìm tổng lớn nhất của dãy con được sắp theo thứ tự tăng dần của dãy A[].
Ví dụ với dãy A[] = {1, 101, 2, 3, 100, 4, 5} ta có kết quả là 106 = 1 + 2 + 3 + 100. Với dãy A[] = {10, 7, 5} ta có kết
quả là 10. Với dãy A[] = {1, 2, 3, 5} ta có kết quả là 11.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên đưa vào N là số phần tử của dãy A[];
dòng tiếp theo đưa vào N số A[i]; các số được viết cách nhau một vài khoảng trống.
T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤N ≤103; 0≤A[i] ≤103.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
3
7                     106
1 101 2 3 100 4 5
3                     10
10 7 5
4                     11
1 2 3 5
*/
/*Ý tưởng: tổng lớn nhất tại vị trí a[i] bằng giá trị lớn nhất giữa tổng của dãy con tăng trước đó + a[i] với tổng lớn
nhất của nó hiện tại*/
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, a[1005], dp[1005];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    dp[0] = a[0]; //khởi tạo giá trị ban đầu
    for (int i = 1; i < n; i++) {
        dp[i] = a[i]; //giá trị nhỏ nhất luôn bằng a[i]
        for (int j = 0; j < i; j++)
            if (a[i] > a[j]) dp[i] = max (dp[i], dp[j] + a[i]); //cập nhật giá trị lớn nhất
    }
    sort (dp, dp + n); //sắp xếp lại các tổng của dãy con
    cout << dp[n - 1] << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
167. DSA05017	DÃY SỐ BI-TONIC
/*Một dãy số được gọi là Bi-tonic nếu nó được chia thành hai dãy đầu tăng dần và dãy tiếp theo giảm dần. Nhiệm vụ của
bạn là tìm tổng lớn nhất dãy con Bi-tonic của dãy số A[]. Ví dụ với dãy A[] = {1, 15, 51, 45, 33, 100, 12, 18, 9} ta có
kết quả là 194 tương ứng với dãy Bi-tonic {1, 15, 51, 100, 18, 9}.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên đưa vào N là số phần tử của dãy A[];
dòng tiếp theo đưa vào N số A[i]; các số được viết cách nhau một vài khoảng trống.
T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤N ≤100; 0≤A[i] ≤100.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                       Output
2
6                           210
80 60 30 40 20 10
9                           194
1 15 51 45 33 100 12 18 9
*/
//Ý tưởng: tìm tổng dãy con lớn nhất tăng dần từ trái sang và từ phải sang, dãy bitonic bằng tổng của 2 dãy trừ đi a[i]
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, a[105], sum_first[105], sum_last[105];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void solve(){ //hàm xử lý
    sum_first[0] = a[0], sum_last[n - 1] = a[n - 1]; //khởi tạo giá trị ban đầu
    for (int i = 1; i < n; i ++) { //tính tổng dãy con tăng từ trái qua
        sum_first[i] = a[i];
        for (int j = 0; j < i; j ++)
            if (a[i] > a[j]) sum_first[i] = max(sum_first[i], sum_first[j] + a[i]);
    }
    for (int i = n - 2; i >= 0; i --) { //tính tổng dãy con tăng từ phải qua
        sum_last[i] = a[i];
        for (int j = n - 1; j > i; j --)
            if (a[i] > a[j]) sum_last[i] = max(sum_last[i], sum_last[j] + a[i]);
    }
    int res=0; //khởi tạo kết quả
    for (int i = 0; i < n; i ++) res = max(sum_first[i] + sum_last[i] - a[i], res); //tìm max của các dãy
    cout << res << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
168. DSA05022	KÝ TỰ GIỐNG NHAU
/*Giả sử bạn cần viết N ký tự giống nhau lên màn hình. Bạn chỉ được phép thực hiện ba thao tác dưới đây với chi phí thời
gian khác nhau:
Thao tác insert: chèn một ký tự với thời gian là X.
Thao tác delete: loại bỏ ký tự cuối cùng với thời gian là Y.
Thao tác copying: copy và paste tất cả các ký tự đã viết để số ký tự được nhân đôi với thời gian là Z.
Hãy tìm thời gian ít nhất để có thể đưa ra màn hình N ký tự giống nhau. Ví dụ với N = 9, X =1, Y = 2, Z =1 ta có kết quả
là 5 bằng cách thực hiện: insert, insert, copying, copying, insert.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên đưa vào N là số các ký tự giống nhau cần
viết lên màn hình; dòng tiếp theo đưa vào bộ ba số X, Y, Z tương ứng với thời gian thực hiện ba thao tác; các số được
viết cách nhau một vài khoảng trống.
T, N, X, Y, Z thỏa mãn ràng buộc: 1≤T≤100;  1≤N ≤100; 1≤X, Y, Z ≤100.
Output:
Đưa ra kết quả mỗi test theo từng dòng
Input                 Output
2
9                     5
1 2 1
10                    14
2 5 4
*/
/*Ý tưởng: nếu n chẵn thì dp[n] bằng min của dp[n-1]+insert với dp[n/2] + copy, nếu n lẻ thì dp[n]=dp[n/2-1]+copy+insert
với dp[n/2+1]+copy+del*/
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, ins, del, cop, dp[105];

void init() { //hàm khởi tạo
    cin >> n >> ins >> del >> cop;
}

void solve() {
    dp[0] = 0; //khởi tạo 2 giá trị ban đầu
    dp[1] = ins;
    for (int i = 2; i <= n; i++) {
        if (i % 2 == 0) dp[i] = min (dp[i - 1] + ins, dp[i / 2] + cop); //cập nhật kết quả với n chẵn và lẻ
        else dp[i] = min (dp[i - 1] + ins, dp[(i + 1) / 2] + cop + del);
    }
    cout << dp[n] << endl; //đưa ra kết quả
}


int main() {
    int t;
    cin >> t;
    while (t --) {
        init();
        solve();
    }
    return 0;
}
169. DSA05023	TỔNG CÁC XÂU CON
/*Cho số nguyên dương N được biểu diễn như một xâu ký tự số. Nhiệm vụ của bạn là tìm tổng của tất cả các số tạo bởi các
xâu con của N. Ví dụ N=”1234” ta có kết quả là 1670 = 1 + 2 + 3 + 4 + 12 + 23 + 34 + 123 + 234 + 1234.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một số N.
T, N thỏa mãn ràng buộc: 1≤T≤100;  1≤N ≤10^12.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
2
1234                  1670
421                   491
*/
//Ý tưởng: vét cạn
//Code:

#include <bits/stdc++.h>
using namespace std;

string str;
long long res, tmp;

void init() { //hàm khởi tạo
    cin >> str;
}

void solve() { //hàm xử lý
    res=0; //khởi tạo kết quả
    for (int i = 0; i < str.length (); i++) //i là số chữ số của số hiện tại
        for (int j = 0; j < str.length () - i; j++) {
            tmp = 0;
            for (int k = j; k <= j + i; k++) tmp = tmp * 10 + (str[k] - 48); //tạo từng số
            res += tmp; //cập nhật kết quả
        }
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
170. DSA05024	TỔNG BẰNG K
/*Cho một mảng A[] gồm N số nguyên và số K. Tính số cách lấy tổng các phần tử của A[] để bằng K. Phép lấy lặp các phần
tử hoặc sắp đặt lại các phần tử được chấp thuận. Ví dụ với mảng A[] = {1, 5, 6}, K = 7 ta có 6 cách sau:
7 = 1 + 1 + 1+1 + 1 + 1+1 (lặp số 1 7 lần)
7 = 1 + 1 + 5 (lặp số 1)
7 = 1 + 5 + 1 (lặp và sắp đặt lại số 1
7 = 1 + 6
7 = 6 + 1
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất đưa vào N và K; dòng tiếp theo đưa vào N
số của mảng A[]; các số được viết cách nhau một vài khoảng trống.
T, N, K, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤N≤1000; 1≤A[i]≤100.
Output:
Đưa ra kết quả mỗi test theo từng dòng. Khi kết quả quá lớn đưa ra kết quả dưới dạng modulo với 10^9+7.
Input                 Output
2
3 7                   6
1 5 6
4 14                  150
12 3 1 9
*/
//Ý tưởng: nếu phần tử a[j]<= tổng i thì số cặp bằng số cặp hiện tại cộng với số cặp của tổng i-a[j]
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, k;
long m=1e9+7, a[1005], dp[1005];

void init() { //hàm khởi tạo
    cin >> n >> k;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void solve() {
    memset (dp, 0, sizeof (dp)); //khởi tạo lại kết quả
    dp[0] = 1;
    for (int i = 1; i <= k; i++) //i thể hiện tổng
        for (int j = 0; j < n; j++)
            if (i >= a[j]) dp[i] = (dp[i] + dp[i - a[j]]) % m; //cập nhật kết quả
    cout << dp[k] << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t --) {
        init();
        solve();
    }
    return 0;
}
171. DSA05007	TỔNG LỚN NHẤT CỦA DÃY CON KHÔNG KỀ NHAU
/*Cho dãy số A[] gồm N phần tử. Hãy tìm tổng lớn nhất của dãy con của dãy số A[] sao cho dãy con không có hai số cạnh
nhau trong A[]. Ví dụ với A[] = {6, 7, 1, 3, 8, 2, 4} ta có kết quả là 19 tương ứng với tổng của dãy con {6, 1, 6, 4}
không có haI phần tử nào kề nhau trong A[].
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất là một số N; dòng tiếp theo đưa vào N số
A[i]; các số được viết cách nhau một vài khoảng trống.
T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤N ≤106; 1≤A[i] ≤107.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
2
6                     110
5 5 10 100 10 5
4                     13
3 2 7 10
*/
//Ý tưởng: tổng lớn nhất nếu chọn a[i] bằng max của tổng lớn nhất khi chọn a[i-1] với a[i-2] cộng với a[i]
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, a[1000005];
long long dp[1000005];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    dp[0] = a[0], dp[1] = a[1], dp[2] = a[0] + a[2]; //khởi tạo giá trị ban đầu
    for (long i = 3; i < n; i++) dp[i] = max (dp[i - 2], dp[i - 3]) + a[i]; //cập nhật kết quả
    cout << max (dp[n - 1], dp[n - 2]) << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
172. DSA05028	BIẾN ĐỔI XÂU
/*Cho hai xâu ký tự str1, str2 bao gồm các ký tự in thường và các thao tác dưới đây:
Insert: chèn một ký tự bất kỳ vào str1.
Delete: loại bỏ một ký tự bất kỳ trong str1.
Replace: thay một ký tự bất kỳ trong str1.
Nhiệm vụ của bạn là đếm số các phép Insert, Delete, Replace ít nhất thực hiện trên str1 để trở thành str2.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là bộ đôi hai xâu str1 và str2.
T, str1, str2 thỏa mãn ràng buộc: 1≤T≤100;  1≤length(str1),length(str2) ≤100.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
1
geek gesek            1
*/
/*Ý tưởng: nếu 1 xâu rỗng thì số phép biến đổi bằng độ dài của xâu còn lai, nếu 2 ký tự của xâu giống nhau thì số phép
biến đổi bằng số phép biến đổi của xâu trước đó của 2 xâu +1, nếu 2 ký tự khác nhau thì số phép biến đổi bằng min số phép
biến đổi của trước đó của 2 xâu với số phép biến đổi của xâu trước đó của xâu 1 + 1 với số phép biến đổi của xâu trước
xâu 2 + 1*/
//Code:

#include <bits/stdc++.h>
using namespace std;

string s1, s2;
int n, m, dp[105][105];

void init() { //hàm khởi tạo
    cin >> s1 >> s2;
    n = s1.length (), m = s2.length ();
}

void solve() { //hàm xử lý
    for (int i = 0; i <= n; i++) //cập nhật kết quả theo công thức quy hoạch động
        for (int j = 0; j <= m; j++) {
            if (i == 0 || j == 0) dp[i][j] = i + j;
            else if (s1[i - 1] == s2[j - 1]) dp[i][j] = dp[i - 1][j - 1];
            else dp[i][j] = min (dp[i - 1][j - 1], min (dp[i - 1][j], dp[i][j - 1])) + 1;
        }
    cout << dp[n][m] << endl;
}

int main() {
    int t;
    cin >> t;
    cin.ignore ();
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
173. DSA05031	TỔNG BÌNH PHƯƠNG
/*Mọi số nguyên dương N đều có thể phân tích thành tổng các bình phương của các số nhỏ hơn N. Ví dụ số 100 = 102 hoặc
100 = 52 + 52 + 52 + 52. Cho số nguyên dương N. Nhiệm vụ của bạn là tìm số lượng ít nhất các số nhỏ hơn N mà có tổng
bình phương bằng N.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi test là một số tự nhiên N được viết trên 1 dòng.
T, N thỏa mãn ràng buộc: 1≤T≤100;  1≤N≤10000.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
3
100                   1
6                     3
25                    1
*/
/*Ý tưởng: số các số nhỏ nhất tại tổng i bằng min của giá trị hiện tại với giá trị tại tổng của i-a[j]*a[j] + 1(thực
hiện cộng với bình phương của phần tử a[j]*/
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, dp[10005];

void init() { //hàm khởi tạo
    cin >> n;
}

void solve() { //hàm xử lý
    for (int i = 1; i <= 10000; i++) {
        dp[i] = i;
        for (int j = 1; j <= sqrt (i); j++) dp[i] = min (dp[i], dp[i - j * j] + 1); //cập nhật kết quả
    }
}

void print() { //hàm đưa ra kết quả
    cout << dp[n] << endl;
}

int main() {
    int t;
    cin >> t;
    solve ();
    while (t--) {
        init ();
        print ();
    }
    return 0;
}
174. DSA07008	BIẾN ĐỔI TRUNG TỐ - HẬU TỐ
/*Hãy viết chương trình chuyển đổi biểu thức biểu diễn dưới dạng trung tố về dạng hậu tố.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T;
Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test là một biểu thức tiền tố exp.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Ràng buộc:
T, exp thỏa mãn ràng buộc: 1≤T≤100; 2≤length(exp)≤10.
Input                 Output
2
(A+(B+C)              ABC++
((A*B)+C)             AB*C+
*/
/*Ý tưởng: tạo 1 hàm so sánh mức độ ưu tiên của các phần tử sau đó đưa ra kết quả theo mức độ ưu tiên với 2 phần tử ở
đỉnh của ngăn xếp rồi đẩy nó lại vào ngăn xếp*/
//Code:

#include <bits/stdc++.h>
using namespace std;

string str;

int comp(char x) { //hàm so sánh mức độ ưu tiên của phần tử
    if (x == '(') return 1;
    else if (x == '+' || x == '-') return 2;
    else if (x == '*' || x == '/') return 3;
    else return 4;
}

void init() { //hàm khởi tạo
    cin >> str;
}

void solve() { //hàm xử lý
    stack <char> s; //ngăn xếp lưu chữ các phần tử
    for (int i = 0; i < str.length (); i++) {
        if (str[i] >= 65 && str[i] <= 90 || str[i] >= 97 && str[i] <= 122) cout << str[i]; //gặp toán hạng in luôn
        else if (str[i] == '(') s.push (str[i]); //nếu gặp dấu ( đẩy vào stack
        else if (str[i] == ')') { //nếu gặp dấu ) tức là đã hết 1 biểu thức con
            while (!s.empty () && s.top () != '(') {
                cout << s.top (); //in ra toán tử tương ứng
                s.pop ();
            }
            s.pop (); //xoá dấu ( do đã in ra biểu thức con tương ứng rồi
        } else {
            while (!s.empty () && comp (s.top ()) >= comp (str[i])) { //kiểm tra mức độ ưu tiên
                cout << s.top (); //toán tử nào có độ ưu tiên cao hơn thì in trước
                s.pop ();
            }
            s.push (str[i]); //đẩy toán tử hiện tại vào stack
        }
    }
    while (!s.empty ()  && s.top () != '(') { //in ra nốt các toán tử còn lại
        cout << s.top ();
        s.pop ();
    }
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
175. DSA07011	BIẾN ĐỔI HẬU TỐ - TIỀN TỐ
/*Hãy viết chương trình chuyển đổi biểu thức biểu diễn dưới dạng hậu tố về dạng tiền tố.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T;
Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test là một biểu thức tiền tố exp.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Ràng buộc:
T, exp thỏa mãn ràng buộc: 1≤T≤100; 2≤length(exp)≤106.
Input                 Output
2
AB+CD-*               *+AB-CD
ABC/-AK/L-*           *-A/BC-/AKL
*/
//Ý tưởng: tmp = x + OP1 + OP2 với toán hạng vào ngăn xếp trước là OP1, vào sau là OP2
//Code:

#include <bits/stdc++.h>
using namespace std;

bool isOperator(char x) { //hàm kiểm tra toán tử
    if (x == '+' || x == '-' || x == '*' || x == '/') return true;
    return false;
}

string str;

void init() { //hàm khởi tạo
    getline (cin, str);
}

void solve() { //hàm xử lý
    stack <string> s; //stack lưu các toán hạng, khi biến đổi hết chỉ tồn tại 1 toán hạng đó là kết quả
    for (int i = 0; i < str.length (); i++) {
        if (isOperator (str[i])) { //nếu là toán tử
            string str1 = s.top (); //lấy ra 2 phần tử ở đỉnh của ngăn xếp
            s.pop ();
            string str2 = s.top ();
            s.pop ();
            string tmp = str[i] + str2 + str1; //áp dụng công thức để tạo biểu thức con
            s.push (tmp); //đẩy biểu thức tìm được vào ngăn xếp
        } else {
            string tmp = ""; //nếu gặp toán hạng thì đẩy nó vào ngăn xếp
            s.push (tmp + str[i]);
        }
    }
    cout << s.top () << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    cin.ignore ();
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
176. DSA07012	BIẾN ĐỔI HẬU TỐ - TRUNG TỐ
/*Hãy viết chương trình chuyển đổi biểu thức biểu diễn dưới dạng hậu tố về dạng trung tố.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T;
Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test là một biểu thức tiền tố exp.
T, exp thỏa màng ràng buộc: 1≤T≤100; 2≤length(exp)≤106.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Ràng buộc:
T, exp thỏa mãn ràng buộc: 1≤T≤100; 2≤length(exp)≤10^6.
Input                 Output
2
ABC++                 (A+(B+C)
AB*C+                 ((A*B)+C)
*/
//Ý tưởng: tmp = ( + OP1 + x + OP2 ) với toán hạng vào ngăn xếp trước là OP1, vào sau là OP2
//Code:

#include <bits/stdc++.h>
using namespace std;

bool isOperator(char x) { //hàm kiểm tra toán tử
    if (x == '+' || x == '-' || x == '*' || x == '/') return true;
    return false;
}

string str;

void init() { //hàm khởi tạo
    getline (cin, str);
}

void solve() { //hàm xử lý
    stack <string> s; //ngăn xếp chứa các toán hạng
    for (int i = 0; i < str.length (); i++) {
        if (isOperator (str[i])) { //nếu tìm thấy toán tử
            string str1 = s.top (); //lấy 2 phần tử ở đỉnh stack
            s.pop ();
            string str2 = s.top ();
            s.pop ();
            string tmp = "(" + str2 + str[i] + str1 + ")"; //sử dụng công thức cập nhật kết quả
            s.push (tmp); //đẩy biểu thức con vào ngăn xếp
        } else { //nếu gặp toán hạng thì đẩy nó vào ngăn xếp
            string tmp = "";
            s.push (tmp + str[i]);
        }
    }
    cout << s.top () << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    cin.ignore ();
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
177. DSA07016	BIỂU THỨC TĂNG GIẢM
/*Cho dãy ký tự S chỉ bao gồm các ký tự I hoặc D. Ký tự I được hiểu là tăng (Increasing) ký tự D được hiểu là giảm
(Decreasing). Sử dụng các số từ 1 đến 9, hãy đưa ra số nhỏ nhất được đoán nhận từ S. Chú ý, các số không được phép lặp
lại. Dưới đây là một số ví dụ mẫu:
A[] = “I”              : số tăng nhỏ nhất là 12.
A[] = “D”            : số giảm nhỏ nhất là 21
A[] =”DD”           : số giảm nhỏ nhất là 321
A[] = “DDIDDIID”: số thỏa mãn 321654798
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test là một xâu S
T, S thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ length(S) ≤8; .
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
4
I                     12
D                     21
DD                    321
DDIDDIID              321654798
*/
// Ý tưởng: thêm chỉ mục vào ngăn xếp, gặp I hoặc đến chỉ mục cuối thì in các chỉ mục ra
//Code:

#include <bits/stdc++.h>
using namespace std;

string str;

void init() { //hàm khởi tạo
    cin >> str;
}

void solve() { //hàm xử lý
    stack <int> s; //stack lưu các chỉ mục
    for (int i = 0; i <= str.length (); i++) {
        s.push (i + 1); //thêm chỉ mục vào stack
        if (i == str.length () || str[i] == 'I') { //nếu ngặp I hoặc duyệt đến cuối
            while (!s.empty ()) {
                cout<<s.top(); //in ra các chỉ mục
                s.pop ();
            }
        }
    }
    cout<<endl;
}
int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
178. DSA07017	PHẦN TỬ BÊN PHẢI NHỎ HƠN
/*Cho mảng A[] gồm n phần tử. Hãy đưa ra các phần tử nhỏ hơn tiếp theo của phần tử lớn hơn đầu tiên phần tử hiện tại.
Nếu phần tử hiện tại không có phần tử lớn hơn tiếp theo ta xem là -1. Nếu phần tử không có phần tử nhỏ hơn tiếp theo ta
cũng xem là -1. Ví dụ với mảng A[] = {5, 1, 9, 2, 5, 1, 7} ta có kết quả là ans = {2, 2, -1, 1, -1, -1, -1} vì:
Next Greater                         Right Smaller
5          ->  9                                        9  ->  2
1          ->  9                                        9  ->  2
9          -> -1                                       -1  -> -1
2          ->  5                                        5  -> 1
5          ->  7                                        7  -> -1
1          ->  7                                        7  -> -1
7          -> -1                                        7  -> -1
Input:
Dòng đầu tiên đưa vào số lượng bộ test T;
Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất đưa vào n là số phần tử của
mảng A[], dòng tiếp theo đưa vào n số A[i].
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Ràng buộc:
T, n, A[i] thỏa mãn ràng buộc: 1≤T≤100; 1≤n, A[i] ≤10^6.
Input                 Output
2
7                     2 2 1 1 -1 -1 -1
5 1 9 2 5 1 7
8                     2 5 5 5 -1 3 -1 -1
4 8 2 1 9 5 6 3
*/
//Ý tưởng:
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, a[100005];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    int bg[n]; //mảng lưu chỉ mục phần tử lớn
    int sm[n]; //mảng lưu chỉ mục phần tử nhỏ
    stack <int> s;
    for (int i = n - 1; i >= 0; i--) { //tìm phần tử bên phải đầu tiên lớn hơn
        while (!s.empty () && a[i] >= a[s.top ()]) s.pop (); //tìm trong ngăn xếp phần tử đầu tiên lớn hơn
        if (!s.empty ()) bg[i] = s.top (); //nếu tìm thấy gán đó là phần tử lớn hơn phần tử tại vị trí i
        else bg[i] = -1; //nếu không tìm thấy gán -1
        s.push (i); //đẩy phần tử hiện tại vào ngăn xếp
    }
    while (!s.empty ()) s.pop (); //làm mới ngăn xếp
    for (int i = n - 1; i >= 0; i--) { //tìm phần tử nhỏ hơn đầu tiên ở bên phải
        while (!s.empty () && a[i] <= a[s.top ()]) s.pop (); //tìm trong ngăn xếp phần tử đầu tiên nhỏ hơn
        if (!s.empty ()) sm[i] = s.top (); //nếu tìm thấy gán đó là phần tử nhỏ hơn phần tử tại vị i
        else sm[i] = -1; //nếu không tìm thấy gán -1
        s.push (i); //đẩy phần tử hiện tại vào ngăn xếp
    }
    for (int i = 0; i < n; i++) { //đưa ra kết quả
        if (bg[i] != -1 && sm[bg[i]] != -1) cout << a[sm[bg[i]]] << " ";
        else cout << "-1" << " ";
    }
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
179. DSA07029	GIẢI MÃ XÂU KÝ TỰ
/*Cho xâu ký tự mã hóa str. Hãy viết chương trình giải mã xâu ký tự str. Xâu ký tự mã hóa được thực hiện theo số lần lặp
các xâu con của str như sau:
Xâu đầu vào: “abbbababbbababbbab ”
Xâu mã hóa : "3[a3[b]1[ab]]"
Input:
Dòng đầu tiên đưa vào số lượng bộ test T;
Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test là một xâu mã hóa str được viết trên một dòng.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Ràng buộc:
T, str thỏa mãn ràng buộc: 1≤T≤100; 1≤length(str)≤100.
Input                 Output
2
1[b]                  b
3[b2[ca]]             bcacabcacabcaca
*/
/*Ý tưởng: tạo 2 ngăn xếp lưu xâu và giá trị tương ứng, nếu gặp dấu ] bắt đầu giải mã rồi đẩy xâu đã giải mã rồi vào
ngăn xếp*/
//Code:

#include <bits/stdc++.h>
using namespace std;

string str;

void init() { //hàm khởi tạo
    getline (cin, str);
}

void solve() { //hàm xử lý
    int val = 0;
    string tmp = "";
    stack <int> s;
    stack <string> stk;
    string res = "";
    for (int i = 0; i < str.length (); i++) {
        if (isdigit (str[i])) val = val * 10 + (str[i] - 48); //chuyển giá trị sang kiểu int
        else if (isalpha (str[i])) { //nếu gặp chữ cái thêm nó vào xâu trung gian hiện tại
            tmp += str[i];
            if (!isalpha (str[i + 1])) { //khi hết xâu trung gian đẩy xâu đó vào ngăn xếp
                stk.push (tmp);
                tmp = ""; //khởi tạo lại giá trị của xâu trung gian
            }
        } else if (str[i] == '[') {
            if (val != 0) s.push (val); //đẩy giá trị vào ngăn xếp
            else s.push (1); //lưu ý trường hợp không có giá trị trước dấu [ thì ta lấy giá trị là 1
            val = 0; //khởi tạo lại giá trị
        } else if (str[i] == ']') { //nếu gặp dấu ] thực hiện giải mã
            int x = s.top (); //lấy giá trị của xâu hiện tại ra
            while (x--) tmp += stk.top (); //tạo ra x xâu hiện tại
            stk.pop (); //xoá xâu hiện tại khỏi ngăn xếp
            string a = "";
            if (!stk.empty ()) { //nếu ngăn xếp không rỗng lấy ra xâu ở đỉnh
                a += stk.top ();
                stk.pop ();
            }
            a += tmp; //ghép xâu đó với xâu vừa tạo thành
            stk.push (a); //đẩy xâu tạo thành vào ngăn xếp
            s.pop (); //xoá giá trị đã giải mã khỏi ngăn xếp
            tmp = ""; //khởi tạo lại xâu trung gian
            if (s.empty ()) {
                res += stk.top (); //cập nhật kết quả
                stk.pop ();
            }
        }
    }
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    cin.ignore();
    while (t --) {
        init();
        solve();
    }
    return 0;
}
180. DSA08004	GIÁ TRỊ NHỎ NHẤT CỦA XÂU
/*Cho xâu ký tự S. Ta gọi giá trị của xâu S là tổng bình phương số lần xuất hiện mỗi ký tự trong S. Hãy tìm giá
trị nhỏ nhất của xâu S sau khi thực hiện K lần loại bỏ ký tự.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất là số K; phần thứ hai là một xâu
ký tự S được viết trên một dòng.
T, S, K thỏa mãn ràng buộc: 1≤T≤100;  1≤length(S)≤10000; 1≤K≤1000.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
2
ABCCBC               6
2
AAAB                 2
*/
//Ý tưởng: sử dụng hàng đợi ưu tiên, xoá dần đi 1 phần tử có số lần xuất hiện lớn nhất
//Code:

#include <bits/stdc++.h>
using namespace std;

int k, cnt[30];
string str;
priority_queue <int> q;


void init() { //hàm khởi tạo
    cin >> k;
    cin >> str;
}

void solve() { //hàm xử lý
    memset (cnt, 0, sizeof (cnt)); //làm mới mảng đếm
    long long res = 0;
    for (int i = 0; i < str.length (); i++) cnt[str[i] - 'A']++; //đếm số lần xuất hiện của các phần tử
    for (int i = 0; i < 26; i++)
        if (cnt[i]) q.push (cnt[i]); //đẩy số lần xuất hiện của các phần tử vào hàng đợi
    while (k--) {
        int tmp = q.top () - 1; //thực hiện trừ
        q.pop ();
        q.push (tmp);
    }
    while (!q.empty ()) {
        res += pow (q.top (), 2); //cập nhật kết quả
        q.pop ();
    }
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
181. DSA08009	BIẾN ĐỔI S – T
/*Cho hai số nguyên dương S và T (S, T<10000) và hai thao tác (a), (b) dưới đây:
Thao tác (a): Trừ S đi 1  (S = S-1) ;
Thao tác (b): Nhân S với 2 ( S = S*2);
Hãy dịch chuyển S thành T sao cho số lần thực hiện các thao tác (a), (b) là ít nhất. Ví dụ với    S =2, T=5 thì số các
bước ít nhất để dịch chuyển S thành T thông qua 4 thao tác sau:
Thao tác (a): 2*2 = 4;
Thao tác (b): 4-1 = 3;
Thao tác (a): 3*2 = 6;
Thao tác (b): 6-1 = 5;
Input:
Dòng đầu tiên ghi lại số tự nhiên T là số lượng Test;
T dòng kế tiếp mỗi dòng ghi lại một bộ Test. Mỗi test là một bộ đôi S và T.
Output: Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
3
2 5                   4
3 7                   4
7 4                   3
*/
//Ý tưởng: Ứng dụng bfs duyệt qua mỗi số 1 lần duy nhất đến khi tìm được T
//Code: 

#include <bits/stdc++.h>
using namespace std;

int S, T;

void init() { //hàm khởi tạo
    cin >> S >> T;
}

int bfs() { //hàm bfs
    set <int> s; //khai báo 1 set (tập hợp lưu trữ các phần tử không trùng lặp)
    queue <pair <int, int> > q; //khai báo hàng đợi với .first là giá trị và .second là số lần biến đổi
    q.push ({S, 0});
    while (!q.empty ()) {
        int val = q.front ().first;
        int cnt = q.front ().second;
        if (val - 1 == T || val * 2 == T) return cnt + 1; //nếu tìm được T trả về kết quả
        if (s.find (val * 2) == s.end () && val < T) { //nếu không tìm được T và số mới chưa được thăm thì thêm vào
            q.push ({val * 2, cnt + 1});
            s.insert (val * 2);
        }
        if (s.find (val - 1) == s.end () && val > 1) {  //nếu không tìm được T và số mới chưa được thăm thì thêm vào
            q.push ({val - 1, cnt + 1});
            s.insert (val - 1);
        }
        q.pop (); //xoá số đã thăm khỏi hàng đợi
    }
}

void solve() { //hàm xử lý
    cout << bfs () << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
182. DSA09009	TÌM SỐ THÀNH PHẦN LIÊN THÔNG VỚI BFS
/*Cho đồ thị vô hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy tìm số thành phần liên thông của đồ thị bằng
thuật toán BFS.
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào hai số |V|, |E| tương ứng với số
đỉnh và số cạnh; Dòng tiếp theo đưa vào các bộ đôi uÎV, vÎV tương ứng với một cạnh của đồ thị.
T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra số thành phần liên thông của đồ thị bằng thuật toán BFS.
Input                    Output
1
6  6                     2
1 2 1 3 2 3 3 4 3 5 4 5
*/
//Ý tưởng: duyệt qua các đỉnh nếu chưa được thăm thì gọi bfs tại đỉnh đó, khi duyệt hết tức là đã tạo 1 tplt
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, vs[1005];
vector <int> a[1005];

void bfs(int u) { //hàm bfs
    vs[u] = 1; //đánh dấu đỉnh đã được thăm
    queue <int> q;
    q.push (u);
    while (!q.empty ()) {
        u = q.front (); //lấy ra đỉnh ở đầu hàng đợi
        q.pop ();
        for (int i = 0; i < a[u].size (); i++) { //kiểm tra tất cả các đỉnh chưa thăm kề với đỉnh u
            int tmp = a[u][i];
            if (!vs[tmp]) {
                vs[tmp] = 1; //nếu tìm thấy thêm vào hàng đợi
                q.push (tmp);
            }
        }
    }
}

void init() { //hàm khởi tạo
    cin >> v >> e;
    memset (a, 0, sizeof (a));
    while (e--) {
        int i, j;
        cin >> i >> j;
        a[i][j] = 1; //tạo ma trận kề
        a[j][i] = 1;
    }
}

void solve() { //hàm xử lý
    memset (vs, 0, sizeof (vs));
    cnt = 0; //khởi tạo số thành phần liên thông bằng 0
    for (int i = 1; i <= v; i++) {
        if (vs[i] == 0) {
            cnt++; //tăng số thành phần liên thông
            bfs (i); //gọi dfs tại đỉnh chưa được thăm
        }
    }
    cout << cnt << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
183. KIỂM TRA TÍNH LIÊN THÔNG MẠNH VỚI BFS
/*Cho đồ thị có hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Sử dụng thuật toán BFS, hãy kiểm tra xem đồ thị
có liên thông mạnh hay không?
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào hai số |V|, |E| tương ứng với số
đỉnh và số cạnh; Dòng tiếp theo đưa vào các bộ đôi uÎV, vÎV tương ứng với một cạnh của đồ thị.
T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra “YES”, hoặc “NO” theo từng dòng tương ứng với test là liên thông mạnh hoặc không liên thông mạnh.
Input                                Output
1
6 9                                  YES
1 2 2 4 3 1 3 2 3 5 4 3 5 4 5 6 6  3
*/
//Ý tưởng: duyệt mọi đỉnh đều cho 1 đồ thị liên thông
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, vs[1005];
vector <int> a[1005];

int bfs(int u, int cnt) { //hàm bfs
    vs[u] = 1; //đánh dấu đã thăm
    queue <int> q;
    q.push(u); //đưa đỉnh u vào hàng đợi
    while (! q.empty()) {
        u = q.front(); //gán u là đỉnh ở đầu hàng đợi
        q.pop();
        for (int i = 0; i < a[u].size(); i ++) { //tìm tất cả các đỉnh chưa được thăm kề với đỉnh u
            int tmp = a[u][i];
            if (! vs[tmp]) { //nếu tìm thấy đánh dấu đã được thăm và tăng số đỉnh duyệt được
                vs[tmp] = 1;
                cnt ++;
                q.push(tmp); //đẩy đỉnh đó vào hàng đợi
            }
        }
    }
    return cnt; //trả về số đỉnh duyệt được
}

void init(){ //hàm khởi tạo
    cin >> v >> e;
    while (e--) {
        int i, j;
        cin >> i >> j;
        a[i].push_back (j); //tạo ma trận kề
    }
}

void solve() { //hàm xử lý
    int check = 1; //đánh dấu đã duyệt được
    for (int i = 1; i <= v; i++) {
        memset (vs, 0, sizeof (vs)); //đánh dấu tất cả đỉnh chưa được thăm
        if (bfs (i, 1) != v) { //nếu duyệt không đủ v đỉnh tức là không liên thông
            check = 0; //đánh dấu không liên thông mạnh
            break;
        }
    }
    if (check) cout << "YES" << endl; //đưa ra kết quả
    else cout << "NO" << endl;
    for (int i = 1; i <= v; i++) a[i].clear (); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
184. DSA09012	LIỆT KÊ ĐỈNH TRỤ VỚI BFS
/*Cho đồ thị vô hướng liên thông G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy đưa ra tất cả các đỉnh trụ của đồ
thị?
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào hai số |V|, |E| tương ứng với số
đỉnh và số cạnh; Dòng tiếp theo đưa vào các bộ đôi uÎV, vÎV tương ứng với một cạnh của đồ thị.
T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra danh sách các đỉnh trụ của mỗi test  theo từng dòng.
Input                 Output
1
5 5                   2 3
1 2 1 3 2 3 2 5 3 4
*/
//Ý tưởng: đỉnh trụ là khi xóa u và các cạnh liên thuộc sẽ tạo ra một đồ thị mới có nhiều thành phần liên thông hơn G.
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, res, vs[1005];
vector <int> a[1005];

void reset() { //hàm làm mới
    for (int i = 1; i <= v; i++) vs[i] = 0; //đánh dấu tất cả các đỉnh chưa được thăm
    vs[res] = 1; //đánh dấu đỉnh hiện tại đã đươc thăm coi như đã xoá đỉnh hiện tại
}

void bfs(int u) { //hàm bfs
    vs[u] = 1; //đánh dấu đỉnh đã được thăm
    queue <int> q;
    q.push (u);
    while (!q.empty ()) {
        u = q.front (); //lấy ra đỉnh ở đầu hàng đợi
        q.pop ();
        for (int i = 0; i < a[u].size (); i++) { //kiểm tra tất cả các đỉnh chưa thăm kề với đỉnh u
            int tmp = a[u][i];
            if (!lt[tmp]) {
                vs[tmp] = 1; //nếu tìm thấy thêm vào hàng đợi
                q.push (tmp);
            }
        }
    }
}

void init(){ //hàm khởi tạo
    cin >> v >> e;
    while (e --) {
        int i, j;
        cin >> i >> j;
        a[i].push_back(j); //tạo ma trận kề
        a[j].push_back(i);
    }
}

void solve() { //hàm xử lý
    for (res = 1; res <= v; res++) { //duyệt qua tất cả các đỉnh
        reset (); //gọi hàm làm mới
        if (res == 1) bfs (2); //nếu là đỉnh 1 thì tìm bfs tại đỉnh 2 do xoá đỉnh 1
        else bfs (1); //nếu khác 1 thì gọi tại 1
        for (int i = 1; i <= v; i++) {
            if (!vs[i]) {
                cout << res << " "; //nếu đồ thị mới không liên thông thì đỉnh nó là đỉnh trụ
                break;
            }
        }
    }
    for (int i = 1; i <= v; i++) a[i].clear (); //làm mới ma trận kề
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
185. 	DSA09014	KIỂM TRA CHU TRÌNH VỚI BFS
/*Cho đồ thị vô hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Sử dụng thuật toán BFS, hãy kiểm tra xem đồ thị
có tồn tại chu trình hay không?
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào hai số |V|, |E| tương ứng với số đỉnh,  số cạnh của đồ thị; Dòng tiếp theo đưa vào các bộ đôi uÎV, vÎV tương ứng với một cạnh của đồ thị.
T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra YES hoặc “NO” kết quả test theo từng dòng tương ứng với đồ thị tồn tại hoặc không tồn tại chu trình.
Input                                 Output
1
6  9                                  YES
1 2 1 3 2 3 2 5 3 4 3 5 4 5 4 6 5 6
*/
//Ý tưởng: tạo mảng đỉnh trước, nếu duyệt đến 1 đỉnh được thăm mà đỉnh trước đó khác đỉnh hiện tại thì tồn tại chu trình
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, check, previous[1005], vs[1005];
vector <int> a[1005];

void bfs(int u) { //hàm bfs
    queue <int> q;
    q.push (u); //thêm u vào hàng đợi
    vs[u] = 1; //đánh dấu u đã được thăm
    while (!q.empty ()) {
        u = q.front (); //gán u là đỉnh đầu của hàng đợi
        q.pop ();
        for (int i = 0; i < a[u].size (); i++) { //duyệt tất cả các đỉnh kề với u
            int tmp = a[u][i];
            if (vs[tmp] == 0) { //nếu chưa được thăm
                q.push (tmp); //đẩy vào hàng đợi
                vs[tmp] = 1; //đánh dấu đã thăm
                previous[tmp] = u; //đánh dấu đỉnh trước nó là đỉnh u
            } else if (vs[tmp] == 1 && tmp != previous[u]) { //nếu đã được thăm và đinh trước nó khác đỉnh u
                check = 1; //tồn tại chi trình
                return;
            }
        }
    }
}

void init() { //hàm khởi tạo
    cin >> v >> e;
    while (e--) {
        int x, y;
        cin >> x >> y;
        a[x].push_back (y); //tạo ma trận kề
        a[y].push_back (x);
    }
}

void solve(){ //hàm xử lý
    check = 0; //đánh dấu không có chu trình
    memset(vs, 0, sizeof(vs)); //gán tất cả các đỉnh chưa được thăm
    memset(previous,0,sizeof(previous)); //gán tất cả chưa có đỉnh trước
    for (int i = 1; i <= v; i ++) {
        if (! vs[i]) bfs(i); //duyệt bfs tại từng đỉnh chưa được thăm
        if (check) break; //nếu đã có chu trình thì dừng lại
    }
    if (check) cout << "YES" << endl; //đưa ra kết quả
    else cout << "NO" << endl;
    for (int i = 1; i <= v; i ++) a[i].clear(); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
186. DSA10003	KIỂM TRA CHU TRÌNH SỬ DỤNG DISJOIN SET
/*Cho đồ thị vô hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Sử dụng Disjoin Set, hãy kiểm tra xem đồ thị có
tồn tại chu trình hay không?
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào hai số |V|, |E| tương ứng với số
đỉnh,  số cạnh của đồ thị; Dòng tiếp theo đưa vào các bộ đôi uÎV, vÎV tương ứng với một cạnh của đồ thị.
T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra YES hoặc “NO” kết quả test theo từng dòng tương ứng với đồ thị tồn tại hoặc không tồn tại chu trình.
Input                                   Output
1
6 9                                     YES
1 2 1 3 2 3 2 5 3 4 3 5 4 5 4 6 5 6
*/
//Ý tưởng: nếu x, y cùng thuộc 1 tập con thì nó tồn tại chu trình
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, parent[1005];
vector <pair <int, int> > a;

int find(int i) { //hàm tìm kiếm tập con của 1 phần tử
    if (parent[i] == - 1) return i;
    return find(parent[i]);
}

void Union(int x, int y) { //hàm liên hiệp
    parent[x] = y; //gán x là con của y
}

int isCycle() { //hàm kiểm tra chi trình
    for (int i = 0; i < e; i ++) {
        int x = find(a[i].first);
        int y = find(a[i].second);
        if (x == y) return 1; //nếu x, y có chung cha thì tồn tại chu trình
        Union(x, y); //gọi hàm liên hiệp
    }
    return 0; //trả về 0 nếu không tồn tại chu trình
}

void init(){ //hàm khởi tạo
    cin >> v >> e;
    for (int i = 0; i < e; i ++) {
        int x, y;
        cin >> x >> y;
        a.push_back({x, y}); //tạo ma trận kề
    }
}

void solve() {
    memset (parent, -1, sizeof (parent)); //làm mới mảng cha
    if (isCycle ())cout << "YES" << endl; //đưa ra kết quả
    else cout << "NO" << endl;
    a.clear (); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
187. DSA09016	KIỂM TRA CHU TRÌNH TRÊN ĐỒ THỊ CÓ HƯỚNG VỚI DFS
/*Cho đồ thị có hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Sử dụng thuật toán DFS, hãy kiểm tra xem đồ thị
có tồn tại chu trình hay không?
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào hai số |V|, |E| tương ứng với số
đỉnh,  số cạnh của đồ thị; Dòng tiếp theo đưa vào các bộ đôi uÎV, vÎV tương ứng với một cạnh của đồ thị.
T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra YES hoặc “NO” kết quả test theo từng dòng tương ứng với đồ thị tồn tại hoặc không tồn tại chu trình.
Input                                Output
1
6 9                                  YES
1 2 2 4 3 1 3 2 3 5 4 3 5 4 5 6 6 4
*/
//Ý tưởng: duyệt trong 1 thành phần liên thông nếu duyệt trở lại đỉnh đã duyệt qua rồi thì tồn tại chu trình
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, check ,  vs[1005];
vector <int> a[1005];

void dfs(int u) { //hàm dfs
    if (check) return; //nếu tìm thấy chu trình rồi thì dừng lại
    for (int i = 0; i < a[u].size (); i++) { //tìm tất cả các đỉnh kề với u
        int tmp = a[u][i];
        if (vs[tmp] == 0) { //nếu chưa thăm duyệt dfs tại nó
            vs[tmp] = 1; //đánh dấu nó đã thăm
            dfs (tmp);
            vs[tmp] = 2; //đánh dấu bằng 2 do đã thăm nhưng không tạo chu trình
        } else if (vs[tmp] == 1) { //nếu duyệt tới điểm đã duyệt qua
            check = 1; //đánh dấu tạo chu trình
            return;
        }
    }
}

void init() { //hàm khởi tạo
    cin >> v >> e;
    while (e--) {
        int x, y;
        cin >> x >> y;
        a[x].push_back (y); //tạo ma trận kề
    }
}

void solve() { //hàm xử lý
    check = 0; //đánh dấu không tồn tại chu trình
    memset (vs, 0, sizeof (vs)); //làm mới mảng chưa thăm
    for (int i = 1; i <= v; i++) {
        if (vs[i] == 0) { //nếu đỉnh i chưa thăm
            vs[i] = 1; //gọi dfs tại nó
            dfs (i);
            vs[i] = 2; //đánh dấu bằng 2 do đã thăm nhưng không tạo chu trình
            if (check == 1) break; //nếu đã tìm thấy chu trình thì dừng lại
        }
    }
    if (!check) cout << "NO"; //đưa ra kết quả
    else cout << "YES";
    cout << endl;
    for (int i = 1; i <= v; i++) a[i].clear (); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
188. DSA09015	KIỂM TRA CHU TRÌNH TRÊN ĐỒ THỊ CÓ HƯỚNG VỚI BFS
/*Cho đồ thị có hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Sử dụng thuật toán BFS, hãy kiểm tra xem đồ thị
có tồn tại chu trình hay không?
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào hai số |V|, |E| tương ứng với số
đỉnh,  số cạnh của đồ thị; Dòng tiếp theo đưa vào các bộ đôi uÎV, vÎV tương ứng với một cạnh của đồ thị.
T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra YES hoặc “NO” kết quả test theo từng dòng tương ứng với đồ thị tồn tại hoặc không tồn tại chu trình.
Input                               Output
1
6 9                                 YES
1 2 2 4 3 1 3 2 3 5 4 3 5 4 5 6 6 4
*/
//Ý tưởng: duyệt trong 1 thành phần liên thông nếu duyệt trở lại đỉnh đã duyệt qua rồi thì tồn tại chu trình
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, check, vs[1005];
vector <int> a[1005];

void bfs(int u) { //hàm bfs
    queue <int> q;
    q.push (u); //đẩy u vào hàng đợi
    while (!q.empty ()) {
        u = q.front (); //gán u là đỉnh đầu của hàng đợi
        q.pop ();
        for (int i = 0; i < a[u].size (); i++) { //duyệt tất cả các đỉnh kề với u
            int tmp = a[u][i];
            if (vs[tmp] == 1) { //nếu duyệt qua rồi
                check = 1; //đanh dấu có chu trình
                return;
            } else if (vs[tmp] == 0) q.push (tmp); //nếu chưa duyệt qua thêm vào hàng đợi
            vs[tmp] = 2; //đánh dấu đã duyệt qua nhưng không tạo chu trình
        }
    }
}

void init() { //hàm khởi tạo
    cin >> v >> e;
    while (e--) {
        int x, y;
        cin >> x >> y;
        a[x].push_back (y); //tạo ma trận kề
    }
}

void solve() { //hàm xử lý
    check = 0; //đánh dấu không có chu trình
    for (int i = 1; i <= v; i++) {
        memset (vs, 0, sizeof (vs)); //làm mới mảng chưa thăm
        vs[i] = 1; //đánh dấu đỉnh i đã thăm
        bfs (i); //gọi bfs tại i
        if (check) break; //nếu tồn tại chu trình thì dừng lại
    }
    if (check) cout << "YES" << endl; //đưa ra kết quả
    else cout << "NO" << endl;
    for (int i = 1; i <= v; i++) a[i].clear (); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
189. DSA09017	KIỂM TRA ĐỒ THỊ CÓ PHẢI LÀ CÂY HAY KHÔNG
/*Một đồ thị N đỉnh là một cây, nếu như nó có đúng N-1 cạnh và giữa 2 đỉnh bất kì, chỉ tồn tại duy nhất 1 đường đi giữa
chúng. Cho một đồ thị N đỉnh và N-1 cạnh, hãy kiểm tra đồ thị đã cho có phải là một cây hay không?
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test bắt đầu bởi số nguyên N (1 ≤ N ≤ 1000).
N-1 dòng tiếp theo, mỗi dòng gồm 2 số nguyên u, v cho biết có cạnh nối giữa đỉnh u và v.
Output:
Với mỗi test, in ra “YES” nếu đồ thị đã cho là một cây, in ra “NO” trong trường hợp ngược lại.
Input                 Output
2
4                     YES
1 2
1 3
2 4
4                     NO
1 2
1 3
2 3
*/
//Ý tưởng: kiểm tra tính liên thông nếu liên thông thì là cây
//Code:

#include <bits/stdc++.h>
using namespace std;
int v, vs[1005];
vector <int> a[1005];

void bfs(int u) { //hàm bfs
    vs[u] = 1; //đánh dấu đỉnh u đã thăm
    queue <int> q;
    q.push(u);
    while (! q.empty()) {
        u = q.front(); //gán u là đỉnh ở đầu hàng đợi
        q.pop();
        for (int i = 0; i < a[u].size(); i ++) { //tìm tất cả các đỉnh chưa được thăm kề với u
            int tmp = a[u][i];
            if (! vs[tmp]) { //nếu tìm thấy
                vs[tmp] = 1; //đánh dấu là đã thăm
                q.push(tmp); //đẩy nó vào hàng đợi
            }
        }
    }
}

bool isTree() { //hàm kiểm tra cây
    bfs (1); //nếu duyệt bfs từ gốc ra được tất cả các đỉnh thì là cây
    for (int i = 1; i <= v; i++)
        if (vs[i] == 0) return false;
    return true;
}

void init() { //hàm khởi tạo
    cin >> v;
    for (int i = 0; i < v - 1; i++) {
        int x, y;
        cin >> x >> y;
        a[x].push_back (y); //tạo ma trận kề
        a[y].push_back (x);
    }
}

void solve() { //hàm xử lý
    memset (vs, 0, sizeof (vs)); //làm mới mảng chưa thăm
    if (isTree ()) cout << "YES" << endl; //đưa ra kết quả
    else cout << "NO" << endl;
    for (int i = 1; i <= v; i++) a[i].clear (); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
190. DSA09011	SỐ LƯỢNG HÒN ĐẢO
/*Cho một bản đồ kích thước N x M được mô tả bằng ma trận A[][].A[i][j] = 1 có nghĩa vị trí (i, j) là nổi trên biển. 2
vị trí (i, j) và (x, y) được coi là liền nhau nếu như nó có chung đỉnh hoặc chung cạnh. Một hòn đảo là một tập hợp các
điểm (i, j) mà A[i][j] = 1 và có thể di chuyển giữa hai điểm bất kì trong đó.
Nhiệm vụ của bạn là hãy đếm số lượng đảo xuất hiện trên bản đồ.
Input: Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test bắt đầu bởi 2 số nguyên N và M (1 ≤ N, M ≤ 500).
N dòng tiếp theo, mỗi dòng gồm M số nguyên A[i][j].
Output:  Với mỗi test, in ra số lượng hòn đảo tìm được.
Input                 Output
1
5 5                   5
1 1 0 0 0
0 1 0 0 1
1 0 0 1 1
0 0 0 0 0
1 0 1 0 1
*/
//Ý tưởng: đếm số thành phần liên thông
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, m, res, vs[505][505], a[505][505];

void dfs(int i, int j) { //hàm dfs
    vs[i][j] = 1; //đánh dấu vị trí hiện tại được thăm
    //tìm tất cả các vị trí ở 8 hướng có vị trí nổi và gọi dfs tại vị trí đó
    if (a[i - 1][j] == 1 && i > 1 && vs[i - 1][j] == 0) dfs(i - 1, j);
    if (a[i - 1][j - 1] == 1 && i > 1 && j > 1 && vs[i - 1][j - 1] == 0) dfs(i - 1, j - 1);
    if (a[i - 1][j + 1] == 1 && i > 1 && j < m && vs[i - 1][j + 1] == 0) dfs(i - 1, j + 1);
    if (a[i][j - 1] == 1 && j > 1 && vs[i][j - 1] == 0) dfs(i, j - 1);
    if (a[i][j + 1] == 1 && j < m && vs[i][j + 1] == 0) dfs(i, j + 1);
    if (a[i + 1][j - 1] == 1 && i < n && j > 1 && vs[i + 1][j - 1] == 0) dfs(i + 1, j - 1);
    if (a[i + 1][j] == 1 && i < n && vs[i + 1][j] == 0) dfs(i + 1, j);
    if (a[i + 1][j + 1] == 1 && i < n && j < m && vs[i + 1][j + 1] == 0) dfs(i + 1, j + 1);
}

void init(){ //hàm khởi tạo
    cin >> n >> m;
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= m; j ++)
            cin >> a[i][j];
}

void solve() { //hàm xử lý
    res = 0; //khởi tạo kết quả
    memset (vs, 0, sizeof (vs)); //làm mới mảng chưa thăm
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) {
            if (a[i][j] == 1 && vs[i][j] == 0) { //đếm số thành phần liên thông bằng dfs
                res++;
                dfs (i, j);
            }
        }
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
191. DSA10001	TÌM ĐƯỜNG
/*Cho một bảng S[][] kích thước N x M, bao gồm các ô trống, các vật cản. Ban đầu bạn ở vị trí S. Nhiệm vụ của bạn là hãy
di chuyển tới vị trí T, sao cho số lần đổi hướng không quá hai lần.
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test bắt đầu bởi hai số nguyên N và M (1 ≤ N, M ≤ 500).
N dòng tiếp theo, mỗi dòng gồm M kí tự mô tả bảng S. Trong đó: ‘.’ là một ô trống, ‘*’ là vật cản, ‘S’ là vị trí xuất
phát và ‘T’ là vị trí đích. (Chỉ có một vị trí S và T duy nhất).
Output:
Với mỗi test, in ra “YES” nếu tìm được đường đi, ra in “NO” trong trường hợp ngược lại.
Input                 Output
2
5 5                   YES
..S..
****.
T....
****.
.....
5 5                   NO
S....
****.
.....
.****
..T..
*/
/*Ý tưởng: sử dụng bfs để tìm đường đi, nếu mỗi lần đổi hướng thì tăng số lần lên, khi đến đích số lần lớn hơn 2 hoặc
không thể đến đích thì đưa ra NO, còn lại đưa ra YES*/

#include <bits/stdc++.h>
using namespace std;
int n, m, start_row, start_col, dest_row, dest_col, vs[505][505];
char a[505][505];

void init() { //hàm khởi tạo
    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> a[i][j];
            if (a[i][j] == 'S') { //gán vị trí bắt đầu
                start_row = i;
                start_col = j;
            } else if (a[i][j] == 'T') { //gán vị trí kết thúc
                dest_row = i;
                dest_col = j;
            }
        }
    }
}

int bfs() { //hàm bfs
    queue <pair <int, int> > q;
    q.push ({start_row, start_col});
    while (!q.empty ()) { //do đánh dấu đã duyệt là 1 nên số lần đổi hướng sẽ bằng vs[i][j] - 2
        int row = q.front ().first;
        int col = q.front ().second;
        if (vs[row][col] == 4) return 3; //nếu qua số lần đổi hướng trả về 3
        q.pop ();
        //duyệt theo các hướng và tăng số lần đổi hướng lên và thêm vị trí được duyệt đến vào hàng đợi
        for (int i = row - 1; i >= 0; i--)
            if (a[i][col] == '*') break;
            else {
                if (vs[i][col] == 0) {
                    vs[i][col] = vs[row][col] + 1;
                    q.push ({i, col});
                }
            }
        for (int i = row + 1; i < n; i++)
            if (a[i][col] == '*') break;
            else {
                if (vs[i][col] == 0) {
                    vs[i][col] = vs[row][col] + 1;
                    q.push ({i, col});
                }
            }
        for (int i = col - 1; i >= 0; i--)
            if (a[row][i] == '*') break;
            else {
                if (vs[row][i] == 0) {
                    vs[row][i] = vs[row][col] + 1;
                    q.push ({row, i});
                }
            }
        for (int i = col + 1; i < m; i++)
            if (a[row][i] == '*') break;
            else {
                if (vs[row][i] == 0) {
                    vs[row][i] = vs[row][col] + 1;
                    q.push ({row, i});
                }
            }
        if (vs[dest_row][dest_col] != 0) return vs[dest_row][dest_col] - 2; //nếu tìm thấy đích thì trả về số lần đổi
    }
    return 3; //nếu không tìm được đừng đi thì trả về số lớn hơn 2
}

void solve() { //hàm xử lý
    memset (vs, 0, sizeof (vs)); //làm mới mảng đã thăm
    vs[start_row][start_col] = 1; //đánh dấu vị trí xuất phát đã được duyệt qua
    if (bfs () <= 2) cout << "YES" << endl; //đưa ra kết quả
    else cout << "NO" << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
192. DSA09032	KẾT BẠN
/*Trường học X có N sinh viên, trong đó có M cặp là bạn bè của nhau. Bạn của bạn cũng là bạn, tức là nếu A là bạn của B,
B là bạn của C thì A và C cũng là bạn bè của nhau.
Các bạn hãy xác định xem số lượng sinh viên nhiều nhất trong một nhóm bạn là bao nhiêu?
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test bắt đầu bởi 2 số nguyên N và M (N, M ≤ 100 000).
M dòng tiếp theo, mỗi dòng gồm 2 số nguyên u, v (u #v) cho biết sinh viên u là bạn của sinh viên v.
Output:
Với mỗi test, in ra đáp án tìm được trên một dòng.
Input                 Output
2
3 2                   3
1 2
2 3
10 12                 7
1 2
3 1
3 4
5 4
3 5
4 6
5 2
2 1
7 1
1 2
9 10
8 9
*/
//Ý tưởng: tìm số đỉnh lớn nhất của 1 thành phần liên thông
//Code:

#include <bits/stdc++.h>
using namespace std;
int v, e, cnt, res, vs[100005];
vector <int> a[100005];

void dfs(int u) { //hàm dfs
    vs[u] = 1; //đánh dấu đỉnh đã được duyệt qua
    for (int i = 0; i < a[u].size (); i++) { //tìm tất cả các đỉnh chưa được duyệt qua kề với u
        int tmp = a[u][i];
        if (vs[tmp] == 0) {
            cnt++; //tăng số đỉnh của thành phần liên thông hiện tại
            dfs (tmp);
        }
    }
}

void init() { //hàm khởi tạo
    cin >> v >> e;
    while (e--) {
        int x, y;
        cin >> x >> y;
        a[x].push_back (y); //tạo ma trận kề
        a[y].push_back (x);
    }
}

void solve() { //hàm khởi tạo
    res = 0; //khởi tạo kết quả
    memset (vs, 0, sizeof (vs));
    for (int i = 1; i <= v; i++)
        if (vs[i] == 0) {
            cnt = 1; //khởi tạo số đỉnh của thành phần liên thông hiện tại
            dfs (i); //gọi hàm dfs tìm số đỉnh của thành phần liên thông
            res = max (cnt, res); //cập nhật kết quả
        }
    cout << res << endl; //đưa ra kết quả
    for (int i = 1; i <= v; i++) a[i].clear (); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
193. DSA10006	CÂY KHUNG CỦA ĐỒ THỊ THEO THUẬT TOÁN DFS
/*Cho đồ thị vô hướng G=(V, E). Hãy xây dựng một cây khung của đồ thị G với đỉnh u ∈ V là gốc của cây bằng thuật toán
DFS.
Input
Dòng đầu tiên gồm một số nguyên T (1 ≤ T ≤ 20) là số lượng bộ test.
Tiếp theo là T bộ test, mỗi bộ test có dạng sau:
Dòng đầu tiên gồm 3 số nguyên N=|V|, M=|E|, u (1 ≤ N ≤ 103, 1 ≤ M ≤ 105, 1 ≤ u ≤ N).
M dòng tiếp theo, mỗi dòng gồm 2 số nguyên a, b (1 ≤ a, b ≤ N, a ≠ b) tương ứng cạnh nối hai chiều từ a tới b.
Dữ liệu đảm bảo giữa hai đỉnh chỉ tồn tại nhiều nhất một cạnh nối.
Output
Với mỗi bộ test, nếu tồn tại cây khung thì in ra N – 1 cạnh của cây khung với gốc là đỉnh u trên N – 1 dòng theo thứ tự
duyệt của thuật toán DFS. Ngược lại nếu không tồn tại cây khung thì in ra -1.
Input                 Output
2
4 3 2                 2 1
1 2                   1 3
1 3                   3 4
2 4
3 4                   -1
4 2 2
1 2
3 4
*/
//Ý tưởng: duyệt dfs từ đỉnh cho trước sau đó in lần lượt từng cạnh, nếu duyệt không ra được đủ các đỉnh đưa ra -1
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, cnt, start, vs[1005];
vector <int> a[1005];
vector <int> res;

void dfs(int u) { //hàm dfs
    vs[u] = 1; //đánh dấu đỉnh được duyệt qua
    cnt++; //tăng số đỉnh được duyệt qua
    for (int i = 0; i < a[u].size (); i++) { //kiểm tra tất cả các đỉnh chưa được duyệt qua kề với đỉnh u
        int tmp = a[u][i];
        if (!vs[tmp]) { //nếu tìm thấy
            vs[tmp] = 1; //đánh dấu đã duyệt qua
            res.push_back (u); //cập nhật kết quả
            res.push_back (tmp);
            dfs (tmp); //gọi lại hàm dfs tại đỉnh đó
        }
    }
}

void init() { //hàm khởi tạo
    res.clear ();
    cin >> v >> e >> start;
    while (e--) {
        int x, y;
        cin >> x >> y;
        a[x].push_back (y); //tạo ma trận kề
        a[y].push_back (x);
    }
}

void solve() { //hàm xử lý
    cnt = 0;
    memset (vs, 0, sizeof (vs));
    dfs (start);
    if (cnt == v)
        for (int i = 0; i < res.size (); i += 2) cout << res[i] << " " << res[i + 1] << endl; //đưa ra kết quả
    else cout << "-1" << endl;
    for (int i = 1; i <= v; i++) a[i].clear (); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
194. DSA10007	CÂY KHUNG CỦA ĐỒ THỊ THEO THUẬT TOÁN BFS
/*Cho đồ thị vô hướng G=(V, E). Hãy xây dựng một cây khung của đồ thị G với đỉnh u ∈ V là gốc của cây bằng thuật toán
BFS.
Input
Dòng đầu tiên gồm một số nguyên T (1 ≤ T ≤ 20) là số lượng bộ test.
Tiếp theo là T bộ test, mỗi bộ test có dạng sau:
Dòng đầu tiên gồm 3 số nguyên N=|V|, M=|E|, u (1 ≤ N ≤ 103, 1 ≤ M ≤ 105, 1 ≤ u ≤ N).
M dòng tiếp theo, mỗi dòng gồm 2 số nguyên a, b (1 ≤ a, b ≤ N, a ≠ b) tương ứng cạnh nối hai chiều từ a tới b.
Dữ liệu đảm bảo giữa hai đỉnh chỉ tồn tại nhiều nhất một cạnh nối.
Output
Với mỗi bộ test, nếu tồn tại cây khung thì in ra N – 1 cạnh của cây khung với gốc là đỉnh u trên N – 1 dòng theo thứ tự
duyệt của thuật toán BFS. Ngược lại nếu không tồn tại cây khung thì in ra -1.
Input                 Output
2
4 4 2                 2 1
1 2                   2 4
1 3                   1 3
2 4
3 4                   -1
4 2 2
1 2
3 4
*/
//Ý tưởng: duyệt bfs từ đỉnh cho trước sau đó in lần lượt từng cạnh, nếu duyệt không ra được đủ các đỉnh đưa ra -1
//Code:

#include <bits/stdc++.h>
using namespace std;
int v, e, cnt, start, vs[1005];
vector <int> a[1005];
vector <int> res;

void bfs(int u) { //hàm bfs
    vs[u] = 1; //đánh dấu đã thăm
    queue <int> q;
    q.push (u);
    while (!q.empty ()) {
        u = q.front (); //gán u là đỉnh ở đầu hàng đợi
        cnt++; //tăng số đỉnh đã thăm
        q.pop ();
        for (int i = 0; i < a[u].size (); i++) { //tìm tất cả các đỉnh chưa thăm kề với đỉnh u
            int tmp = a[u][i];
            if (!vs[tmp]) {
                vs[tmp] = 1; //đánh dấu là đã thăm
                q.push (tmp); //đưa đỉnh đó vào hàng đợi
                res.push_back (u); //cập nhật kết quả
                res.push_back (tmp);
            }
        }
    }
}

void init() { //hàm khởi tạo
    res.clear ();
    cin >> v >> e >> start;
    while (e--) {
        int x, y;
        cin >> x >> y;
        a[x].push_back (y); //tạo ma trận kề
        a[y].push_back (x);
    }
}

void solve() { //hàm xử lý
    cnt = 0;
    memset (vs, 0, sizeof (vs));
    bfs (start);
    if (cnt == v)
        for (int i = 0; i < res.size (); i += 2) cout << res[i] << " " << res[i + 1] << endl; //đưa ra kết quả
    else cout << "-1" << endl;
    for (int i = 1; i <= v; i++) a[i].clear (); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
195. DSA11001	CÂY BIỂU THỨC 1
/*Cây biểu thức là một cây nhị phân trong đó mỗi node trung gian là một phép toán, mỗi node lá là một toán hạng. Ví dụ
với biểu thức P = 3 + ((5+9)*2) sẽ được biểu diễn như cây dưới đây.
Đối với cây biểu thức, duyệt theo thứ tự trước ta sẽ được biểu thức tiền tố, duyệt theo thứ tự sau ta sẽ được biểu thức
hậu tố, duyệt theo thứ tự giữa ta được biểu thức trung tố. Chú ý, cây biểu thức luôn là cây nhị phân đầy (mỗi node trung
gian đều có hai node con).
Cho biểu thức hậu tố P, hãy sử dụng cây biểu thức để đưa ra biểu thức trung tố tương ứng với biểu thức P.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test là một biểu thức hậu tố P.
T, P thỏa mãn ràng buộc : 1≤T≤100; 1≤lengh(P)≤100.
Output:
Đưa ra biểu thức trung tố tương ứng với P.
Input                 Output
2
ab+ef*g*-             a+b-e*f*g
wlrb+-*               w*l-r+b
*/
//Ý tưởng: dựa vào biểu thức hậu tố để tạo cây sau đó in ra theo duyệt thứ tự giữa
//Code:

#include <bits/stdc++.h>
using namespace std;

string str;

void init() { //hàm khởi tạo
    cin >> str;
}

struct et { //kiểu dữ liệu cây
    char val;
    et *left, *right;
};

bool isOperator(char c) { //hàm kiểm tra toán tử
    if (c == '+' || c == '-' || c == '*' || c == '/') return true;
    return false;
}

et* newNode(char c) { //hàm tạo cây mới
    et *tmp = new et;
    tmp->left = tmp->right = NULL;
    tmp->val = c;
    return tmp;
}

et* constructTree() { //hàm xây dựng cây
    stack <et *> s;
    et *t, *t1, *t2;
    for (int i = 0; i < str.length (); i++) {
        if (!isOperator (str[i])) { //nếu không phải là toán tử, đưa cây đó vào ngăn xếp
            t = newNode (str[i]);
            s.push (t);
        } else { //nếu gặp toán tử lấy 2 cây ở đỉnh của ngăn xếp là cây con bên trái và cây con bên phải
            t = newNode (str[i]);
            t1 = s.top ();
            s.pop ();
            t2 = s.top ();
            s.pop ();
            t->right = t1;
            t->left = t2;
            s.push (t); //đưa cây vừa tạo vào ngăn xếp
        }
    }
    return s.top (); //trả về cây được tạo thành
}
 
void print(et* res) { //hàm in theo thứ tự giữa
    if (res) {
        print (res->left); //in bên trái
        cout << res->val; //in giữa
        print (res->right); //in bên phải
    }
}

void solve() { //hàm xử lý
    et *res = constructTree (); //xây dựng cây
    print (res); //đưa ra kết quả
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
196. DSA11002	CÂY BIỂU THỨC 2
/*Cho một cây biểu thức là một cây nhị phân đầy đủ bao gồm các phép toán +, -, *. / và một số toán hạng có giá trị
nguyên. Nhiệm vụ của bạn là hãy tính toán giá trị biểu thức được biểu diễn trên cây nhị phân đầy đủ. Ví dụ với cây dưới
đây là biểu diễn của biểu thức P = ( (5*4) + (100-20)) sẽ cho ta giá trị là 100.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test là gồm hai dòng: dòng thứ nhất đưa vào N là số lượng node của cây;
dòng thứ hai đưa vào nội dung các node của cây; các node được viết cách nhau một vài khoảng trống. Các số có giá trị
nguyên không vượt quá 1000.
T, N, P thỏa mãn ràng buộc : 1≤T≤100; 1≤N, lenght(P)≤100.
Output:
Đưa ra giá trị của cây biểu thức.
Input                Output
2
7
+ * - 5 4 100 20    100
3
- 4 7               -3
*/
/*Ý tưởng: duyệt đồng thời từ cuối về cả toán tử và toán hạng thực hiện phép toán giữa 2 toán hạng và toán tử tương ứng,
sau đó đưa toán hạng tìm được về đầu của hàng đợi chưa toán hạng*/
//Code:

#include <bits/stdc++.h>
using namespace std;

int n;
stack <char> s; //ngăn xếp chưa toán tử
deque <int> q; //hàng đợi chưa toán hạng

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n / 2; i++) {
        char c;
        cin >> c;
        s.push (c); //đưa toán tử vào ngăn xếp
    }
    for (int i = n / 2; i < n; i++) {
        int x;
        cin >> x;
        q.push_back (x); //đưa toán hạng vào hàng đợi
    }
}

int calculate(int x, int y, char c) { //hàm tính biểu thức
    if (c == '+') return x + y;
    if (c == '-') return x - y;
    if (c == '*') return x * y;
    return x / y;
}

void solve() { //hàm xử lý
    while (!s.empty ()) { //duyệt đến khi hết toán tử
        int y = q.back (); //lấy ra 2 toán hạng ở cuối hàng đợi
        q.pop_back ();
        int x = q.back ();
        q.pop_back ();
        q.push_front (calculate (x, y, s.top ())); //thực hiện phép toán với toán tử tương ứng rồi thêm vào đầu hàng đợi
        s.pop (); 
    }
    cout << q.back () << endl; //đưa ra kết quả
    q.pop_back (); //làm mới hàng đợi
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
197. DSA11003	DUYỆT CÂY 1
/*Cho phép duyệt cây nhị phân Inorder và Preorder, hãy đưa ra kết quả phép duyệt Postorder của cây nhị phân. Ví dụ với
cây nhị phân có các phép duyệt cây nhị phân của cây dưới đây:
Inorder     : 4  2  5  1  3  6
Preorder:  : 1  2  4  5  3  6
Postorder : 4  5  2  6  3  1
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 3 dòng: dòng đầu tiên đưa vào số N là số lượng node; dòng tiếp
theo đưa vào N số theo phép duyệt Inorder; dòng cuối cùng đưa vào N số là kết quả của phép duyệt Preorder; các số được
viết cách nhau một vài khoảng trống.
T, N, node thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤1000; 1≤ giá trị node ≤104;
Output:
Đưa ra kết quả phép duyệt Postorder theo từng dòng.
Input                 Output
1
6                     4  5  2  6  3  1
4  2  5  1  3  6
1  2  4  5  3  6
*/
//Ý tưởng: sử dụng băm
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, pre[1005], in[1005], preIndex;
map <int, int> hm;

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> in[i];
    for (int i = 0; i < n; i++) cin >> pre[i];
}

void printPostorder(int start, int end) { //hàm in ra kết quả
    if (start > end) return; // bắt đầu lớn hơn kết thúc là đã in hết mảng
    int inIndex = hm[pre[preIndex++]]; // tìm chỉ mục gốc của cây hiện tại trong mảng duyệt thứ tự trước
    //tăng preIndex lên 1 vì gốc của cây con đứng ngay sau chỉ mục trước hiện tại
    printPostorder (start, inIndex - 1); //tiếp tục tìm gốc của cây con bên trái
    printPostorder (inIndex + 1, end); // tiếp tục tìm gốc của cây con bên phải
    cout << in[inIndex] << " "; // in ra gốc của cây hiện tại
}

void solve() { //hàm xử lý
    preIndex = 0; //chỉ mục trước của mảng duyệt thứ tự giữa bắt đầu ở 0 vì trong duyệt thứ tự giữa gốc ở đầu tiên
    for (int i = 0; i < n; i++) hm[in[i]] = i; //đánh dấu vị trí của phần tử trong mảng duyệt thứ tự giữa
    printPostorder (0, n - 1); //tìm gốc của cây con với phạm vi là cả mảng
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
198. DSA11004	DUYỆT CÂY THEO MỨC
/*Cho cây nhị phân, nhiệm vụ của bạn là duyệt cây theo Level-order. Phép duyệt level-order trên cây là phép thăm node
theo từng mức của cây. Ví dụ với cây dưới đây sẽ cho ta kết quả của phép duyệt level-order: 20  8  22  4  12  10  14.
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào số N là số lượng cạnh của cây;
dòng tiếp theo đưa vào N bộ ba (u, v, x), trong đó u là node cha, v là node con, x= R nếu v là con phải, x=L nếu v là
con trái; u, v, x được viết cách nhau một vài khoảng trống.
T, N, u, v, thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤103; 1≤u, v≤104;
Output:
Đưa ra kết quả phép duyệt level-order theo từng dòng.
Input                            Output
2
2                                1 3 2
1 2 R 1 3 L
4                                10 20 30 40 60
10 20 L 10 30 R 20 40 L 20 60 R
*/
//Ý tưởng: xây dựng cây sau đó duyệt từng cây con sử dụng hàng đợi
//Code:

#include <bits/stdc++.h>
using namespace std;

struct Node { //kiểu dữ liệu cây
    int data;
    Node *left, *right;
    Node (int x) { //tạo cây mới
        data = x;
        left = right = NULL;
    }
};

void makeNode(Node* root, int b, int c) { //hàm tạo cây mới
    if (c == 'L') root->left = new Node (b); //tạo cây con bên trái
    else root->right = new Node (b); //tạo cây con bên phải
}

void findNode(Node* root, int a, int b, int c) { //hàm tìm kiếm cây
    if (root == NULL) return;
    if (root->data == a) makeNode (root, b, c); //nếu tìm thấy tạo cây con
    else {
        findNode (root->left, a, b, c);  //tìm ở cây con bên trái
        findNode (root->right, a, b, c); //tìm ở cây con bên phải
    }
}

void print(Node* root) { //hàm in
    if (root == NULL) return;
    queue <Node *> q;
    q.push (root);
    while (!q.empty ()) {
        Node *tmp = q.front ();
        cout << tmp->data << " "; //đưa ra gốc của cây hiện tại
        q.pop ();
        if (tmp->left != NULL) q.push (tmp->left); //đưa cây con bên trái vào hàng đợi
        if (tmp->right != NULL) q.push (tmp->right); //đưa cây con bên phải vào hàng đợi
    }
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        Node *root = NULL;
        int a, b;
        char c;
        while (n--) {
            cin >> a >> b >> c;
            if (root == NULL) { //nếu cây rỗng tạo cây mới
                root = new Node (a); //tạo gốc mới
                makeNode (root, b, c); //tạo cây con
            } else findNode (root, a, b, c); //nếu cây không rỗng tìm cây hiện tại
        }
        print (root);
        cout << endl;
    }
    return 0;
}
199. DSA11005	DUYỆT CÂY 2
/*Cho hai mảng là phép duyệt Inorder và Level-order, nhiệm vụ của bạn là xây dựng cây nhị phân và đưa ra kết quả phép
duyệt Postorder. Level-order là phép duyệt theo từng mức của cây. Ví dụ như cây dưới đây ta có phép Inorder và
Level-order như dưới đây:
Inorder : 4  8  10  12 14 20 22
Level order: 20  8  22  4  12  10  14
https://media.geeksforgeeks.org/wp-content/cdn-uploads/BinaryTree4.png
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 3 dòng: dòng đầu tiên đưa vào số N là số lượng node; dòng tiếp
theo đưa vào N số là phép duyệt Inorder; dòng cuối cùng đưa vào N số là phép duyệt Level-order; các số được viết cách
nhau một vài khoảng trống.
T, N, node thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤103; 1≤A[i]≤104;
Output:
Đưa ra kết quả phép duyệt Postorder theo từng dòng
Input                 Output
2
3                     1 2 0
1 0 2
0 1 2
7                     3 4 1 5 6 2 0
3 1 4 0 5 2 6
0 1 2 3 4 5 6
*/
//Ý tưởng: sử dụng băm
//Code:

#include <bits/stdc++.h>
using namespace std;

struct Node { //kiểu dữ liệu cây
    int left, right;
};

int n, in[1005], lv[1005], lvIndex;
map <int, int> hm;
Node root[1005];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> in[i];
    for (int i = 0; i < n; i++) cin >> lv[i];
}

void printPostorder(int res) { //hàm đưa ra kết quả
    if (res == -1) return;
    printPostorder (root[res].left); //đưa ra cây con bên trái
    printPostorder (root[res].right); //dưa ra cây con bên phải
    cout << res << " "; //đưa ra gốc của cây hiện tại
}

void buildTree() { //hàm xây dựng cây
    queue <pair <int, pair <int, int> > > q;
    q.push ({lv[0], {0, n - 1}}); //đưa giá trị của cây theo mức và độ rộng của hm vào hàng đợi
    while (!q.empty ()) {
        int tmp = q.front ().first; //gốc hiện tại
        int start = q.front ().second.first; //vị trí bắt đầu
        int end = q.front ().second.second; //vị trí kết thúc
        int inIndex = hm[tmp]; //tìm chỉ mục của gốc hiện tại trên mảng inorder
        //theo thứ tự duyệt theo mức nếu chỉ mục hiện tại lớn hơn start thì đó là cây con bên trái của cây hiện tại
        if (start < inIndex) {
            root[tmp].left = lv[lvIndex]; //cập nhật cây con bên trái
            lvIndex++; //chạy đến chỉ mục tiếp theo trên mảng duyệt theo mức
            q.push ({root[tmp].left, {start, inIndex - 1}}); //đưa cây tìm được và độ rộng của hm vào hàng đợi
        }
        //theo thứ tự duyệt theo mức nếu chỉ mục hiện tại nhỏ hơn end thì đó là cây con bên phải của cây hiện tại
        if (inIndex < end) {
            root[tmp].right = lv[lvIndex]; //cập nhật cây con bên phải
            lvIndex++; //chạy đến chỉ mục tiếp theo trên mảng duyệt theo mức
            q.push ({root[tmp].right, {inIndex + 1, end}}); //đưa cây tìm được và độ rộng của hm vào hàng đợi
        }
        q.pop ();
    }
}

void solve() { //hàm xử lý
    lvIndex = 1; //khởi tạo chỉ mục ban đầu của mảng duyệt theo mức
    for (int i = 0; i < n; i++) {
        hm[in[i]] = i; //đánh dấu vị trí của phần tử ở mảng duyệt theo thứ tự inorder
        root[in[i]].left = -1; //đánh dấu chưa có cây con bên trái
        root[in[i]].right = -1;  //đánh dấu chưa có cây con bên phải
    }
    buildTree (); //xây dựng cây
    printPostorder (lv[0]); //đưa ra kết quả
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
200. DSA07028	NHỊP CHỨNG KHOÁN
/*Bạn là một nhà đầu tư chứng khoán nổi tiếng. Nhiệm vụ hàng ngày của bạn là tính nhịp tăng giảm của phiên chứng khoán
trong N ngày để có thể bắt kịp thị trường. Nhịp chứng khoán của ngày thứ i được định nghĩa là số ngày liên tiếp từ ngày
thứ i trở về mà giá chứng khoán bé hơn hoặc bằng với giá chứng khoán của ngày i.
Input: Dòng đầu ghi số bộ test (không quá 10). Mỗi test có 2 dòng.
Dòng đầu tiên gồm 1 số nguyên N (1 ≤ N ≤ 105) là số ngày.
Dòng tiếp theo gồm N số nguyên A1, A2, …, AN (1 ≤ Ai ≤ 106) là giá chứng khoán của các ngày.
Output
In ra N số B1, B2, …, BN trong đó Bi là nhịp chứng khoán của ngày thứ i.
Input                 Output
1
7                     1 1 1 2 1 4 6
100 80 60 70 60 75 85
*/
//Ý tưởng: sử dụng ngăn xếp để lưu lại những ngày có giá chứng khoán cao hơn ngày hiện tại và nhịp chứng khoán của nó
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, a[100005], res[100005];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    stack <int> s; //ngăn xếp lưu giá chứng khoán
    stack <int> cnt; //ngăn xếp lưu nhịp chứng khoán tương ứng
    res[0] = 1; //ngày đầu tiên luôn có nhịp chứng khoán là 1
    for (long i = 1; i < n; i++) {
        if (a[i] < a[i - 1]) { //nếu ngày hiện tại có giá chứng khoán nhỏ hơn ngày hôm trước
            res[i] = 1; //nhịp chứng khoán hiện tại là 1
            s.push (a[i - 1]); //đưa giá chứng khoán ngày hôm trước vào ngăn xếp
            cnt.push (res[i - 1]); //đưa nhịp chứng khoán ngày hôm trước vào ngăn xếp
        } else { //nếu ngày hiện tại có giá chứng khoán không nhỏ hơn ngày hôm trước
            res[i] = res[i - 1] + 1; //nhịp chứng khoán bằng nhịp chứng khoán của ngày hôm trước cộng 1
            while (!s.empty () && a[i] >= s.top ()) { //so sánh giá chứng khoán của những ngày khác trên ngăn xếp
                res[i] += cnt.top (); //nếu giá chứng khoán lớn hơn cập nhật kết quả
                cnt.pop (); //xoá nhịp chứng khoán ngày vừa duyệt qua
                s.pop (); //xoá giá chứng khoán ngày vừa duyệt qua
            }
        }
    }
    for (long i = 0; i < n; i++) cout << res[i] << " "; //đưa ra kết quả
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
201. DSA05042	DÃY CON LIÊN TIẾP TỔNG BẰNG K
/*Cho dãy số A[] gồm có N phần tử không âm và số K.
Nhiệm vụ của bạn là hãy xác định xem có tìm được 1 dãy con liên tiếp mà tổng các phần tử bằng K hay không?
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test gồm số nguyên N và K (1≤ N ≤ 100 000, 0 ≤ K ≤ 1018).
Dòng tiếp theo gồm N số nguyên A[i] (0 ≤ A[i] ≤ 109).
Output:
Với mỗi test, in ra trên một dòng là đáp án thu được. Nếu có hãy in ra “YES”. Nếu không tìm được đáp án, in ra “NO”.
Input                 Output
3
6 33                  YES
1 4 20 3 10 5
7 7                   YES
1 4 0 0 3 10 5
2 0                   NO
1 4
*/
//Ý tưởng: lưu trữ lại tổng của dãy con hiện tại, nếu tổng lớn k trừ dần từ vị trí hiện tại đến khi tổng nhỏ hơn k
//Code:

#include <bits/stdc++.h>
using namespace std;

long long n, k, a[100005];

void init(){ //hàm khởi tạo
    cin >> n >> k;
    for (int i = 0; i < n; i ++) cin >> a[i];
}

void solve() { //hàm xử lý
    int pos = 0, i = 0;
    long long sum = a[0]; //khởi tạo tổng bằng phần tử đầu tiên
    int check = 0;
    while (i < n) { //duyệt lần lượt từng phần tử
        if (sum == k) { //nếu tổng bằng k đánh dấu đã tìm được và dừng lại
            check = 1;
            break;
        } else if (sum > k) { //nếu tổng lớn k trừ từ phần tử của vị trí đã đánh dấu và đi đến vị trí tiếp theo
            sum -= a[pos++];
            if (pos > i) {  //nếu đã trừ hết dãy con hiện tại
                i = pos; //cập nhật lại i
                sum = a[i]; //cập nhật lại tổng
            }
        } else if (sum < k) { //nếu tổng nhỏ hơn k
            i++; //duyệt đến phần tử tiếp theo
            sum += a[i];
        }
    }
    if (check == 1) cout << "YES" << endl; //đưa ra kết quả
    else cout << "NO" << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
202. DSA06044	SẮP XẾP CHẴN LẺ
/*Cho dãy số a[] có n phần tử, đánh số từ 1 đến n. Hãy sắp xếp các phần tử ở vị trí lẻ theo thứ tự tăng dần, các phần tử
ở vị trí chẵn theo thứ tự giảm dần.
Input
Dòng đầu tiên ghi số n, không quá 105
Dòng thứ 2 ghi n số của dãy a[] (a ≤ a[i] ≤ 109)
Output
Ghi ra dãy số kết quả trên một dòng
Input                Output
4
1 2 3 4              1 4 3 2
*/
//Ý tưởng: sắp xếp lại từng mảng vị trí chẵn và lẻ sau đó in ra
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, a[100005];
vector <int> chan;
vector <int> le;

void init() { //hàm khởi tạo
    cin >> n;
    for (long i = 0; i < n; i++) {
        cin >> a[i];
        if (i % 2 == 0) chan.push_back (a[i]); //thêm phầ tử vị trí chẵn và lẻ vào mảng của nó
        else le.push_back (a[i]);
    }
}

void solve() { //hàm xử lý
    sort (le.begin (), le.end ()); //sắp xếp mảng lẻ
    sort (chan.begin (), chan.end ()); //sắp xếp mảng chẵn
    long k = 0, h = le.size () - 1;
    for (long i = 0; i < n; i++) { //đưa ra kết quả
        if (i % 2 == 0) cout << chan[k++] << " ";
        else cout << le[h--] << " ";
    }
}

int main() {
    init ();
    solve ();
    return 0;
}
203. CTDL_003	PHƯƠNG ÁN TỐI ƯU
/*Cho ai, ci , W, N (i =1, 2,..,N; N£100) là những số nguyên dương  và tập hợp
Hãy viết chương trình tìm phương án tối ưu XOPT =(x1,x2,..,xN) và giá trị tối ưu FOPT=F(XOPT) của hàm mục tiêu
Dữ liệu vào cho bởi file data.in theo khuôn dạng sau:
Dòng đầu tiên ghi lại số tự nhiên N và W. Hai số được viết cách nhau một vài khoảng trống;
Dòng kế tiếp ghi lại N số cj (j=1,2,..,N). Hai số được viết cách nhau một vài khoảng trống;
Dòng kế tiếp ghi lại N số aj (j=1,2,..,N). Hai số được viết cách nhau một vài khoảng trống;
Giá trị tối ưu FOPT và phương án XOPT tìm được sẽ liệt kê trên màn hình theo khuôn dạng:
Dòng đầu tiên ghi lại giá trị tối ưu FOPT;
Dòng kế tiếp ghi lại phương án tối ưu XOPT. Hai phần tử khác nhau của phương án tối ưu được viết cách nhau bởi một
khoảng trống.
Input                Output
4 10                 13
6 5 3 7              1 0 0 1
5 4 6 5
*/
//Ý tưởng: quy hoạch động bài toán cái túi sau đó sử dụng truy vét
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, v, a[105], c[105];

void init() { //hàm khởi tạo
    cin >> n >> v;
    for (int i = 1; i <= n; i++) cin >> c[i];
    for (int i = 1; i <= n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    int dp[n + 1][v + 1], used[n + 1];
    for (int i = 0; i <= n; i++)
        for (int j = 0; j <= v; j++)
            dp[i][j] = 0; //khởi tạo giá trị ban đầu của mảng dp
    for (int i = 1; i <= n; i++) //tính giá trị tối ưu, thuật toán đã trình bày ở bài cái túi
        for (int j = 1; j <= v; j++) {
            if (j >= a[i]) dp[i][j] = max (dp[i - 1][j], c[i] + dp[i - 1][j - a[i]]);
            else dp[i][j] = dp[i - 1][j];
        }
    cout << dp[n][v] << endl; //đưa ra giá trị tối ưu
    int pos = n; //khởi tạo vị trí
    while (pos > 0) {
        if (dp[pos][v] != dp[pos - 1][v]) { //nếu giá trị sử dụng khác với giá trị sử dụng trước đó
            used[pos] = 1; //vật tại ví trí pos được sử dụng
            v -= a[pos]; //cập nhật khối lượng còn lại của túi
        } else used[pos] = 0; //nếu giá trị sử dụng bằng với giá trị sử dụng trước đó vật không được sử dụng
        pos--; //kiểm tra đến vật tiếp theo
    }
    for (int i = 1; i <= n; i++) cout << used[i] << " "; //đưa ra phương án tối ưu
    cout << endl;
}

int main() {
    init ();
    solve ();
    return 0;
}
204. DSA02039	PHÂN TÍCH SỐ 2
/*Cho số nguyên dương N. Nhiệm vụ của bạn là hãy liệt kê tất cả các cách phân tích số tự nhiên N thành tổng các số tự
nhiên nhỏ hơn hoặc bằng N. Phép hoán vị của một cách được xem là giống nhau. Ví dụ với N = 5 ta có kết quả là:
(5), (4, 1), (3, 2), (3, 1, 1), (2, 2, 1), (2, 1, 1, 1), (1, 1, 1, 1, 1) .
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một số tự nhiên N được viết trên một dòng.
T, n thỏa mãn ràng buộc: 1≤T, N≤10.
Output:
Dòng đầu tiên là số lượng cách phân tích thỏa mãn. Dòng tiếp theo liệt kê đáp án theo mẫu ví dụ đã cho.
Input                Output
2
4                    5
                     (4) (3 1) (2 2) (2 1 1) (1 1 1 1)
5                    7
                     (5) (4 1) (3 2) (3 1 1) (2 2 1) (2 1 1 1) (1 1 1 1 1)
*/
//Ý tưởng: giống phân tích số 1 thêm  bước đưa ra số cách phân tích
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, cnt, a[10];
vector <int> res;

void init() { //hàm khởi tạo
    cin >> n;
}

void add(int k) { //hàm thêm
    for (int i = 0; i < k; i++) res.push_back (a[i]);
    res.push_back (-1);
}

void solve() { //hàm xử lý
    res.clear (); //làm mới kết quả
    cnt = 0; //khởi tạo biến đếm
    a[0] = n; //khởi tạo cấu hình đầu
    int k = 1;
    add (k); //thêm cấu hình đầu tiên vào kết quả
    int sum = 0; //khởi tạo biến tính tổng còn lại
    for (int i = k - 1; i >= 0; i--) {
        if (a[i] != 1) { //nếu tìm được số khác 1
            a[i]--; //giảm số đó đi 1
            sum++; //cập nhật tổng còn lại
            int x = sum / a[i]; //kiểm tra xem còn có thể thêm bao nhiêu số a[i] đằng sau nó
            for (int j = i + 1; j <= i + x; j++) a[j] = a[i]; //thêm vào x số a[i]
            k = i + x + 1; //cập nhật độ rộng của cấu hình
            if (sum % a[i] != 0) { //kiểm tra xem tổng đã bằng n chưa
                a[k] = sum % a[i]; //nếu chưa bằng thì bù thêm vào để bằng n
                k++; //cập nhật độ rộng của cấu hình
            }
            add (k); //thêm cấu hình tiếp theo vào kết quả
            sum = 0; //trả lại tổng còn lại và i để sinh cấu hình kế tiếp
            cnt++; //tăng số cách
            i = k;
        } else sum++; //nếu tìm thấy số 1 thì tăng tổng còn lại
    }
    cout << cnt << endl; //đưa ra kết quả
    cout << "(";
    for (int i = 0; i < res.size () - 1; i++)
        if (res[i] != -1) {
            if (res[i + 1] == -1) cout << res[i];
            else cout << res[i] << " ";
        } else cout << ") (";
    cout << ")";
    cout << endl;
}

main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
205. DSA02032	TỔ HỢP SỐ CÓ TỔNG BẰNG X
/*Cho mảng A[] gồm N số nguyên dương phân biệt và số X. Nhiệm vụ của bạn là tìm phép tổ hợp các số trong mảng A[] có
tổng bằng X. Các số trong mảng A[] có thể được sử dụng nhiều lần. Mỗi tổ hợp các số của mảng A[] được in ra theo thứ tự
không giảm các số. Ví dụ với A[] = {2, 4, 6, 8}, X = 8 ta có các tổ hợp các số như sau:
{2, 2, 2, 2}, {2, 2, 4}, {2, 6}, {4, 4}, {8}.
Input: Dòng đầu tiên đưa vào số lượng bộ test T. Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần
thứ nhất là hai số N và X; dòng tiếp theo đưa vào N số của mmảng A[]; các số được viết cách nhau một vài khoảng trống.
T, N, X, A[i] thỏa mãn ràng buộc: 1≤T ≤10; 1≤X, A[i]≤100. N ≤ 20.
Output: Đưa ra kết quả mỗi test theo từng dòng. Đầu tiên là số lượng  tổ hợp thỏa mãn. Mỗi tổ hợp được bao bởi cặp ký tự
{ } và cách nhau một dấu cách. Đưa ra -1 nếu không có tổ hợp nào thỏa mãn yêu cầu bài toán.
Input                Output
2
4  8                 5 {2 2 2 2} {2 2 4} {2 6} {4 4} {8}
2  4  6  8
2 9                  -1
10 11
*/
//Ý tưởng: quay lui với 0 và 1 ứng với có và không sử dụng phần tử a[i]
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, k, cnt, a[20];
vector <int> res;

void Try(int i, int sum, vector <int> tmp) { //hàm quay lui
    for (int j = 1; j >= 0; j--) {
        if (j == 1) { //nếu sử dụng phần tử a[i]
            sum += a[i]; //cập nhật tổng hiện tại
            tmp.push_back (a[i]); //thêm a[i] tổ hợp hiện tại
            if (sum > k) return; //nếu tổng lớn hơn k thì dừng lại
            else if (sum == k) { //nếu tổng bằng k
                cnt++; //tăng số tổ hợp
                for (int x = 0; x < tmp.size (); x++) res.push_back (tmp[x]); //cập nhật kết quả
                res.push_back (-1); //thêm -1 để ngăn cách giữa các tổ hợp
                return;
            } else { //nếu tổng nhỏ hơn k thì tiếp tục gọi hàm quay lui tại phần tử đó
                if (i < n) Try (i, sum, tmp);
            }
            sum -= a[i];
            tmp.pop_back ();
        } else { //nếu không sử dụng
            if (i < n - 1) Try (i + 1, sum, tmp); //gọi hàm quay lui với số tiếp theo
        }
    }
}

void init() { //hàm khởi tạo
    cin >> n >> k;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    cnt = 0; //khởi tạo biến đếm
    res.clear (); //làm mới kết quả
    vector <int> tmp;
    Try (0, 0, tmp); //thực hiện quay lui tìm kiếm các tổ hợp
    if (cnt == 0) cout << "-1"; //đưa ra kết quả
    else {
        cout << cnt << " {";
        for (int i = 0; i < res.size () - 1; i++) {
            if (res[i] != -1 && res[i + 1] != -1) cout << res[i] << " ";
            else if (res[i] != -1 && res[i + 1] == -1) cout << res[i];
            else cout << "} {";
        }
        cout << "}";
    }
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
206. DSA02045	TẬP CON CỦA XÂU KÝ TỰ
/*Cho một xâu ký tự S không có ký tự lặp lại. Hãy đưa ra tất cả các tập con của xâu ký tự S theo thứ tự từ điển.
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một xâu ký tự.
T, S thỏa mãn ràng buộc: 1≤T≤100; 1≤length(S)≤16.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
1
3                    a ab abc ac b bc c
abc
*/
//Ý tưởng: quay lui với 0 và 1 ứng với có và không sử dụng phần tử tại vị trí i
//Code:

#include<bits/stdc++.h>
using namespace std;

string str;
int n;
vector <int> res;

void Try(int i) { //hàm quay lui
    for (int j = 1; j >= 0; j--) {
        if (j == 1) { //nếu sử dụng
            res.push_back (i); //cập nhật kết quả hiện tại
            for (int k = 0; k < res.size (); k++) cout << str[res[k]]; //đưa ra kết quả
            cout << " ";
            if (i < n - 1) Try (i + 1); //nếu chưa duyệt hết tiếp tục gọi hàm quay lui
            res.pop_back (); //trả lại kết quả trước đó
        } else {
            if (i < n - 1) Try (i + 1); //nếu chưa duyệt hết tiếp tục gọi hàm quay lui
        }
    }
}

void init() { //hàm khởi tạo
    cin >> n;
    cin >> str;
}

void solve() { //hàm xử lý
    res.clear (); //làm mới kết quả
    Try (0); //gọi hàm quay lui
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
207. DSA02025	KÝ TỰ LẶP
/*Cho một dãy các xâu ký tự chỉ bao gồm các chữ cái in hoa từ A đến Z, trong đó các ký tự trong mỗi xâu đều đã được sắp
xếp theo thứ tự từ điển và mỗi chữ cái chỉ xuất hiện nhiều nhất một lần (tức là độ dài xâu tối đa là 26). Nếu một ký tự
xuất hiện trong hai xâu liên tiếp thì được coi là một lần lặp. Hãy tìm cách sắp xếp lại thứ tự các xâu sao cho số lần
lặp là nhỏ nhất có thể. Ví dụ dưới đây là cùng một dãy xâu nhưng với cách sắp xếp lại thì số lần lặp chỉ còn 2.
ABC
ABEF
DEF
ABCDE
FGH
=> Số lần lặp là 6
ABEF
DEF
ABC
FGH
ABCDE
=> Số lần lặp là 2.
Input
Dòng đầu tiên ghi số N (2 ≤ N ≤ 10) là số xâu ký tự. N dòng tiếp theo, mỗi dòng ghi một xâu.
Output
In ra trên một dòng số lần lặp nhỏ nhất có thể.
Input                Output
5                    2
ABC
ABEF
DEF
ABCDE
FGH

6                    3
BDE
FGH
DEF
ABC
BDE
ABEF

4                    4
XYZ
XYZ
ABYZ
Z
*/
//Ý tưởng: sinh ra các hoán vị của n, sau đó kiểm tra xem hoán vị nào cho số lần lặp nhỏ nhất
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, res, a[10], b[10]={0}, repeat[10][10];
vector <string> v;

int find(string s1, string s2) { //hàm tìm xem có mấy kí tự lặp
    int pos = 0;
    int cnt = 0;
    for (int i = 0; i < s1.length (); i++) //thực hiện dựa trên tìm kiếm giao của 2 mảng phần sắp xếp tìm kiếm
        for (int j = pos; j < s2.length (); j++) {
            if (s1[i] == s2[j]) {
                cnt++;
                pos = j + 1;
                break;
            } else if (s1[i] < s2[j]) {
                j = pos;
                break;
            }
        }
    return cnt; //trả về số lần lặp
}

void Try(int k) { //hàm quay lui
    for (int i = 0; i < n; i++)
        if (b[i] == 0) { //sinh ra các hoán vị
            a[k] = i;
            b[i] = 1;
            if (k == n - 1) {
                int cnt = 0;
                for (int i = 0; i < n - 1; i++) {
                    cnt += repeat[a[i]][a[i + 1]]; //tìm số lần lặp
                    if (cnt > res) break; //nếu số lần lặp lớn hơn kết quả hiện tại thì dừng lại
                }
                if (cnt < res) res = cnt; //cập nhật kết quả
            } else Try (k + 1);
            b[i] = 0;
        }
}

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin.ignore ();
        string str;
        cin >> str;
        v.push_back (str); //cập nhật vector chứa các xâu
    }
}

void solve() { //hàm xử lý
    res = INT_MAX; //khởi tạo kết quả
    for (int i = 0; i < n - 1; i++) //tìm số lần lặp lại giữa 2 xâu
        for (int j = i + 1; j < n; j++) {
            int tmp = find (v[i], v[j]);
            repeat[i][j] = tmp;
            repeat[j][i] = tmp;
        }
    Try (0); //thực hiện quay lui
    cout << res << endl; //đưa ra kết quả
}

int main() {
    init ();
    solve ();
    return 0;
}
208. DSA02026	PHÉP TOÁN CƠ BẢN
/*Cho một biểu thức trong phạm vi hai chữ số với các phép toán cộng trừ nhân chia. Các toán hạng và kết quả đảm bảo là
số nguyên dương có hai chữ số, nếu có phép chia thì phải thỏa mãn tính chia hết.
Người ta có thể ẩn đi một số chữ số hoặc phép toán bằng cách điền dấu chấm hỏi (?). Nhiệm vụ của bạn là khôi phục các
dấu chấm hỏi và in ra phép toán chính xác ban đầu. Nếu không thể có kết quả đúng thì ghi ra WRONG PROBLEM!
Dữ liệu vào
Dòng đầu ghi số bộ test T (1 ≤ T ≤ 100).
T dòng tiếp theo, mỗi dòng là một biểu thức có thể có các dấu ?.
Nếu có thể có nhiều kết quả đúng thì in ra kết quả đầu tiên theo thứ tự từ điển, tức là số nhỏ nhất có thể tính từ trái
sang phải.
Kết quả
Với mỗi bộ test, ghi ra biểu thức đúng tìm được. Hoặc WRONG PROBLEM!
Input                 Output
2
?0 ? 12 = 28          40 - 12 = 28
40 / ?3 = ??          WRONG PROBLEM!
*/
//Ý tưởng: thử các dấu hỏi từ số nhỏ đến lớn, từ + đến - rồi in ra phép toán đúng đầu tiên tìm được
#include <bits/stdc++.h>
using namespace std;

string str, tmp;
vector <string> res;
int state;

bool isOperator(char c) { //hàm kiểm tra toán tử
    if (c == '+' || c == '-') return true;
    return false;
}

int toInt(char x, char y) { //hàm chuyển đổi sang kiểu int
    int tmp = (x - 48) * 10 + (y - 48);
    return tmp;
}

bool check(string s) { //hàm kiểm tra phép toán
    int a, b, c;
    a = toInt (s[0], s[1]);
    b = toInt (s[5], s[6]);
    c = toInt (s[10], s[11]);
    if (s[3] == '+' && a + b == c) return true;
    if (s[3] == '-' && a - b == c) return true;
    return false;
}

void init() { //hàm khởi tạo
    getline (cin, str);
}

void Try(int i) { //hàm quay lui
    if (state == 1) return; //nếu đã có kết quả thì dừng lại
    if (i == 0 || i == 5 || i == 10) { //chữ số đầu tiên của 1 số nằm trong khoảng từ 1 đến 9
        if (str[i] == '?') { //nếu là dấu ? thì tạo ta các trường hợp
            for (char j = '1'; j <= '9'; j++) {
                tmp[i] = j;
                Try (i + 1); //gọi hàm quay lui để duyệt đến phần tử kế tiếp
            }
        } else Try (i + 1); //gọi hàm quay lui để duyệt đến phần tử kế tiếp
    } else if (i == 1 || i == 6 || i == 11) { //chữ số thứ 2 của 1 số nằm trong khoảng từ 0 đến 9
        if (str[i] == '?') { //nếu là dấu ? thì tạo ta các trường hợp
            for (char j = '0'; j <= '9'; j++) {
                tmp[i] = j;
                if (i < 11) Try (i + 1); //gọi hàm quay lui để duyệt đến phần tử kế tiếp
                else { //duyệt đến hết thì kiểm tra xem biểu thức có đúng không
                    if (check (tmp)) {
                        cout << tmp;
                        state = 1;
                        return;
                    }
                }
            }
        } else {
            if (i < 11) Try (i + 1);
            else { //duyệt đến hết thì kiểm tra xem biểu thức có đúng không
                if (check (tmp)) {
                    cout << tmp;
                    state = 1;
                    return;
                }
            }
        }
    } else if (i == 3) {
        if (isOperator (str[i])) Try (i + 1); //nếu là toán tử thì gọi hàm quay lui để duyệt đến phần tử kế tiếp
        else { //nếu là dấu ? thì thử với 2 trường hợp + và -
            tmp[i] = '+';
            Try (i + 1);
            tmp[i] = '-';
            Try (i + 1);
        }
    } else Try (i + 1); //nếu là khoảng trắng thì gọi hàm quay lui để duyệt đến phần tử kế tiếp
}

void solve() { //hàm xử lý
    state = 0; //khởi tạo tráng thái
    if (str[3] == '/' || str[3] == '*') return; //nếu có dấu * hoặc / thì không tồn tại phép toán đúng
    if (str[0] == '0' || str[5] == '0' || str[10] == '0') return; //nếu không phải số có 2 chữ số thì cũng sai
    if (check (str)) { //thực hiện kiểm tra biểu thức đầu vào xem có đúng không
        state = 1;
        cout << str;
        return;
    }
    tmp = str;
    Try (0); //thực hiện quay lui
}

void print() { //đưa ra kết quả
    if (state == 0) cout << "WRONG PROBLEM!";
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    cin.ignore ();
    while (t--) {
        init ();
        solve ();
        print ();
    }
    return 0;
}
209. DSA03021	TÌM DÃY SỐ
/*Cho dãy số nguyên A[] gồm có N phần tử. Nhiệm vụ của bạn là tìm dãy số B[] có tổng phần tử nhỏ nhất thỏa mãn tính chất
A[i] / B[i] = A[i+1] / B[i+1] với mọi chỉ số i (0 ≤ i ≤ N-2).
Phép chia trong bài toán này là phép chia nguyên (tức là chỉ lấy phần nguyên của kết quả: ví dụ 5/3 = 1).
Dữ liệu vào:
Dòng đầu tiên là số lượng phần tử N (1 ≤ N ≤ 1000).
Dòng tiếp theo gồm N số nguyên A[i] (1 ≤ A[i] ≤ 2000).
Kết quả:
In ra một số nguyên là tổng các phần tử của dãy số B[] tìm được.
Input                 Output
5                     25
18 27 16 22 6
*/
/*Ý tưởng: chọn kết quả chia lấy dư giữa 2 mảng từ 1 đến a[n-1]/2+1 do các số lớn hơn nó cũng cho phép dư bằng 1, khi
tạo đủ mảng b thì đưa ra kết quả*/
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, res, a[1005], b[1005];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    int check;
    res = 0; //khởi tạo kết quả
    for (int i = 1; i <= a[n - 1] / 2 + 1; i++) { //bắt đầu thử
        check = 1;
        int x = a[n - 1] / i; //khởi tạo phép dư chung
        b[n - 1] = i; //cập nhật phần tử cuối cùng của mảng b
        for (int j = n - 2; j >= 0; j--) { //tìm các phần tử còn lại
            int tmp = a[j] / x; //tìm số nhỏ nhất mà a[j]/b[j]=x;
            if (tmp == 0 || a[j] / tmp > x) {
                check = 0;
                break;
            } else {
                while (tmp > 1 && a[j] / (tmp - 1) == x) tmp--;
                b[j] = tmp;
            }
        }
        if (check == 1) break; //nếu tìm được kết quả thì dừng lại
    }
    for (int i = 0; i < n; i++) res += b[i]; //cập nhật kết quả
    cout << res; //đưa ra kết quả
}

int main() {
    init ();
    solve ();
    return 0;
}
210. CTDL_004	DÃY CON TĂNG DẦN BẬC K
/*Cho dãy gồm N số phân biệt AN = {a1, a2, .., aN } và số tự nhiên K (K<=N<=100). Ta gọi một dãy con tăng dần bậc K của
dãy số AN là một dãy các số gồm K phần tử trong dãy đó thỏa mãn tính chất tăng dần. Bài toán được đặt ra là in ra màn
hình  số các dãy con tăng dần bậc K của dãy số AN. Ví dụ :
Input:
5 3
2 5 15 10 20
Dòng đầu tiên ghi lại hai số N và K tương ứng với số phần tử của dãy số và bậc của dãy con.
Dòng kế tiếp : N số của dãy số AN, các số trong dãy không lớn hơn 100.
Output : 7 (số các dãy con tăng dần bậc 3 của dãy số AN)
*/
//ý tưởng: quay lui với 0 và 1 ứng với không sử dụng và sử dụng
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, k, cnt, a[105];

void Try(int i, vector<int>b, int dem) { //hàm xử lý
    for (int j = 1; j >= 0; j--) {
        if (j == 1 && a[i] > b[b.size () - 1]) { //sử dụng a[i] khi a[i] lớn hơn phần tử cuối của vector
            dem++; //tăng đếm
            b.push_back (a[i]); //đẩy a[i] vào cuối vector
            if (dem == k) { //nếu đã đủ bộ k số thì tăng số cặp lên và dừng nhánh
                cnt++;
                return;
            } else {
                if (i <= n - dem) Try (i + 1, b, dem);   //nếu chưa đủ thì thử tiếp
            }
            b.pop_back ();  //trả lại vector trước đó và đếm trước đó
            dem--;
        } else if (j == 0) {
            if (i <= n - dem) Try (i + 1, b, dem); //nếu không sử dụng a[i] thì tiếp tục thử
        }
    }
}

void init() { //hàm khởi tạo
    cin >> n >> k;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    cnt = 0;
    vector <int> b; //khai báo vector để lưu trữ bộ k số tạo thành
    for (int i = 0; i <= n - k; i++) {  //duyệt từ vị trí 0 đến vị trí tối đa mà còn có thể ghép thành cặp k số
        b.push_back (-1); //gán b[0]=-1 để các phần tử của mảng luôn lớn hơn b[0]
        Try (i, b, 0); //thử tại vị trí i với vector b và đếm bằng ;
    }
    cout << cnt << endl;    //in ra kết quả
}

main() {
    init ();
    solve ();
    return 0;
}
211. DSA03023	SẮP XẾP VIÊN BI
/*Cho một dãy N viên bi gồm 3 màu xanh, trắng, đỏ xếp lẫn lộn. Bằng cách đổi chỗ từng cặp viên bi cho nhau có thể xếp
lại dãy bi trên sao cho các viên bi xanh đứng trước, sau đó đến các viên bi trắng và cuối cùng là các viên bi đỏ. Tìm số
lượng ít nhất các phép đổi chỗ cần thực hiện
Input
Dòng đầu  tiên ghi N (N≤100)
Dòng thứ hai ghi xâu ký tự mô tả dãy bi (T-trắng, X-xanh, D-đỏ).
Output
Một dòng duy nhất ghi số phép đổi chỗ tối thiểu cần thực hiện
Input                 Output
9                     4
TTXDDDTDX
*/
/*Ý tưởng: tìm các viên bi đứng ở vị trí của nhau tức là khi đổi chỗ 2 viên bi đó thì sẽ có vị trí đúng(tốn 1 phép đổi
chỗ), các viên bi còn lại cứ mỗi 3 viên bi sẽ tốn 2 phép đổi chỗ*/
//Code:

#include <bits/stdc++.h>
using namespace std;

int n;
string str, tmp;

void init() { //hàm khởi tạo
    cin >> n;
    cin >> str;
}

void solve() { //hàm xử lý
    for (int i = 0; i < n; i++) {
        if (str[i] == 'X') str[i] = '1';
        else if (str[i] == 'T') str[i] = '2';
        else str[i] = '3';
    }
    tmp = str;
    sort (str.begin (), str.end ()); //tạo thứ tự đúng sau khi đã đổi chỗ
    int cnt = 0; //khởi tạo biến đếm
    for (int i = 0; i < n; i++) { //tìm các viên bi đã đứng đúng vị trí
        if (str[i] == tmp[i]) {
            cnt++;
            tmp[i] = 0;
        }
    }
    int res = 0;
    for (int i = 0; i < n - 1; i++) { //tìm các viên bi đứng ở vị trí của nhau
        for (int j = n; j > i; j--) {
            if (tmp[j] == str[i] && tmp[i] == str[j]) {
                res++; //tốn 1 phép đổi chỗ
                tmp[i] = 0; //đánh dấu đã đúng vị trí
                tmp[j] = 0;
                cnt += 2; //tăng số viên bi đã đứng đúng
            }
            if (cnt == n) break; //nếu đủ số bi thì dừng lại
        }
    }
    n -= cnt; //tìm số viên bi chưa đúng vị trí còn lại
    cout << res + (n / 3) * 2 << endl; //cứ 3 viên bi tốn 2 phép đổi chỗ
}

int main() {
    init ();
    solve ();
    return 0;
}
212. DSA05035	CHỮ SỐ SẮP XẾP TĂNG DẦN
/*Xét các số X có các chữ số được sắp xếp tăng dần, tức a[1] ≤ a[2] ≤ … ≤ a[N] trong đó a[1], a[2], …, a[N] lần lượt là
các chữ số của X. Chẳng hạn 223, 8999, …
Cho trước số chữ số N. Nhiệm vụ của bạn là đếm xem có bao nhiêu số như vậy.
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 100).
Mỗi test gồm một số nguyên dương N (1 ≤ N ≤ 100).
Output:
Với mỗi test, in ra đáp án tìm được trên một dòng theo modulo 109+7.
Ví dụ:
Input            Output
3
1                10
2                55
3                220
*/
/* Ý tưởng: số các số có i chữ số không giảm bắt đầu từ chữ số j bằng tổng của số các số có i-1 chữ số không giảm bắt
đầu từ chữ số j với số các số có i chữ số không giảm bắt đầu từ j+1*/
//Code:

#include <bits/stdc++.h>
using namespace std;

int n;
long m=1e9+7, dp[105][10];

void init() { //hàm khởi tạo
    for (int i = 0; i < 10; i++) dp[0][i] = 1; //số các số có 0 chữ số không giảm bắt đầu từ i là 1 số
    for (int i = 0; i <= 100; i++) dp[i][9] = 1; //số các số có i chữ số không giảm bắt đầu từ 9 là 1 số
}

void solve() { //hàm xử lý
    for (int i = 1; i <= n; i++)
        for (int j = 8; j >= 0; j--)
            dp[i][j] = (dp[i - 1][j] + dp[i][j + 1]) % m; //cập nhật kết quả
    cout << dp[n][0] << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    init ();
    while (t--) {
        cin >> n;
        solve ();
    }
    return 0;
}
213. DSA02041	BIẾN ĐỔI VỀ 1
/*Cho số nguyên dương N. Hãy đếm số bước ít nhất để đưa N về 1 bằng cách thực hiện ba thao tác dưới đây:
Nếu N chia hết cho 2 bạn có thể giảm N = N/2.
Nếu N chia hết cho 3 bạn có thể giảm N = N/3.
Giảm N đi 1.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một số N được viết trên một dòng.
T, N thỏa mãn ràng buộc: 1≤T≤100;  1≤N ≤100000.
Output:
Đưa ra kết quả mỗi test theo từng dòng
Input                 Output
2
10                    3
6                     2
*/
//Ý tưởng: thực hiện quay lui với tất cả các phép biến đổi có thể có đến khi về 1 thì cập nhật lại kết quả
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, int res;

void Try(int i, int cnt) { //hàm quay lui
    if (i == 1) { //khi về đến 1 cập nhật kết quả
        if (cnt < res) res = dem;
        return;
    }
    if (cnt >= res) return; //nếu số bước hiện tại không thoả mã thì dừng lại
    if (i % 3 == 0) Try (i / 3, cnt + 1); //thử với từng phương pháp biến đổi
    if (i % 2 == 0) Try (i / 2, cnt + 1);
    Try (i - 1, cnt + 1);
}

void init() { //hàm khởi tạo
    cin >> n;
}

void solve() { //hàm xử lý
    res = INT_MAX; //khởi tạo kết quả
    Try (n, 0); //gọi hàm quay lui
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
214. DSA05040	DÃY TAM GIÁC DÀI NHẤT
/*Cho dãy số A[] gồm có N phần tử.  Một dãy con liên tiếp được gọi là dãy tam giác nếu như dãy đó tăng dần rồi lại giảm
dần, hay tồn tại i, j, k sao cho A[i] < A[i+1] < … < A[k] > A[k+1] > … > A[j].
Nhiệm vụ của bạn là hãy tìm dãy con liên tiếp là dãy tam giác có độ dài lớn nhất.
Lưu ý: Dãy đơn điệu không giảm hoặc không tăng cũng là dãy tam giác. Ví dụ A[] = {10, 20, 30, 40} là một dãy tam giác.
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 10).
Mỗi test gồm số nguyên N(1≤ N ≤ 100 000).
Dòng tiếp theo gồm N số nguyên A[i] (0 ≤ A[i] ≤ 106).
Output:
Với mỗi test, in ra trên một dòng là độ dài của dãy con tìm được.
Input                Output
2
6                    5
12 4 78 90 45 23
8                    5
20 4 1 2 3 4 2 10
*/
//Ý tưởng: duyệt qua từng phần tử lưu lại dãy tam giác hiện tại, khi hết 1 dãy tam giác thì cập nhật lại kết quả
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, res, a[100005];

void init() { //hàm khởi tạo
    cin >> n;
    for (long i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    res = INT_MIN; //khởi tạo kết quả
    int cnt = 2; //khởi tạo biến đếm độ dài dãy tam giác hiện tại
    int state = 0; //biến trạng thái 1 ứng với sườn lên, 2 ứng với sườn xuống, 0 là chưa biết sườn nào do có 1 phần tử
    for (long i = 1; i < n; i++) {
        if (a[i] > a[i - 1] && state == 0) state = 1; //thay đổi trạng thái là sườn lên
        else if (a[i] > a[i - 1] && state == 1) cnt++; //nếu đang ở sườn lên tăng độ dài của dãy
        else if (a[i] > a[i - 1] && state == 2) { //nếu đang ở sườn xuống gặp phần tử không thoả mãn sườn xuống
            if (cnt > res) res = cnt; //cập nhật kết quả
            state = 1; //thay đổi trạng thái đang sườn lên (phần tử a[i-1] và a[i] tạo sườn lên mới)
            cnt = 2; //khởi tạo lại độ dài của dãy
        } else if (a[i] < a[i - 1] && state == 1) { //nếu đang ở sườn lên mà gặp phần tử không thoả mã sườn xuống
            cnt++; //tăng đồ dài dãy
            state = 2; //chuyển trạng thái sang sườn lên
        } else if (a[i] < a[i - 1] && state == 2) cnt++; //nếu đang ở sường xuống tăng độ dài của dãy
    }
    if (cnt > res) res = cnt; //cập nhật lại kết quả
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
215. DSA08025	QUÂN MÃ
/*Cho một quân mã trên bàn cờ vua tại vị trí ST. Nhiệm vụ của bạn là hãy tìm số bước di chuyển ít nhất để đưa quân mã
tới vị trí EN.
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test gồm 2 xâu dạng “xy” và “uv”, trong đó x, y là kí tự trong “abcdefgh” còn y, v là số thuộc 1, 2, 3, 4, 5, 6, 7, 8.
Output:
Với mỗi test, in ra đáp án tìm được trên một dòng
Input                 Output
8
e2 e4                 2
a1 b2                 4
b2 c3                 2
a1 h8                 6
a1 h7                 5
h8 a1                 6
b1 c3                 1
f6 f6                 0
*/
//Ý tưởng: sử dụng bfs để tạo ra tất cả các trường hợp có thể đi của quân mã
//Code:

#include <bits/stdc++.h>
using namespace std;

string str;
int start_row, start_col, dest_row, dest_col, vs[9][9];
int dx[] = {-2, -2, -1, -1, 1, 1, 2, 2}; //mảng tạo độ x của quân mã
int dy[] = {-1, 1, -2, 2, -2, 2, -1, 1}; //mảng toạ độ y của quân mã

void init() { //hàm khởi tạo
    getline (cin, str);
    start_col = str[0] - 96; //chuyển định dạng sang toạ độ kiểu số
    start_row = str[1] - 48;
    dest_col = str[3] - 96;
    dest_row = str[4] - 48;
}

bool check(int i, int j) { //hàm kiểm tra toạ độ của quân mã có nằm trên bàn cờ không
    if (i < 1 || i > 8 || j < 1 || j > 8) return false;
    return true;
}

void solve() { //hàm xử lý
    memset (vs, 0, sizeof (vs)); //làm mới mảng đã thăm
    queue <pair <int, int> > q;
    q.push ({start_row, start_col}); //đẩy toạ độ bắt đầu của quân mã vào hàng đợi
    vs[start_row][start_col] = 1; //đánh dẫu đã đi qua
    while (!q.empty ()) {
        int i = q.front ().first;
        int j = q.front ().second;
        q.pop ();
        for (int t = 0; t < 8; t++) { //thử với tất cả các hướng của quân mã
            int x = i + dx[t];
            int y = j + dy[t];
            if (check (x, y) && !vs[x][y]) { //nếu có 1 vị trí chưa được đi
                vs[x][y] = vs[i][j] + 1; //đánh dấu mất số bước để đi tới
                q.push ({x, y}); //đẩy nó vào hàng đợi
            }
        }
        if (vs[dest_row][dest_col]) { //nếu đã đến đích
            cout << vs[dest_row][dest_col] - 1 << endl; //đưa ra kết quả
            return;
        }
    }
}

int main() {
    int t;
    cin >> t;
    cin.ignore ();
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
216. DSA07041	BIỂU THỨC ĐÚNG DÀI NHẤT
/*Cho biểu thức P chỉ bao gồm các ký tự mở ngoặc ‘(’ hoặc đóng ngoặc ‘)’. Biểu thức P có thể viết đúng hoặc không đúng.
Nhiệm vụ của bạn là tìm tổng độ dài lớn nhất của các biểu thức con viết đúng trong P (các biểu thức đúng không nhất
thiết phải liên tiếp nhau).
Chú ý: Độ dài của biểu thức đúng ngắn nhất là 2.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T (không quá 100)
Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test là một biểu thức P được viết trên một dòng (độ dài của P
không quá 100).
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
4
(()(                 2
()()((               4
((()()())))          10
()(())(              6
*/
//Ý tưởng: sử dụng ngăn xếp, gặp 1 cặp () thì tăng lên 1
//Code:

#include<bits/stdc++.h>
using namespace std;

int res;
string str;

void init() { //hàm khởi tạo
    cin >> str;
}
 
void solve() { //hàm xử lý
    res = 0; //khởi tạo kết quả
    stack <char> s; //tạo 1 ngăn xếp chưa các dấu (
    for (int i = 0; i < str.length (); i++) {
        if (str[i] == '(') s.push (str[i]); //nếu gặp dấu ( thêm vào ngăn xếp
        else { //nếu gặp dấu ) 
            if (!s.empty ()) {
                res += 2; //ngăn xếp còn trống tăng số dấu ngoặc đúng
                s.pop (); //xoá dấu ngoặc đã dùng khỏi ngăn xếp
            }
        }
    }
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
217. DSA09028	TÔ MÀU ĐỒ THỊ
/*Một trong những bài toán kinh điển của lý thuyết đồ thị là bài toán Tô màu đồ thị. Bài toán được phát biểu như sau:
Cho đồ thị vô hướng G =<V, E> được biểu diễn dưới dạng danh sách cạnh và số M. Nhiệm vụ của bạn là kiểm tra xem đồ thị
có thể tô màu các đỉnh bằng nhiều nhất M màu sao cho hai đỉnh kề nhau đều có màu khác nhau hay không?
https://media.geeksforgeeks.org/wp-content/uploads/mcolor.png
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất đưa vào ba số V, E, M tương ứng với số
đỉnh, số cạnh và số màu; phần thứ hai đưa vào các cạnh của đồ thị.
T, V, E, M thỏa mãn ràng buộc: 1≤T ≤100; 1≤V≤10; 1≤ E ≤N(N-1), 1≤V≤N.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
2
4 5 3                 YES
1 2
2 3
3 4
4 1
1 3
3 3 2                 NO
1 2
2 3
1 3
*/
//Ý tưởng: sử dụng quay lui để tô tất cả các màu có thể cho đồ thị rồi kiểm tra xem có trường hợp nào thoả mãn hay không
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, m, color[105];
vector <int> edge[15];

void init() { //hàm khởi tạo
    cin >> v >> e >> m;
    int i, j;
    while (e--) {
        cin >> i >> j;
        edge[i].push_back (j); //tạo ma trận kề
        edge[j].push_back (i);
    }
}

int coloring(int u, int cl) { //hàm tô màu
    for (int i = 0; i < edge[u].size (); i++) if (color[edge[u][i]] == cl) return 0;
    return 1;
}

int Try(int i) { //hàm quay lui
    if (i == v + 1) return 1; //nếu tô hết các đỉnh thì dừng lại
    for (int j = 1; j <= m; j++) //thử tất cả các màu cho đỉnh hiện tại
        if (coloring (i, j)) { //kiểm tra màu được tô có hợp lệ hay không
            color[i] = j;
            if (Try (i + 1)) return 1; //tô tiếp đỉnh tiếp theo
            color[i] = 0; //trả lại lúc chưa tô màu
        }
    return 0;
}

void solve() { //hàm xử lý
    memset (color, 0, sizeof (color)); //gán tất cả các đỉnh chưa được tô màu
    if (Try (1)) cout << "YES"; //đưa ra kết quả
    else cout << "NO";
    cout << endl;
    for (int i = 1; i <= v; i++) edge[i].clear (); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
218. DSA09029	ĐƯỜNG ĐI HAMILTON
/*Đường đi đơn trên đồ thị có hướng hoặc vô hướng đi qua tất cả các đỉnh của đồ thị mỗi đỉnh đúng một lần được gọi là
đường đi Hamilton. Cho đồ thị vô hướng G = <V, E>, hãy kiểm tra xem đồ thị có đường đi Hamilton hay không?
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất đưa vào hai số V, E tương ứng với số
đỉnh, số cạnh của đồ thị; phần thứ hai đưa vào các cạnh của đồ thị.
T, V, E thỏa mãn ràng buộc: 1≤T ≤100; 1≤V≤10; 1≤ E ≤15.
Output:
Đưa ra 1 hoặc 0 tương ứng với test có hoặc không có đường đi Hamilton theo từng dòng.
Input                 Output
2
4 4                   1
1 2 2 3 3 4 2 4
4 3                   0
1 2 2 3 2 4
*/
//Ý tưởng: duyệt đường đi từ tất cả các đỉnh, đỉnh nào tồn tại đường đi hamilton thì trả về 1, không có trả về 0
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, check, vs[20];
vector <int> a[20];

void init() {
    cin >> v >> e;
    while (e--) {
        int i, j;
        cin >> i >> j;
        a[i].push_back (j); //tạo ma trận kề
        a[j].push_back (i);
    }
}

void dfs(int u, int cnt) { //hàm dfs
    if (check) return; //nếu tồn tại đường đi rồi thì dừng lại
    for (int i = 0; i < a[u].size (); i++) { //duyệt qua tất cả các đỉnh chưa được thăm kề với đỉnh hiện tại
        int tmp = a[u][i];
        if (!vs[tmp]) { //nếu tìm thấy
            vs[tmp] = 1; //đánh dấu đã thăm
            cnt++; //tăng số đỉnh được thăm
            if (cnt == v) { //nếu đủ các đỉnh tức tồn tại đường hamilton
                check = 1;
                return;
            }
            dfs (tmp, cnt); //gọi dfs tại đỉnh đó
            vs[tmp] = 0; //trả lại đỉnh chưa được thăm
            cnt--; //trả lại số đỉnh được thăm trước đó
        }
    }
}

void solve() { //hàm xử lý
    check = 0; //khởi tạo không có đường hamilton
    for (int i = 1; i <= v; i++) {
        memset (vs, 0, sizeof (vs)); //đánh dấu tất cả các đỉnh chưa được thăm
        vs[i] = 1;
        dfs (i, 1); //gọi dfs
        if (check) break; //nếu có đường hamilton rồi thì dừng lại
    }
    if (check) cout << "1" << endl; //đưa ra kết quả
    else cout << "0" << endl;
    for (int i = 1; i <= v; i++) a[i].clear (); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
219. DSA09030	ĐỒ THỊ HAI PHÍA
/*Đồ thị hai phía là một đồ thị đặc biệt, trong đó tập các đỉnh có thể được chia thành hai tập không giao nhau thỏa mãn
điều kiện không có cạnh nối hai đỉnh bất kỳ thuộc cùng một tập. Cho đồ thị N đỉnh và M cạnh, bạn hãy kiểm tra đồ thị đã
cho có phải là một đồ thị hai phía hay không?
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤  20).
Mỗi test bắt đầu bởi số nguyên N và M (1 ≤  N, M ≤  1000).
M dòng tiếp theo, mỗi dòng gồm 2 số nguyên u, v cho biết có cạnh nối giữa đỉnh u và v.
Output:
Với mỗi test, in ra “YES” nếu đồ thị đã cho là một đồ thị hai phía, in ra “NO” trong trường hợp ngược lại.
Input                 Output
2
5 4                   YES
1 5
1 3
2 3
4 5
3 3                   NO
1 2
1 3
2 3
*/
//Ý tưởng: sử dụng bfs nếu đỉnh được duyệt tới cùng nhóm với đỉnh hiện tại thì trả về false
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, check, vs[1005];
vector <int> edge[1005];

void init() { //hàm khởi tạo
    cin >> v >> e;
    while (e --) {
        int i, j;
        cin >> i >> j;
        edge[i].push_back(j); //tạo ma trận kề
        edge[j].push_back(i);
    }
}

void bfs(int u) { //hàm bfs
    vs[u] = 1; //đánh dấu đỉnh được thăm
    queue <int> q;
    q.push (u);
    while (!q.empty ()) {
        u = q.front (); //gán u là đỉnh đầu tiên của hàng đợi
        q.pop ();
        for (int i = 0; i < edge[u].size (); i++) { //duyệt tới tất cả các đỉnh kề với đỉnh u
            int tmp = edge[u][i];
            if (!vs[tmp]) { //nếu chưa được thăm đánh dấu khác nhóm với đỉnh u
                if (vs[u] == 1) vs[tmp] = 2;
                else vs[tmp] = 1;
                q.push (tmp); //thêm đỉnh đó vào hàng đợi
            } else if (vs[tmp] == vs[u]) { //nếu cùng nhóm với đỉnh u trả về sai
                check = 0;
                return;
            }
        }
    }
}

void solve() { //hàm xử lý
    check = 1; //khởi tạo kết quả
    for (int i = 1; i <= v; i++) vs[i] = 0; //đánh dấu tất cả các đỉnh chưa được thăm
    for (int i = 1; i <= v; i++)
        if (!vs[i]) { //nếu đỉnh chưa được thăm duyệt bfs tại đó
            if (check) bfs (i);
            else break; //nếu đã có kết quả thì dừng lại
        }
    if (check) cout << "YES" << endl; //đưa ra kết quả
    else cout << "NO" << endl;
    for (int i = 1; i <= v; i++) edge[i].clear (); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t --) {
        init();
        solve();
    }
    return 0;
}
220. DSA09033	MẠNG XÃ HỘI
/*Tý đang xây dựng một mạng xã hội và mời các bạn của mình dùng thử. Bạn của bạn cũng là bạn. Vì vậy, Tý muốn mạng xã
hội của mình là hoàn hảo, tức với mọi bộ ba X, Y, Z, nếu X kết bạn với Y, Y kết bạn với Z thì X và Z cũng phải là bạn bè
của nhau trên mạng xã hội.
Các bạn hãy xác định xem mạng xã hội hiện tại của Tý có là hoàn hảo hay không? Nếu có hãy in ra “YES”, “NO” trong trường
hợp ngược lại.
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test bắt đầu bởi 2 số nguyên N và M (N, M ≤ 100 000).
M dòng tiếp theo, mỗi dòng gồm 2 số nguyên u, v (u #v) cho biết u và v là kết bạn với nhau trên mạng xã hội của Tý.
Output:
Với mỗi test, in ra đáp án tìm được trên một dòng.
Input                 Output
3
4 3                   YES
1 3
3 4
1 4
4 4                   NO
3 1
2 3
3 4
1 2
10 4                  YES
4 3
5 10
8 9
1 2
*/
//Ý tưởng: để là mạng xã hội hoàn hảo thì với mỗi thành phần liên thông gồm n đỉnh thì sẽ cần có n * (n - 1) / 2 cạnh.
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, cntEdge, vs[100005];
vector <int> edge[100005];

void init() { //hàm khởi tạo
    cin >> v >> e;
    int x, y;
    for (int i = 0; i < e; i++) {
        cin >> x >> y;
        edge[x].push_back (y); //tạo ma trận kề
        edge[y].push_back (x);
    }
}

void bfs(int u) { //hàm bfs
    vs[u] = 1; //đánh dấu đã thăm
    queue <int> q;
    q.push (u);
    int cnt = 1; //khởi tạo số đỉnh đã thăm
    while (!q.empty ()) {
        u = q.front (); //gán u là đỉnh ở đầu hàng đợi
        q.pop ();
        for (int i = 0; i < edge[u].size (); i++) { //duyệt tới tất cả các đỉnh chưa thăm kề với đỉnh u
            int tmp = edge[u][i];
            if (!vs[tmp]) { //nếu tìm thấy
                cnt++; //tăng số đỉnh đã thăm
                vs[tmp] = 1; //đánh dấu đã thăm
                q.push (tmp); //thêm đỉnh đó vào hàng đợi
            }
        }
    }
    cntEdge += cnt * (cnt - 1) / 2; //cập nhật lại số cạnh
}

void solve() { //hàm xử lý
    cntEdge = 0; //khởi tạo số cạnh
    for (int i = 1; i <= v; i++) vs[i] = 0; //đánh dấu tất cả các đỉnh chưa được thăm
    for (int i = 1; i <= v; i++) if (!vs[i]) bfs (i); //duyệt bfs tại đỉnh chưa được thăm
    if (cntEdge != e) cout << "NO"; //đưa ra kết quả
    else cout << "YES";
    cout << endl;
    for (int i = 1; i <= v; i++) edge[i].clear (); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
221. DSA09036	GIẤY KHAI SINH
/*Một buổi họp mặt đại gia đình nhân dịp cụ già Ted tròn 100 tuổi, người ta muốn sắp xếp con cháu của cụ theo thứ tự từ
tuổi cao xuống thấp. Giả sử ta có thông tin về giấy khai sinh của từng người đó. Mỗi giấy khai sinh chỉ viết ba thông
tin đơn giản gồm: Tên người cha, Tên người con, Tuổi của người cha lúc sinh con.
Hãy giúp đại gia đình trên tính ra tuổi của từng người con cháu cụ Ted và viết ra danh sách theo thứ tự từ tuổi cao
xuống thấp.
Input
Dòng đầu ghi số bộ test (không quá 100). Với mỗi bộ test:
Dòng đầu tiên ghi số X (0<X<100) là số người con cháu cần sắp xếp.
Tiếp theo là X dòng, mỗi dòng ghi thông tin về một giấy khai sinh của từng người (thứ tự ngẫu nhiên) gồm 3 thành phần,
mỗi thành phần cách nhau một khoảng trống:
Tên người cha: không quá 20 ký tự và không chứa khoảng trống
Tên người con: không quá 20 ký tự và không chứa khoảng trống
Tuổi của người cha khi sinh con: 1 số nguyên dương, không quá 100.
Output
Với mỗi bộ test, in ra màn hình thứ tự bộ test (xem thêm trong bộ test ví dụ), sau đó lần lượt là từng người trong danh
sách tuổi từ cao xuống thấp (không tính cụ Ted). Mỗi người viết ra hai thông tin: tên, một khoảng trống rồi đến tuổi của
người đó.
Nếu hai người có cùng tuổi thì xếp theo thứ tự từ điển.
Input                 Output
2
1                     DATASET 1
Ted Bill 25           Bill 75
4                     DATASET 2
Ray James 40          Ray 80
James Beelzebub 17    James 40
Ray Mark 75           Beelzebub 23
Ted Ray 20            Mark 5
*/
//Ý tưởng: tìm tuổi của từng người sau đó sắp xếp sử dụng cmp
//Code:

#include <bits/stdc++.h>
using namespace std;

struct person { //kiểu dữ liệu người
    string father, son; //gồm tên cha và tên con
    int ageF, ageS; //tuổi của cha và tuổi của con
};

int x;
person a[102];

int cmp(person i, person j) { //hàm so sánh thứ tự của 2 người
    if (i.ageS < j.ageS) return 0;
    else if (i.ageS == j.ageS) if (i.son > j.son) return 0;
    return 1;
}

void init() { //hàm khởi tạo
    cin >> x;
    for (int i = 0; i < x; i++) cin >> a[i].father >> a[i].son >> a[i].ageF;
}

void solve(int t) {
    queue <pair <string, int> > q;
    q.push ({"Ted", 100}); //thêm cụ Ted và tuổi của cụ vào hàng đợi
    while (!q.empty ()) {
        string tmp = q.front ().first; //lấy ra người đầu tiên trong hàng đợi
        int age = q.front ().second; //lấy ra tuổi của người đó
        q.pop ();
        for (int i = 0; i < x; i++) { //tìm tất cả con của người đó
            if (a[i].father == tmp) {
                a[i].ageS = age - a[i].ageF; //tính tuổi con của người đó
                q.push ({a[i].son, a[i].ageS}); //thêm người con đó vào hàng đợi
            }
        }
    }
    sort (a, a + x, cmp); //sắp xếp lại theo thứ tự
    cout << "DATASET " << t << endl;
    for (int i = 0; i < x; i++) cout << a[i].son << " " << a[i].ageS << endl; //đưa ra kết quả
}


int main() {
    int t;
    cin >> t;
    for (int i = 1; i <= t; i++) {
        init ();
        solve (i);
    }
    return 0;
}
222. DSA05032	XÂU ĐỐI XỨNG 1
/*Cho xâu ký tự str. Nhiệm vụ của bạn là tìm số phép chèn tối thiểu các ký tự vào str để str trở thành xâu đối xứng. Ví
dụ: str =”ab” ta có số phép chèn tối thiểu là 1 để trở thành xâu đối xứng “aba” hoặc “bab”. Với xâu str=”aa” thì số phép
chèn tối thiểu là 0. Với xâu str=”abcd” có số phép chèn tối thiểu là 3 để trở thành xâu “dcbabcd”
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một xâu ký tự được viết trên một dòng
T, str thỏa mãn ràng buộc: 1≤T≤100;  1≤length(str)≤40.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
3
abcd                  3
aba                   0
geeks                 3
*/
//Ý tưởng: số ký tự cần thêm vào bằng độ dài xâu trừ đi dãy con chung dài nhất của xâu với xâu nghịch đảo
//Code:

#include <bits/stdc++.h>
using namespace std;

string str;
int dp[50][50]; //số phép chèn tối thiểu của xâu bắt đầu bằng i và kết thúc bằng j

void init() { //hàm khởi tạo
    cin >> str;
}

void solve() { //hàm xử lý
    memset (dp, 0, sizeof (dp)); //khởi tạo mảng dp
    for (int i = 1; i < str.length (); i++) //xâu đối xứng tối thiểu có 2 ký tự nên điểm kết thúc bắt đâu tại 1
        for (int j = 0, k = i; k < str.length (); j++, k++) { //j là điểm bắt đầu, k là điểm kết thúc của xâu con
            if (str[j] == str[k]) dp[j][k] = dp[j + 1][k - 1]; //số phép chèn bằng số phép chèn của xâu con trước đó 
            //nếu 2 ký tự không trùng nhau thì số phép chèn bằng số phép chèn tối thiểu của xâu độ dài có (k-j) + 1
            else dp[j][k] = min (dp[j + 1][k], dp[j][k - 1]) + 1; 
        }
    cout << dp[0][str.length () - 1] << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
223. DSA05033	XÂU ĐỐI XỨNG 2
/*Cho xâu ký tự S. Nhiệm vụ của bạn là tìm số phép loại bỏ ít nhất các ký tự trong S để S trở thành xâu đối xứng. Chú ý,
phép loại bỏ phải bảo toàn tính trước sau của các ký tự trong S.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một xâu ký tự được viết trên một dòng
T, str thỏa mãn ràng buộc: 1≤T≤100;  1≤length(S)≤100.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
2
aebcbda               2
geeksforgeeks         8
*/
//Ý tưởng: số phép xoá cũng chính bằng số phép chèn
//Code:

#include <bits/stdc++.h>
using namespace std;

string str;
int n, dp[105][105]; //mảng dp là độ dài xâu đối xứng dài nhất của xâu có điểm bắt đầu bằng i kết thúc bằng j

void init() { //hàm khởi tạo
    cin.ignore();
    cin >> str;
    n = str.length(); //n là độ dài của xâu

}
void solve() { //hàm xử lý
    for (int i = 0; i < n - 1; i++) dp[i][i] = 1; //xâu đối xứng có điểm đầu và điểm cuối trùng nhau có độ dài là 1 
    for (int cl = 1; cl <= n; cl++) //tìm xâu con chung dài nhất của xâu ban đầu với xâu nghịch đảo của nó
        for (int i = 0; i < n - cl; i++) { //i là vị trí được duyệt đến của xâu ban đầu
            int j = i + cl; //j là vị trí của i ở xâu nghịch đảo
            if (str[i] == str[j] && cl == 1) dp[i][j] = 2; //khởi tạo giá trị ban đầu
            else if (str[i] == str[j]) dp[i][j] = dp[i + 1][j - 1] + 2; //dp[i][j] bằng độ dài của xâu trước +2
            //nếu khác nhau thì bằng max của xâu có độ dài j-i
            else dp[i][j] = max (dp[i + 1][j], dp[i][j - 1]); 
        }
    cout << n - dp[0][n - 1] << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
224. DSA10008	DIJKSTRA
/*Cho đồ thị có trọng số không âm G=<V, E> được biểu diễn dưới dạng danh sách cạnh trọng số. Hãy viết chương trình tìm
đường đi ngắn nhất từ đỉnh uÎV đến tất cả các đỉnh còn lại trên đồ thị.
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm |E|+1 dòng: dòng đầu tiên đưa vào hai ba số |V|, |E| tương ứng
với số đỉnh và uÎV là đỉnh bắt đầu; |E| dòng tiếp theo mỗi dòng đưa vào bộ ba uÎV, vÎV, w tương ứng với một cạnh cùng
với trọng số canh của đồ thị.
T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra kết quả của mỗi test theo từng dòng. Kết quả mỗi test là trọng số đường đi ngắn nhất từ đỉnh u đến các đỉnh còn
lại của đồ thị theo thứ tự tăng dần các đỉnh.
Input                 Output
1
9 12 1
1 2 4
1 8 8
2 3 8
2 8 11
3 4 7
3 6 4
3 9 2
4 5 9
4 6 14
5 6 10
6 7 2
6 9 6
*/
//Ý tưởng: sử dụng hàng đợi ưu tiên để cập nhật đường đi nhỏ nhất đến đỉnh đó
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, s, d[1005];
vector <pair <int, int> > a[1005];
priority_queue <pair <int, int>, vector<pair <int, int> >, greater<pair <int, int> > > q;

void init() { //hàm khởi tạo
    cin >> v >> e >> s;
    while (e--) {
        int x, y, z;
        cin >> x >> y >> z;
        a[x].push_back ({z, y}); //tạo ma trận kề
        a[y].push_back ({z, x});
    }
}

void solve(){ //hàm xử lý
    for (int i = 1; i <= v; i++) d[i] = INT_MAX; //khởi tạo giá trị max cho đường đi đến mọi đỉnh
    while (!q.empty ()) q.pop (); 
    d[s] = 0; //bắt đầu từ đỉnh s nên chi phí đến s=0
    q.push ({0, s}); //thêm đỉnh s vào hàng đợi
    while (!q.empty ()) {
        s = q.top ().second;
        q.pop ();
        for (int i = 0; i < a[s].size (); i++) { //tìm tất cả các đỉnh kể với s
            int x = a[s][i].second;
            int y = a[s][i].first;
            if (d[x] > d[s] + y) { //cập nhật chi phí nhỏ nhất
                d[x] = d[s] + y;
                q.push ({d[x], x}); //thêm đỉnh đó vào hàng đợi
            }
        }
    }
    for (int i = 1; i <= v; i++) cout << d[i] << " "; //đưa ra kết quả
    cout << endl;
    for (int i = 1; i <= v; i++) a[i].clear (); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
225. DSA10009	FLOYD
/*Cho đơn đồ thị vô hướng liên thông G = (V, E) gồm N đỉnh và M cạnh, các đỉnh được đánh số từ 1 tới N và các cạnh được
đánh số từ 1 tới M.
Có Q truy vấn, mỗi truy vấn yêu cầu bạn tìm đường đi ngắn nhất giữa đỉnh X[i] tới Y[i].
Input:
Dòng đầu tiên hai số nguyên N và M (1 ≤ N ≤ 100, 1 ≤ M ≤ N*(N-1)/2).
M dòng tiếp theo, mỗi dòng gồm 3 số nguyên u, v, c cho biết có cạnh nối giữa đỉnh u và v có độ dài bằng c (1 ≤ c ≤ 1000).
Tiếp theo là số lượng truy vấn Q (1 ≤ Q ≤ 100 000).
Q dòng tiếp theo, mỗi dòng gồm 2 số nguyên X[i], Y[i].
Output:
Với mỗi truy vấn, in ra đáp án là độ dài đường đi ngắn nhất tìm được.
Input                 Output
5 6
1 2 6
1 3 7
2 4 8
3 4 9
3 5 1
4 5 2
3
1 5                   8
2 5                   10
4 3                   3
*/
//Ý tưởng: dùng ma trận lưu lại đường đi nhỏ nhất giữa các cặp đỉnh
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, e, d[105][105];

void init() { //hàm khởi tạo
    cin >> n >> e;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++) {
            if (i == j) d[i][j] = 0; //đường đi từ 1 đỉnh đến chính nó bằng 0
            else d[i][j] = INT_MAX; //khởi tạo đường đi từ đỉnh này đến đỉnh khác bằng max tức chưa có đường đi
        }
    while (e--) {
        int i, j, k;
        cin >> i >> j >> k;
        d[i][j] = k; //chi phí đi từ đỉnh i đến đỉnh j
        d[j][i] = k;
    }
}

void solve() { //hàm xử lý
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++) //nếu đường đi từ đỉnh i đến đỉnh j lớn hơn tổng đường đi i->k->j thì thay thế
                if (d[i][k] != INT_MAX && d[k][j] != INT_MAX && d[i][j] > d[i][k] + d[k][j])
                    d[i][j] = d[i][k] + d[k][j];
    int q;
    cin >> q;
    while (q--) {
        int u, v;
        cin >> u >> v;
        cout << d[u][v] << endl; //đưa ra kết quả
    }
}

int main() {
    init ();
    solve ();
    return 0;
}
226. DSA02011	MÁY ATM
/*Một máy ATM hiện có n (n ≤ 30) tờ tiền có giá trị t[1], t[2], …, t[n]. Hãy tìm cách trả ít tờ nhất với số tiền đúng
bằng S (các tờ tiền có giá trị bất kỳ và có thể bằng nhau, mỗi tờ tiền chỉ được dùng một lần).
Input: Dòng đầu tiên ghi số bộ test T (T<10). Mỗi bộ test gồm 2 số nguyên n và S (S ≤ 109). Dòng thứ hai chứa n số
nguyên t[1], t[2], …, t[n] (t[i] ≤ 109)
Output: Với mỗi bộ test ghi ra số tờ tiền ít nhất phải trả.
Nếu không thể tìm được kết quả, in ra -1.
Intput               Output
1
3 5                  1
1 4 5
*/
//Ý tưởng: sử dụng quay lui với 0 và 1 ứng với không sử dụng và có sử dụng tờ tiền hiện tại
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, cnt, res;
long long s, sum, sumbest, a[30];

void reset(int i) { //hàm reset trả về các giá trị khi chưa sử dụng a[i]
    sum -= a[i];
    sumbest += a[i];
    cnt--;
}

void Try(int i) { //hàm quay lui
    for (int j = 1; j >= 0; j--) {
        if (j == 1) { //nếu sử dụng a[i]
            sum += a[i]; //tăng tổng hiện tại
            sumbest -= a[i]; //giảm tổng tối đa có thể
            cnt++; //tăng số tờ tiền
            if (sum == s) {
                if (cnt < res) res = cnt; //cập nhật kết quả
                reset (i); //gọi hàm reset
                return; //dừng nhánh
            } else if (sum > s || sumbest < s - sum || cnt >= res) { //nếu không thoản mãn dừng nhánh
                reset (i); //gọi hàm reset
                return;
            } else {
                if (i > 0) Try (i - 1); //nếu chưa trả đủ tiền tiếp tục gọi quay lui
            }
            reset (i); //gọi hàm reset
        } else {
            if (i > 0) Try (i - 1); //nếu chưa trả đủ tiền tiếp tục gọi quay lui
        }
    }
}

void init() {
    cin >> n >> s;
    sumbest = 0; //sumbest là tổng số tiền lớn nhất còn có thể trả
    for (int i = 0; i < n; i++) {
        cin >> a[i];
        sumbest += a[i];
    }
}

void solve() { //hàm xử lý
    if (sumbest < s) { //nếu không thể trả tiền đưa ra -1
        cout << "-1" << endl;
        return;
    }
    res = INT_MAX, sum = 0, cnt = 0; //khởi tạo các giá trị ban đầu
    sort (a, a + n); //sắp xếp lại giá trị các tờ tiền
    Try (n - 1); //gọi hàm quay lui từ tờ tiền lớn nhất
    if (res == INT_MAX) cout << "-1"; //đưa ra kết quả
    else cout << res;
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
227. DSA02009	CHIA MẢNG
/*Cho mảng các số nguyên A[] gồm N phần tử. Hãy chia mảng số nguyên A[] thành K tập con khác rỗng sao cho tổng các
phần tử của mỗi tập con đều bằng nhau. Mỗi phần tử thuộc tập con xuất hiện duy nhất một lần trong tất cả các tập
con. Ví dụ với A[] = {2, 1, 4, 5, 6}, K =3 ta có kết quả {2, 4}, {1, 5}, {6}.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất là hai số N và K; dòng tiếp theo
đưa vào N số của mmảng A[]; các số được viết cách nhau một vài khoảng trống.
T, N, K, A[i] thỏa mãn ràng buộc: 1≤T ≤100; 1≤N, K≤20, 0≤A[i]≤100.
Output:
Đưa ra 1 nếu có thể chia tập con thành K tập thỏa mãn yêu cầu bài toán, ngược lại đưa ra 0.
Input                Output
2
5 3
2 1 4 5 6            1
5 3
2 1 5 5 6            0
*/
//Ý tưởng: Tìm từng cặp tổng bằng sum/k. Nếu số cặp đúng bằng k thì đưa ra 1 còn lại đưa ra 0
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, k, sum, check, a[20];
bool used[100];

void init() { //hàm khởi tạo
    cin >> n >> k;
    sum = 0;
    check = 0;
    for (int i = 0; i < n; i++) { //tính tổng chung sao đó gán tất cả vị trí đều chưa sử dụng
        cin >> a[i];
        sum += a[i];
        used[i] = false;
    }
}

void Try(int s, int cnt) { //hàm quay lui
    if (check)return; //nếu đã chia được thì dừng lại
    for (int i = 0; i < n; i++) {
        if (used[i] == false) { //nếu chưa sử dụng thì tăng tổng của mảng hiện tại lên và đánh dấu là đã sử dụng
            s += a[i];
            used[i] = true;
            if (s == sum) { //nếu tồng mảng con bằng sum thì tăng số cặp lớn hơn thì dừng lại còn nhỏ hơn thì thử tiếp
                cnt++;
                /*
                nếu đã đủ cặp thì cập nhật kết quả đã đúng còn chưa thì thử tiếp với tổng mảng con bằng 0 và số cặp
                hiện tại
                */
                if (cnt == k) {
                    check = 1;
                    return;
                } else Try (0, cnt);
            } else if (s > sum) return;
            else Try (s, cnt);
            s -= a[i];   //trả lại tổng mảng con sau khi sử dụng a[i]
        }
        used[i] = false; //gán lại phần tử i chưa sử dụng
    }
}

void solve() {
    if (sum % k != 0)
        cout << "0" << "\n"; //nếu tổng không chia hết cho k thì in 0 luôn còn nếu chia hết thì tiếp tục thử
    else {
        sum /= k; //gán tổng bằng tổng của mỗi mảng con cần tìm
        Try (0, 0); //thử với tổng của mỗi mảng bằng 0 và số mảng bằng 0
        if (check == 0) cout << "0" << endl; //đưa ra kết quả
        else cout << "1" << endl;
    }
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
228. DSA02010	TỔ HỢP SỐ CÓ TỔNG BẰNG X
/*Cho mảng A[] gồm N số nguyên dương phân biệt và số X. Nhiệm vụ của bạn là tìm phép tổ hợp các số trong mảng A[] có
tổng bằng X. Các số trong mảng A[] có thể được sử dụng nhiều lần. Mỗi tổ hợp các số của mảng A[] được in ra theo thứ tự
không giảm các số. Ví dụ với A[] = {2, 4, 6, 8}, X = 8 ta có các tổ hợp các số như sau:
[2, 2, 2, 2], [2, 2, 4], [2, 6], [4, 4], [8].
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất là hai số N và X; dòng tiếp theo đưa vào
N số của mmảng A[]; các số được viết cách nhau một vài khoảng trống.
T, N, X, A[i] thỏa mãn ràng buộc: 1≤T ≤10; 1≤X, A[i]≤100. N ≤ 20.
Output:
Đưa ra kết quả mỗi test theo từng dòng. Mỗi đường tổ hợp được bao bởi cặp ký tự [, ]. Đưa ra -1 nếu không có tổ hợp nào
thỏa mãn yêu cầu bài toán.
Input                 Ouput
1
4 8                   [2 2 2 2][2 2 4][2 6][4 4][8]
2  4  6  8
2  4  6  8
*/
//Ý tưởng: sư dụng quay lui với 0 và 1 ứng với không sử dụng và sử dụng phần tử a[i]
//Code:

#include <bits/stdc++.h>
using namespace std;
int check, n, x, a[20];

void Try(int i, int sum, vector <int> res) { //hàm quay lui
    for (int j = 1; j >= 0; j--) {
        if (j == 1) {
            res.push_back (a[i]);  //sử dụng thì đẩy vào mảng kết quả và tăng tổng
            sum += a[i];
            //nếu tổng bằng x đánh dấu đã đúng và in ra kết quả tổng lớn hơn x thì dừng lại và nhỏ hơn x thì thử tiếp
            if (sum == x) {
                check = 1;
                cout << "[";
                for (int k = 0; k < res.size () - 1; k++) cout << res[k] << " "; //đưa ra kết quả
                cout << res[res.size () - 1] << "]";
                return;
            } else if (sum > x) return; //nếu tổng lớn hơn x thì dừng nhánh
            else Try (i, sum, res); //nếu chưa bằng x thì tiếp tục quay lui
            //trả lại sum và mảng kết quả trước đó để chuyển sang trường hợp không sử dụng
            sum -= a[i];
            res.pop_back ();
        } else {
            if (i < n - 1) Try (i + 1, sum, res); //không sử dụng thì thử tiếp với trường hợp i+1
        }
    }
}

void init() { //hàm khởi tạo
    cin >> n >> x;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    check = 0; //khởi tạo biến kiểm tra
    vector <int> res; //khởi tạo vector kết quả
    Try (0, 0, res); //gọi hàm quay lui
    if (check == 0) cout << "-1";  //nếu không có kết quả in ra -1
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
229. DSA02015	LOẠI BỎ DẤU NGOẶC
/*Cho biểu thức P chỉ chứa các ký tự ‘(’, ‘)’ và các ký tự. Không có phép toán nào trong biểu thức P. Nhiệm vụ của bạn
là thực hiện ít nhất các phép loại bỏ các ký tự ‘(’, ‘)’ để P trở thành biểu thức đúng. Chú ý: một biểu thức chỉ có 1 ký
tự chữ (không có dấu ngoặc) hoặc một biểu thức rỗng thì không được xem là biểu thức đúng.
Nếu có nhiều hơn một biểu thức đúng với cùng số phép loại bỏ ít nhất hãy đưa ra tất cả các biểu thức đúng theo thứ tự từ
điển.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một biểu thức P được viết trên một dòng.
T, P thỏa mãn ràng buộc: 1≤T ≤100; 1≤length(P)≤100.
Output:
Đưa ra kết quả mỗi test theo từng dòng. Nếu không có đáp án, in ra -1.
Input                 Output
2
()())()               (())() ()()()
(u)())()              (u())() (u)()()
*/
//Ý tưởng: sử dụng hàng đợi thêm 2 trường hợp sử dụng và không sử dụng phần tử thứ i sau đó kiểm tra biểu thức đúng
//Code:

#include <bits/stdc++.h>
using namespace std;
vector <string> res;
string str;
map <string, int> mm;

bool check(string str) { //hàm kiểm tra biểu thức
    if (str.length () == 1 || str == "") return 0; //xâu độ đài nhỏ hơn 2 luôn sai
    stack <char> s;
    for (int i = 0; i < str.length (); i++) {
        if (str[i] == '(') s.push (str[i]); //gặp dấu ( thì thêm vào ngăn xếp
        else if (str[i] == ')') { //nếu gặp dấu )
            if (s.empty ()) return false; //trong ngăn xếp không có dấu ( thì biểu thức sai
            else s.pop ();  //nếu có xoá dấu ( ở đỉnh ngăn xếp
        }
    }
    if (s.empty ()) return true; //nếu ngăn xếp vẫn còn dấu ( thì biểu thức sai
    else return false;
}

void init() { //hàm khởi tạo
    cin >> str;
}

void solve() { //hàm xử lý
    queue <string> q;
    q.push (str);
    int flag = 0;
    mm[str] = 1; //đánh dấu đã tạo ra biểu thức này rồi
    while (!q.empty ()) {
        string tmp = q.front (); //lấy ra phần tử đầu của hàng đợi
        q.pop ();
        if (check (tmp)) { //nếu là biểu thức đúng
            flag = 1; //đánh dấu đã tìm thấy
            res.push_back (tmp); //thêm vào kết quả
        }
        if (flag == 0) { //khi tìm được phép loại bỏ đúng thì không duyệt nữa
            for (int i = 0; i < tmp.length (); i++) {
                if (tmp[i] == '(' || tmp[i] == ')') {
                    string s1 = tmp;
                    s1.erase (s1.begin () + i); //thực hiện xoá dấu ngoặc
                    if (mm[s1] == 0) {
                        mm[s1] = 1; //đánh dấu biểu thức đã có rồi
                        q.push (s1); //thêm vào hàng đợi
                    }
                }
            }
        }
    }
    if (res.size () == 0) cout << -1; //đưa ra kết quả
    else {
        sort (res.begin (), res.end ());
        for (int i = 0; i < res.size (); i++) cout << res[i] << " ";
    }
    cout << endl;
    res.clear (); //làm mới kết quả
    mm.clear (); //làm mới mảng đánh dấu
}


int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
230. DSA02022	NGƯỜI DU LỊCH
/*Cho n thành phố đánh số từ 1 đến n và các tuyến đường giao thông hai chiều giữa chúng, mạng lưới giao thông này được
cho bởi mảng C[1…n, 1…n] ở đây C[i][j] = C[j][i] là chi phí đi đoạn đường trực tiếp từ thành phố i đến thành phố j. Một
người du lịch xuất phát từ thành phố 1, muốn đi thăm tất cả các thành phố còn lại mỗi thành phố đúng 1 lần và cuối cùng
quay lại thành phố 1. Hãy chỉ ra chi phí ít nhất mà người đó phải bỏ ra. Dữ liệu vào: Dòng đầu tiên là số nguyên n – số
thành phố (n ≤ 15); n dòng sau, mỗi dòng chứa n số nguyên thể hiện cho mảng 2 chiều C.
Kết quả: Chi phí mà người đó phải bỏ ra.
Input                 Output
4
0 20 35 10            117
20 0 90 50
35 90 0 12
10 50 12 0
*/
//Ý tưởng: sử dụng quay lui với 0 và 1 ứng với không đi qua và đi qua thành phố i
//Code:

#include <bits/stdc++.h>
using namespace std;

bool used[20]={0}; //mảng đánh dấu để đánh dấu những thành phố đã đi qua
int n, res=INT_MAX, a[20][20];
void Try(int i, int sum,int cnt){
    if(cnt==n-1){
        sum+=a[i][0]; //nếu đã đi qua hết các thành phố thì quay lại thành phố 1
        if(sum<res) res=sum;  //nếu tổng chi phí nhỏ hơn kết quả hiện tại thì gán kết quả hiện tại bằng tổng đó
        return; //dừng nhánh
    }
    for(int j=1;j<n;j++){
        if(used[j]== 0 && i!=j) {  //kiểm tra xem còn thành phố nào chưa đi
            sum += a[i][j]; //cộng chi phí đến thành phố đó
            if(sum>=res) return; //nếu tổng chi phí nhỏ hơn kết quả hiện tại thì đi tiếp
            used[j]=1;  //đánh dấu là đã đi qua
            Try (j, sum, cnt + 1);  //thử với vị trí hiện tại là thành phố j
            sum-=a[i][j]; //trả lại chi phí khi chưa đi qua
            used[j] = 0; //đánh dấu lại là chưa đi qua
        }
    }
}

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            cin >> a[i][j];
}

void solve() { //hàm xử lý
    Try (0, 0, 0);  //thử tại thành phố đầu tiên
    cout << res;  //đưa ra kết quả
}

int main() {
    init ();
    solve ();
    return 0;
}
231. DSA03014	SỐ KHỐI LẬP PHƯƠNG
/*Một số X được gọi là số khối lập phương nếu X là lũy thừa bậc 3 của số Y (X= Y3). Cho số nguyên dương N, nhiệm vụ của
bạn là tìm số khối lập phương lớn nhất bằng cách loại bỏ đi các chữ số của N. Ví dụ số 4125 ta có kết quả là 125 = 53.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một số tự nhiên N được viết trên một dòng.
T, N thỏa mãn ràng buộc: 1≤T≤100;  1≤N≤1018.
Output:
Đưa ra kết quả mỗi test theo từng dòng. Nếu không tìm được đáp án in ra -1.
Input                Output
2
4125                 125
976                  -1
*/
//Ý tưởng: sử dụng quay lui với 1 và 0 ứng với sử dụng và không sử dụng
//Code:

#include<bits/stdc++.h>
using namespace std;

vector<int>a; //tạo 1 vector a lưu các chữ số của n
long long res;
string str;

void Try(int i, long long sum) { //hàm quay lui
    for (int j = 1; j >= 0; j--) {
        if (j == 1) {
            sum = sum * 10 + a[i];  //số mới tạo thành khi sử dụng a[i]
            float x = cbrt (sum);  //kiểm tra xem số tạo thành có phải số khối lập phương không
            long long y = x / 1;
            //nếu số khối lập phương lớn hơn kết quả hiện tại thì gán kết quả bằng số đó
            if (x - y == 0 && sum > res) res = sum;
            if (i < a.size () - 1) Try (i + 1, sum); //nếu chưa duyệt hết vector a thì ta tiếp tục thử
            sum /= 10; //trả lại số ban đầu khi chưa sử dụng a[i]
        } else {
            if (i < a.size () - 1) Try (i + 1, sum); //nếu chưa duyệt hết vector a thì ta tiếp tục thử
        }
    }
}

void init() {
    cin >> str;
}

void solve() {
    a.clear ();  //làm trống vector a
    res = -1; //khởi tạo kết quả
    for (int i = 0; i < str.length (); i++) a.push_back (str[i] - 48); //đưa các chữ số của n vào vector a
    Try (0, 0); //gọi hàm quay lui
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
232. DSA04006	ĐẾM SỐ BÍT 1
/*Cho số nguyên dương N. Mỗi bước, bạn sẽ biến đổi N thành [N/2], N mod 2, [N/2]. Sau khi thực hiện một cách triệt để,
ta thu được một dãy số chỉ toàn số 0 và 1.
Nhiệm vụ của bạn là hãy đếm các số bằng 1 trong đoạn [L, R] của dãy số cuối cùng.
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test gồm 3 số nguyên N, L, R (1 ≤ N, L, R < 250, 0 ≤ R-L ≤ 100 000).
Output:
Với mỗi test, in ra đáp án trên một dòng.
Input                Output
2
7 2 5                4
10 3 10              5
*/
/*Ý tưởng: nếu k nhỏ hơn phần tử chính giữa hiện tại thì tìm kiếm với n/2 và giảm phần tử chính giữa xuống 2 lần, nếu k
đúng bằng phần tử chính giữa thì trả về kết quả là phép dư của n cho 2, còn lại sẽ tìm kiếm với n/2 và phần tử dối xứng
với k qua phần tử chính giữa hiện tại, i lẻ thì tại đó là phần tử 1*/
//Code:

#include<bits/stdc++.h>
using namespace std;

long long n, l, r, cnt;
vector <long long> a; //vector a dùng để lưu các vị trí chính giữa của dãy con

long long find(long long k, long long n, long long x) { //hàm tìm kiếm
    if (k < a[x]) return find (k, n / 2, x - 1);
    else if (k == a[x]) return n % 2;
    else return find (k - a[x], n / 2, x - 1);
}

void init() { //hàm khởi tạo
    cin >> n >> l >> r;
}

void solve() { //hàm xử lý
    cnt = 0; //khởi tạo biến đếm
    a.clear (); //xoá sạch vector a
    long long tmp = log2 (n); //tìm số mũ lớn nhất của 2^i

    for (long long i = 1; i <= tmp; i++) a.push_back (pow (2, i)); //đưa các luỹ thừa của 2 vào vector
    //tìm kiếm từ l đến r nếu i lẻ thì tại đó là phần tử 1 còn chẵn thì gọi hàm tìm kiếm
    for (long long i = l; i <= r; i++) {
        if (i % 2 == 1) cnt++;
        else cnt += find (i, n, tmp - 1);
    }
    cout << cnt << endl;   //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
233. DSA04014	CẶP NGHỊCH THẾ
/*Cho mảng A[] gồm N phần. Ta gọi cặp nghịch thế của mảng A[] là số các cặp i, j sao cho i<j và A[i]>A[j]. Đối với mảng
đã được sắp xếp thì số cặp nghịch thế bằng 0. Mảng đã sắp theo thứ tự giảm dần có số đảo ngược cực đại. Nhiệm vụ của bạn
là hãy đưa ra số cặp nghịch thế của mảng A[] gồm N phần tử.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất đưa vào số N tương ứng với số phần tử
của mảng A[]; phần thứ 2 là N số của mảng A[]; các số được viết cách nhau một vài khoảng trống.
T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤N≤107; 1≤A[i]≤1018.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
2
5                     3
2 4 1 3 5
5                     10
5 4 3 2 1
*/
//Ý tưởng: sử dụng merge sort
//Code:

#include <bits/stdc++.h>
using namespace std;

long n, res, a[1000005];

void init() { //hàm khởi tạo
    cin >> n;
    for (long i = 0; i < n; i++) cin >> a[i];
}

long merge(long l, long m, long r) { //hàm nhập
    long i = l, j = m, k = l, cnt = 0;
    long tmp[n]; //mảng tmp lưu lại kết quả khi đã sắp xếp
    while (i < m && j <= r) {
        if (a[i] <= a[j]) tmp[k++] = a[i++]; //nếu đúng thứ tự cập nhật mảng tmp
        else { //nếu không đúng thứ tự
            cnt += m - i; //tất cả các số còn lại của mảng bên trái sẽ đều lớn hơn phần tử a[j]
            tmp[k++] = a[j++]; //cập nhật mảng tmp
        }
    }
    while (i < m) tmp[k++] = a[i++]; //nếu mảng bên trái còn phần tử thì đưa nốt vào mảng tmp
    while (j <= r) tmp[k++] = a[j++]; //nếu mảng bên phải còn phần tử thì đưa nốt vào mảng tmp
    for (i = l; i <= r; i++) a[i] = tmp[i]; //trả lại đoạn đã sắp xếp
    return cnt; //trả về số cặp nghịch thế khi nhập 2 đoạn
}

long mergeSort(long l, long r) { //hàm sắp xếp nhập
    long cnt = 0; //khởi tạo biến đếm
    if (l < r) {
        long m = l + (r - l) / 2; //chia đoạn hiện tại thành 2 nửa
        cnt += mergeSort (l, m); //đếm số cặp nghịch thế ở nửa đầu
        cnt += mergeSort (m + 1, r); //đếm số cặp nghịch thế ở nửa sau
        cnt += merge (l, m + 1, r); //đếm sổ cặp nghịch thế khi nhập 2 mảng
    }
    return cnt; //trả về số cặp nghịch thế
}

void solve() { //hàm xử lý
    res = mergeSort (0, n - 1); //đếm cặp nghịch thế
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
234. DSA05010	DÃY CON DÀI NHẤT CÓ TỔNG CHIA HẾT CHO K
/*Cho một dãy gồm n ( n ≤ 1000) số nguyên dương A1, A2, ..., An và số nguyên dương k (k ≤ 50). Hãy tìm dãy con gồm nhiều
phần tử nhất của dãy đã cho sao cho tổng các phần tử của dãy con này chia hết cho k.
Input: Dòng đầu ghi số bộ test T (T<10). Mỗi bộ test gồm 2 dòng. Dòng đầu tiên chứa hai số n, k.  Dòng tiếp theo ghi n
số của dãy A. Các số đều không vượt quá 100.
Output: Gồm 1 dòng duy nhất ghi số lượng phần tử của dãy con dài nhất thoả mãn. Dữ liệu vào luôn đảm bảo sẽ có ít nhất
một dãy con có tổng chia hết cho k.
Input                 Output
1
10 3                  9
2 3 5 7 9 6 12 7 11 15
*/
//Ý tưởng: độ dài dãy con nếu sử dụng phần tử hiện tại bằng độ dài của dãy trước đó cộng 1, lưu trữ lại phần tử của tổng
//Code:

#include <bits/stdc++.h>
using namespace std;

void solve() { //hàm xử lý
    int n, k;
    cin >> n >> k;
    int dp[n + 1][k]; //mảng dp với i là độ dài của mảng được sử dụng và k phần dư của tổng cho k
    dp[0][0] = 0; //độ dài bằng 0 nên độ dài dãy con bằng 0
    for (int i = 1; i < k; i++) dp[0][i] = INT_MIN; //độ dài bằng 0 không tồn tại dãy con
    for (int i = 1; i <= n; i++) {
        int a;
        cin >> a;
        a %= k; //lưu lại phần tử của phần tử cho k
        for (int j = 0; j < k; j++) //kiểm tra xem nếu sử dụng và không sử dụng a[i] thì sẽ tối ưu hơn
            dp[i][j] = max (dp[i - 1][j], dp[i - 1][(j + k - a) % k] + 1);
    }
    cout << dp[n][0] << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        solve ();
    }
    return 0;
}
235. DSA05021	CẶP SỐ
/*Cho N cặp số, trong đó số thứ nhất bao giờ cũng nhỏ hơn số thứ 2. Ta nói, cặp số <c, d> được gọi là theo sau cặp số
<a,b> nếu b<c. Nhiệm vụ của bạn là tìm số lớn nhất chuỗi các cặp thỏa mãn ràng buộc trên. Ví dụ với các cặp
{<5, 24>, <39, 60>, <15, 28>, <27, 40>, <50, 90>} ta có kết quả là 3 tương ứng với chuỗi các cặp
{<5,24>, <27, 40>, <50, 90>}.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên đưa vào N là số cặp <a, b>; dòng tiếp
theo đưa vào 2*N số là N cặp số <a, b>; các số được viết cách nhau một vài khoảng trống.
T, N, a, b thỏa mãn ràng buộc: 1≤T≤100;  1≤N, a, b ≤100.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                          Output
2
5                              2
5  24 39 60 15 28 27 40 50 90
2                              1
5 10 1 11
*/
//Ý tưởng: cập nhật độ dài dãy con bằng cách lấy max của dãy hiện tại với tổng của dãy trước đó cộng với 1
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, dp[105];
pair <int, int> a[105];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i].first >> a[i].second;
}

void solve() { //hàm xử lý
    sort (a, a + n); //sắp xếp lại mảng a theo thứ tự tăng dần của first
    for (int i = 0; i < n; i++) dp[i] = 1; //số cặp tối thiểu là chính cặp hiện tại
    for (int i = 1; i < n; i++)
        for (int j = 0; j < i; j++)
            if (a[i].first > a[j].second) dp[i] = max (dp[i], dp[j] + 1); //cập nhật kết quả
    cout << dp[n - 1] << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
236. DSA05030	DI CHUYỂN VỀ GỐC TỌA ĐỘ
/*Giả sử bạn đang ở điểm có tọa độ nguyên dương (n,m) và cần dịch chuyển về tọa độ (0,0). Mỗi bước dịch chuyển bạn chỉ
được phép dịch chuyển đến tọa độ (n-1, m) hoặc (n, m-1); Từ ô (0,m), hoặc (n, 0) thì có thể di chuyển 1 bước để về gốc
(0,0). Hãy đếm số cách bạn có thể dịch chuyển về tọa độ (0,0).
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là bộ n, m được viết cách nhau một vài khoảng trống.
T, n, m thỏa mãn ràng buộc: 1≤T≤100;  1≤n, m ≤25.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
3
3 2                   10
3 6                   84
3 0                   1
*/
//Ý tưởng: số đường đi tại ô hiện tại bằng tổng đường đi của 2 ô đứng trước nó theo hàng và cột

#include <bits/stdc++.h>
using namespace std;

int n, m;
long dp[30][30];

void init() { //hàm khởi tạo
    cin >> n >> m;
}

void solve() { //hàm xử lý
    for (int i = 0; i <= 25; i ++) 
        for (int j = 0; j <= 25; j ++) {
            if (i == 0 || j == 0) dp[i][j] = 1; //khi i hoặc j bằng 0 thì có thể về luôn gốc toạ độ
            else dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; //cập nhật kết quả
        }
}

void print() { //hàm in
    cout << res[n][m] << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    solve();
    while (t --) {
        init();
        print();
    }
    return 0;
}
238. DSA07005	BIỂU THỨC TƯƠNG ĐƯƠNG
/*Cho biểu thức đúng P chỉ bao gồm các phép toán +, -, các toán hạng cùng với các ký tự ‘(’, ‘)’. Hãy bỏ tất cả các ký
tự ‘(’, ‘)’ trong P để nhận được biểu thức tương đương. Ví dụ với P = a – (b + c) ta có kết quả P = a – b – c .
Input: Dòng đầu tiên đưa vào số lượng bộ test T;
Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test là một biểu thức P được viết trên một dòng.
Output: Đưa ra kết quả mỗi test theo từng dòng.
Ràng buộc: T, P thỏa mãn ràng buộc: 1≤T≤100; 1≤length(P)≤10^3.
Input                 Output
2
a–(b+c)               a-b-c
a-(b-c-(d+e))-f       a-b+c+d+e-f
*/
//Ý tưởng: lưu lại vị trí của các dấu (, nếu trước nó là dấu - thì đổi dấu tất cả các phần tử từ dấu ( đến đấu )
//Code:

#include <bits/stdc++.h>
using namespace std;

string str;

void init(){
    cin >> str;
}

void solve() {
    stack <int> s;
    for (int i = 0; i < str.length (); i++)
        if (str[i] == '(' && i > 0) s.push (i); //thêm vào vị trí của dấu (, dấu ( ở đầu không có nghĩa
        else if (str[i] == ')' && !s.empty ()) { //nếu gặp dấu ) mà trước nó có dấu (
            if (str[s.top () - 1] == '-') { //kiểm tra xem trước dấu ( có phải dấu - không
                for (int j = s.top (); j < i; j++) { //nếu là dấu -
                    if (str[j] == '+') str[j] = '-'; //đổi dấu tất cả các dấu trong khoảng ngoặc
                    else if (str[j] == '-') str[j] = '+';
                }
            }
            s.pop (); //xoá đi dấu ngoặc đã xử lý rồi
        }
    for (int i = 0; i < str.length (); i++) //đưa ra kết quả
        if (str[i] != '(' && str[i] != ')') cout << str[i];
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    cin.ignore ();
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
239. DSA07006	XÓA DẤU NGOẶC
/*Cho biểu thức toán học đúng, bạn cần tìm tất cả các biểu thức đúng có thể bằng cách xóa bỏ các cặp dấu ngoặc tương ứng
với nhau từ biểu thức ban đầu.
Ví dụ: Cho biểu thức: (2+(2*2)+2) Các biểu thức tìm được:
(2+2*2+2)
2+(2*2)+2
2+2*2+2
Các biểu thức (2+2*2)+2 và 2+(2*2+2) không được chấp nhận vì không xóa đi các cặp dấu ngoặc tương ứng với nhau
Input: Một dòng chứa biểu thức gồm các số nguyên không âm, các dấu +, -, *, / và dấu ngoặc đơn.
Biểu thức không quá 200 kí tự, có chứa ít nhất 1 và không quá 10 cặp dấu ngoặc.
Output: In ra tất các các biểu thức khác nhau thỏa mãn đầu bài theo thứ tự từ điển
Input                 Output
(1+(2*(3+4)))         (1+(2*3+4))
                      (1+2*(3+4))
                      (1+2*3+4)
                      1+(2*(3+4))
                      1+(2*3+4)
                      1+2*(3+4)
                      1+2*3+4
*/
//Ý tưởng: xoá các cặp dấu ngoặc ( và ) tương ứng với nhau sau đó lưu vào set rồi in ra các phần tử của set
//Code:

#include <bits/stdc++.h>
using namespace std;

set <string> s;
set <string>::iterator it;
int n, cnt, a[10];
string str, tmp;
vector <pair <int, int> > v;

void init() { //hàm khởi tạo
    cin >> str;
    n = str.length () - 1;
}

void Try(int i) { //ham quay lui
    for (int j = 0; j <= 1; j++) {
        a[i] = j; //sinh ra các xâu nhị phân của v.size() tức là số cặp ngoặc biểu thị cặp ngoặc bị xoá, được sử dụng
        if (i == cnt - 1) { //khi sinh ra được 1 cấu hình
            bool used[205] = {0};
            for (int t = 0; t < cnt; t++) {
                if (a[t] == 1) {
                    used[v[t].first] = 1; //đánh dấu dấu ngoặc được sử dụng
                    used[v[t].second] = 1;
                }
            }
            string tmp = "";
            for (int t = 0; t <= n; t++)
                if (used[t] == 0) tmp += str[t]; //cập nhật biểu thức được tạo ra
            s.insert (tmp); //thêm nó vào set
        } else Try (i + 1); //nếu chưa đủ cấu hình tiếp tục quay lui
    }
}

void solve() { //hàm xử lý
    stack <int> st;
    cnt = 0; //khởi tạo số các cặp ngoặc
    for (int i = 0; i <= n; i++) { //lưu lại vị trí cặp ngoặc tương ứng
        if (str[i] == '(') {
            cnt++; //tăng số cặp ngoặc
            st.push (i);
        } else if (str[i] == ')') {
            v.push_back ({st.top (), i});
            st.pop ();
        }
    }
    sort (v.begin (), v.end ()); //sắp xếp lại thứ tự cặp dấu ngoặc
    Try (0); //bắt đầu quay lui
    s.erase (s.begin ()); //không in biểu thức ban đầu
    for (it = s.begin (); it != s.end (); it++) cout << *it << endl; //đưa ra kết quả
}

int main() {
    init ();
    solve ();
    return 0;
}
240. DSA07007	SO SÁNH BIỂU THỨC
/*Cho P1, P2 là hai biểu thức đúng chỉ bao gồm các ký tự mở ngoặc ‘(’ hoặc đóng ngoặc ‘)’ và các toán hạng in thường.
Nhiệm vụ của bạn là định xem P1 và P2 có giống nhau hay không.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T;
Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất đưa vào P1, dòng tiếp theo
đưa vào P2.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Ràng buộc:
T, P thỏa mãn ràng buộc: 1≤T≤100; 1≤length(P) ≤100.
Input                 Output
2
-(a+b+c)              YES
-a-b-c
a-b-(c-d)             NO
a-b-c-d
*/
//Ý tưởng: thực hiện loại bỏ dấu ngoặc ở cả 2 biểu thức sau đó so sánh
//Code:

#include <bits/stdc++.h>
using namespace std;

string str1, str2;

string convert(string str) { //hàm chuyển đổi đã làm ở bài DSA07005	BIỂU THỨC TƯƠNG ĐƯƠNG
    stack <int> s;
    string tmp = "";
    for (int i = 0; i < str.length (); i++)
        if (str[i] == '(' && i > 0) s.push (i);
        else if (str[i] == ')' && s.size () > 0) {
            if (str[s.top () - 1] == '-') {
                for (int j = s.top (); j < i; j++) {
                    if (str[j] == '+') str[j] = '-';
                    else if (str[j] == '-') str[j] = '+';
                }
            }
            s.pop ();
        }
    for (int i = 0; i < str.length (); i++)
        if (str[i] != '(' && str[i] != ')') tmp += str[i];
    return tmp;
}

void init(){
    cin >> str1;
    cin >> str2;
}

void solve() { //hàm xử lý
    if (convert (str1) == convert (str2)) cout << "YES" << endl; //đưa ra kết quả
    else cout << "NO" << endl;
}

int main() {
    int t;
    cin >> t;
    cin.ignore ();
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
241. DSA07018	TỔNG ĐA THỨC
/*Cho hai đa thức có bậc không quá 10000 (chỉ viết ra các phần tử có hệ số khác 0). Hãy sử dụng danh sách liên kết đơn
để viết chương trình tính tổng hai đa thức đó.
Dữ liệu vào: Dòng đầu ghi số bộ test. Mỗi bộ test có hai dòng, mỗi dòng ghi một đa thức theo mẫu như trong ví dụ. Số
phần tử của đa thức không quá 20.
Chú ý: Bậc của các hạng tử luôn theo thứ tự giảm dần, trong đa thức chỉ có phép cộng và luôn được viết đầy đủ hệ số + số
mũ (kể cả mũ 0).
Kết quả: Ghi ra một dòng đa thức tổng tính được (theo mẫu như ví dụ)
Input                           Output
1
3*x^8 + 7*x^2 + 4*x^0           3*x^8 + 11*x^6 + 16*x^2 + 2*x^1 + 7*x^0
11*x^6 + 9*x^2 + 2*x^1 + 3*x^0
*/
//Ý tưởng: do sắp xếp giảm dần theo bậc nên so sánh 2 phần tử ở đầu bên nào lớn hơn thì in, bằng nhau thì in tổng hệ số
//Code:

#include <bits/stdc++.h>
using namespace std;

list <pair <int, int> > l1;
list <pair <int, int> > l2;
string str1, str2;
vector <pair <int, int> >a;

void init() { //hàm khởi tạo
    getline (cin, str1);
    getline (cin, str2);
}

void convert(string str) { //hàm chuyển đổi
    a.clear ();
    str += ' '; //cộng thêm dấu ' ' để lấy được giá trị của bậc cuối cùng
    pair <int, int> ele;
    int tmp = 0;
    for (int i = 0; i < str.length (); i++) {
        if (isdigit (str[i])) tmp = tmp * 10 + (str[i] - '0'); //chuyển đổi các số sang int
        else if (str[i] == '*') {
            ele.first = tmp; //hệ số
            tmp = 0;
        } else if (str[i] == ' ' && str[i - 1] != '+') {
            ele.second = tmp; //bậc
            a.push_back (ele); //thêm phần tử
            tmp = 0;
        }
    }
}

void solve() { //hàm xử lý
    convert (str1); //chuyển đổi chuỗi 1
    for (int i = 0; i < a.size (); i++) l1.push_back (a[i]); //thêm dữ liệu vào list 1
    convert (str2); //chuyển đổi chuỗi 2
    for (int i = 0; i < a.size (); i++) l2.push_back (a[i]); //thêm dữ liệu vào list 2
    while (!l1.empty () && !l2.empty ()) {
        if (l1.front ().second > l2.front ().second) { //đưa ra phần tử có bậc lớn hơn
            cout << l1.front ().first << "*x^" << l1.front ().second << " + ";
            l1.pop_front ();
        } else if (l1.front ().second < l2.front ().second) { //đưa ra phần tử có bậc lớn hơn
            cout << l2.front ().first << "*x^" << l2.front ().second << " + ";
            l2.pop_front ();
        } else if (l1.front ().second == l2.front ().second) { //nếu cùng bậc
            cout << l1.front ().first + l2.front ().first << "*x^" << l2.front ().second; //đưa ra tổng hệ số
            l1.pop_front ();
            l2.pop_front ();
            if (!l1.empty () || !l2.empty ()) cout << " + "; //vẫn còn phần tử thì in tiếp dấu +
        }
    }
    while (l1.size () > 1) { //đưa ra nốt các phần tủ còn lại của list 1
        cout << l1.front ().first << "*x^" << l1.front ().second << " + ";
        l1.pop_front ();
    }
    if (!l1.empty ()) {
        cout << l1.front ().first << "*x^" << l1.front ().second;
        l1.pop_front ();
    }
    while (l2.size () > 1) { //đưa ra nốt các phần tủ còn lại của list 2
        cout << l2.front ().first << "*x^" << l2.front ().second << " + ";
        l2.pop_front ();
    }
    if (!l2.empty ()) {
        cout << l2.front ().first << "*x^" << l2.front ().second;
        l2.pop_front ();
    }
    cout << endl;
}

int main(){
    int t;
    cin>>t;
    cin.ignore();
    while(t--){
        init();
        solve();
    }
    return 0;
}
242. DSA08010	BIẾN ĐỔI SỐ TỰ NHIÊN
/*Cho số tự nhiên N (N<10^9) và hai phép biến đổi (a), (b) dưới đây.
Thao tác (a): Trừ N đi 1 (N=N-1). Ví dụ N=17, thao tác (a) biến đổi N = N-1 =16.
Thao tác (b): N = max(u,v) nếu u*v =N (u>1, v>1). Ví dụ N=16, thao tác (b) có thể biến đổi N = max(2, 8)=8 hoặc
N=max(4, 4)=4.
Chỉ được phép sử dụng hai thao tác (a) hoặc (b), hãy biến đổi N thành 1 sao số các thao tác (a), (b) được thực hiện ít
nhất. Ví dụ với N=17, số các phép (a), (b) nhỏ nhất biến đổi N thành 1 là 4 bước như sau:
Thao tác (a): N = N-1 = 17-1 = 16
Thao tác (b): 16 = max(4,4) = 4
Thao tác (b): 4 = max(2,2) = 2
Thao tác (a): 2 = 2-1 = 1
Input:
Dòng đầu tiên ghi lại số tự nhiên T là số lượng Test;
T dòng kế tiếp mỗi dòng ghi lại một bộ Test. Mỗi test là một số N.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
3
17                    4
50                    5
100                   5
*/
//Ý tưởng: sử dụng hàng đợi lưu lại số phép biến đổi đến khi đến đích thì đưa ra kết quả luôn
//Code:

#include <bits/stdc++.h>
using namespace std;

int N;

void init() { //hàm khởi tạo
    cin >> N;
}

int bfs() { //hàm bfs
    if (N == 1) return 0; //nếu đã ở đích thì trả về 0
    set <int> s; //tạo 1 set
    s.insert(N); //đưa N vào
    queue <pair <int, int> > q;
    q.push({N, 0});
    while (! q.empty()) {
        int val = q.front().first;
        int cnt = q.front().second + 1;
        q.pop();
        //thêm các bước biến đổi và tăng số lần biến đổi
        for (int i = sqrt(val); i >= 2; i --) {
            if (val % i == 0 && s.find(val / i) == s.end()) {
                q.push({val / i, cnt});
                s.insert(val / i);
            }
        }
        if (val - 1 == 1) return cnt; //nếu đã về 1 trả về kết quả
        else if (s.find(val - 1) == s.end()) {
            q.push({val - 1, cnt});
            s.insert(val - 1);
        }
    }
}

void solve() { //hàm xử lý 
    cout << bfs() << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t --) {
        init();
        solve();
    }
    return 0;
}
243. DSA08012	TÌM SỐ K THỎA MÃN ĐIỀU KIỆN
/*Cho hai số nguyên dương L, R. Hãy đưa ra số các số K trong khoảng [L, R] thỏa mãn điều kiện:
Tất cả các chữ số của K đều khác nhau.
Tất cả các chữ số của K đều nhỏ hơn hoặc bằng 5.
Ví dụ với L = 4, R = 13 ta có 5 số thỏa mãn yêu cầu là 4, 5, 10, 12, 13,
Input:
Dòng đầu tiên đưa vào số lượng test T.
Dòng tiếp theo đưa vào các bộ test. Mỗi bộ test được là một cặp L, R được viết trên một dòng.
T, L, R thỏa mãn ràng buộc: 1≤T≤100; 0≤L≤R≤105.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output 
2
4 13                  5
100 1000              100
*/
//Ý tưởng: tạo mảng lưu các số k sau đó đếm
//Code:

#include <bits/stdc++.h>
using namespace std;

int l, r;
vector <long> a;

int test(string s) { //hàm kiểm tra số k
    int used[6] = {0};
    for (int i = 0; i < s.length (); i++) {
        int tmp = s[i] - 48;
        if (used[tmp] == 0) used[tmp] = 1; //nếu tìm được 1 chữ số chưa sử dụng đánh dấu nó đã sử dụng
        else return 0; //nếu gặp chữ số đã sử dụng rồi trả về 0
    }
    return 1;
}

void solve(){
    queue <string> q; 
    q.push ("1"); //đẩy 5 số k đầu tiên vào hàng đợi
    q.push ("2");
    q.push ("3");
    q.push ("4");
    q.push ("5");
    while (!q.empty ()) {
        string tmp = q.front ();
        q.pop ();
        if (tmp.length () > 5) break;
        int y = 0;
        for (int i = 0; i < tmp.length (); i++) y = y * 10 + (tmp[i] - 48);
        a.push_back (y); //thêm số k vào mảng a
        for (int i = 0; i <= 5; i++) {
            char x = i + 48;
            if (test (tmp + x) == 1) q.push (tmp + x); //nếu tạo ra được 1 số k thì thêm nó vào hàng đợi
        }
    }
}

void init() { //hàm khởi tạo
    cin >> l >> r;
}

void print(){ /hàm in
    int x = 0, y = a.size () - 1;
    while (a[x] < l && x < a.size ()) x++; //tìm chỉ mục bắt đầu
    while (a[y] > r && y > 0) y--; //tìm chỉ mục kết thúc
    cout << y - x + 1 << endl; //đưa ra kết quả
}
int main() {
    int t;
    cin >> t;
    solve ();
    while (t--) {
        init ();
        print ();
    }
    return 0;
}
244. DSA08029	QUAY HÌNH VUÔNG
/*Có một chiếc bảng hình chữ nhật với 6 miếng ghép, trên mỗi miếng ghép được điền một số nguyên trong khoảng từ 1 đến 6.
Tại mỗi bước, chọn một hình vuông (bên trái hoặc bên phải), rồi quay theo chiều kim đồng hồ.
Yêu cầu: Cho một trạng thái của bảng, hãy tính số phép biến đổi ít nhất để đưa bảng đến trạng thái đích.
Input:
Dòng đầu ghi số bộ test (không quá 10). Mỗi bộ test gồm hai dòng:
Dòng đầu tiên chứa 6 số là trạng thái bảng ban đầu (thứ tự từ trái qua phải, dòng 1 tới dòng 2).
Dòng thứ hai chứa 6 số là trạng thái bảng đích (thứ tự từ trái qua phải, dòng 1 tới dòng 2).
Output:
Với mỗi test, in ra một số nguyên là đáp số của bài toán.
Input                 Output
1
1 2 3 4 5 6           2
4 1 2 6 5 3
*/
//Ý tưởng: lưu lại cấu hình tiếp theo và số bước biến đổi bằng hàng đợi
//Code:

#include <bits/stdc++.h>
using namespace std;

string s1,s2;

void init() { //hàm khởi tạo
    s1 = "";
    s2 = "";
    for (int i = 0; i < 6; i++) {
        char x;
        cin >> x;
        s1 += x;
    }
    for (int i = 6; i < 12; i++) {
        char x;
        cin >> x;
        s2 += x;
    }
}

int bfs() { //hàm bfs
    if (s1 == s2) return 0; //nếu giống nhau trả về 0
    queue <pair <string, int> > q;
    q.push ({s1, 0}); //thêm cấu hình đầu vào hàng đợi
    while (1) {
        s1 = q.front ().first; //lấy ra cấu hình hiện tại
        int cnt = q.front ().second + 1; //tăng số phép biến đổi
        q.pop ();
        string tmp = "";
        tmp += s1[3];
        tmp += s1[0];
        tmp += s1[2];
        tmp += s1[4];
        tmp += s1[1];
        tmp += s1[5];
        if (tmp == s2) return cnt; //nếu đến đích trả về kết quả
        else q.push ({tmp, cnt}); //nếu chưa đến đích thêm cấu hình tiếp theo vào hàng đợi
        tmp = "";
        tmp += s1[0];
        tmp += s1[4];
        tmp += s1[1];
        tmp += s1[3];
        tmp += s1[5];
        tmp += s1[2];
        if (tmp == s2) return cnt;  //nếu đến đích trả về kết quả
        else q.push ({tmp, cnt}); //nếu chưa đến đích thêm cấu hình tiếp theo vào hàng đợi
    }
}

void solve() { //hàm xử lý 
    cout << bfs () << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    cin.ignore();
    while (t --) {
        init();
        solve();
    }
    return 0;
}
245. DSA11017	DUYỆT CÂY NHỊ PHÂN TÌM KIẾM 1
/*Cho mảng A[] gồm N node là biểu diễn phép duyệt theo thứ tự giữa (Preorder) của cây nhị phân tìm kiếm. Nhiệm vụ của
bạn là đưa ra phép duyệt theo thứ tự sau của cây nhị phân tìm kiếm.
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào số N là số lượng node; dòng tiếp
theo đưa vào N số A[i]; các số được viết cách nhau một vài khoảng trống.
T, N, node thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤103; 1≤A[i]≤104;
Output:
Đưa ra kết quả phép duyệt Postorder theo từng dòng.
Input                      Output
2
5                          35 30 100 80 40
40 30 35 80 100
8                          35 32 30 120 100 90 80 40
40 30 32 35 80 90 100 120
*/
//Ý tưởng: lưu trữ chỉ mục gốc của cây hiện tại, sau đó tìm phần tử thoả mãn điều kiện của cây nhị phân tìm kiếm
//Code:

#include <bits/stdc++.h>
using namespace std;
int n, pre[1005];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> pre[i];
}

void find(int minval, int maxval, int& preIndex) { //ham
    if (preIndex == n) return; //trả về vì không còn phần tử nào nữa
    //nếu phần tử của mảng không nằm trong phạm vi chỉ định thì nó không thuộc cây con hiện tại
    if (pre[preIndex] < minval || pre[preIndex] > maxval) return;
    int val = pre[preIndex]; //lưu trữ giá trị hiện tại
    preIndex++;  //tìm đến phần tử tiếp theo của mảng
    find (minval, val, preIndex); //tìm tất cả phần tử có giá trị giữa minval và val
    find (val, maxval, preIndex); //tìm tất cả phần tử có giá trị giữa val và maxval
    cout << val << " ";  //in ra kết quả
}

void solve() { //hàm xử lý
    int preIndex = 0;
    find (INT_MIN, INT_MAX, preIndex);
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
246. DSA11006	DUYỆT CÂY KIỂU XOẮN ỐC
/*Cho cây nhị phân, nhiệm vụ của bạn là duyệt cây theo xoắn ốc (spiral-order). Phép. Ví dụ với cây dưới đây sẽ cho ta
kết quả của phép duyệt spiral-order: 1 2 3  4 5 6 7.
spiral_order
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào số N là số lượng cạnh của cây;
dòng tiếp theo đưa vào N bộ ba (u, v, x), trong đó u là node cha, v là node con, x= R nếu v là con phải, x=L nếu v là
con trái; u, v, x được viết cách nhau một vài khoảng trống.
T, N, u, v, thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤103; 1≤u, v≤104;
Output:
Đưa ra kết quả phép duyệt level-order theo từng dòng.
Input                            Output
2
2                                1 3 2
1 2 R 1 3 L
4                                10 0 30 60 40
10 20 L 10 30 R 20 40 L 20 60 R
*/
//Ý tưởng: tạo 2 ngăn xếp và duyệt theo mức từng ngăn xếp một
//Code:

#include <bits/stdc++.h>
using namespace std;
int n;

struct Node { //kiểu dữ liệu cây
    int data;
    Node *left, *right;

    Node (int x) {
        data = x;
        left = right = NULL;
    }
};

void makeNode(Node *root, int b, char c) { //hàm tạo cây mới
    if (c == 'L') root->left = new Node (b);
    else root->right = new Node (b);
}

void findNode(Node *root, int a, int b, int c) { //hàm tìm kiếm cây
    if (root == NULL) return;
    if (root->data == a) makeNode (root, b, c);
    else {
        findNode (root->left, a, b, c);
        findNode (root->right, a, b, c);
    }
}

void printSpiral_order(Node* root) { //hàm in ra kiểu xoắn ốc
    if (node == NULL) return;
    stack <Node *> s1;
    stack <Node *> s2;
    s1.push (root); //thêm gốc vào ngăn xếp 1
    while (!s1.empty () || !s2.empty ()) {
        while (!s1.empty ()) {
            Node *tmp = s1.top ();
            s1.pop ();
            cout << tmp->data << " "; //in ra gốc của cây hiện tại
            if (tmp->right) s2.push (tmp->right); //thêm vào cây con bên phải
            if (tmp->left) s2.push (tmp->left); //thêm vào cây con bên trái
        }
        while (!s2.empty ()) {
            Node *tmp = s2.top ();
            s2.pop ();
            cout << tmp->data << " "; //in ra gốc của cây hiện tại
            if (tmp->left) s1.push (tmp->left); //thêm vào cây con bên trái
            if (tmp->right) s1.push (tmp->right); //thêm vào cây con bên phải
        }
    }
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        cin >> n;
        int a, b;
        char c;
        Node *root = NULL;
        while (n--) {
            cin >> a >> b >> c;
            if (root == NULL) { //tạo cây
                root = new Node (a);
                makeNode (root, b, c);
            else findNode (root, a, b, c);
        }
        printSpiral_order (root); //đưa ra kết quả
        cout << endl;
    }
    return 0;
}
247. DSA11010	CÂY NHỊ PHÂN HOÀN HẢO
/*Cho cây nhị phân, nhiệm vụ của bạn là kiểm tra xem cây nhị phân có phải là một cây hoàn hảo hay không (perfect tree)?
Một cây nhị phân được gọi là cây hoàn hảo nếu tất cả các node trung gian của nó đều có hai node con và tất cả các node
lá đều có cùng một mức.
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào số N là số lượng cạnh của cây;
dòng tiếp theo đưa vào N bộ ba (u, v, x), trong đó u là node cha, v là node con, x= R nếu v là con phải, x=L nếu v là
con trái; u, v, x được viết cách nhau một vài khoảng trống.
T, N, u, v, thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤103; 1≤u, v≤104;
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                                           Output
3
6                                               Yes
10 20 L 10 30 R 20 40 L 20 50 R 30 60 L 30 70 R
2                                               Yes
18 15 L 18 30 R
5                                               No
1 2 L 2 4 R 1 3 R 3 5 L 3 6 R
*/
//Ý tưởng: viết 2 hàm kiểm tra mức và kiểm tra xem cây có 2 cây con không
//Code:

#include <bits/stdc++.h>
using namespace std;

struct Node { //kiểu dữ liệu cây
    int data;
    Node *left, *right;

    Node (int x) {
        data = x;
        left = right = NULL;
    }
};

void makeNode(Node* root, int b, int c) { //hàm tạo cây
    if (c == 'L') root->left = new Node (b);
    else root->right = new Node (b);
}

void findNode(Node* root, int a, int b, int c) { //hàm tìm cây con
    if (!root) return;
    if (root->data == a) makeNode (root, b, c);
    else {
        findNode (root->left, a, b, c);
        findNode (root->right, a, b, c);
    }
}

bool checkLevel(Node* root) { //hàm kiểm tra mức lá
    if (!root) return true;
    queue <pair <Node *, int> > q;
    q.push ({root, 0});
    int res = INT_MAX;
    while (!q.empty ()) {
        int level = q.front ().second + 1;
        Node *tmp = q.front ().first;
        q.pop ();
        if (!tmp->left && !tmp->right) {
            if (res == INT_MAX) res = level;
            else if (level != res) return false;
        }
        if (tmp->left) q.push ({tmp->left, level});
        if (tmp->right) q.push ({tmp->right, level});

    }
    return true;
}

bool fullBinaryTree(Node *node) { //hàm kiểm tra có phải cây nhị phân đầy đủ không
    queue <Node *> q;
    q.push (node);
    while (!q.empty ()) {
        Node *tmp = q.front ();
        q.pop ();
        if (!tmp->left && tmp->right) return false; //nếu không có node bên trái hoặc phải trả về false
        if (tmp->left && !tmp->right) return false;
        if(tmp->left && tmp->right) {
            q.push (tmp->left); //đẩy 2 node bên trái và phải vào hàng đợi
            q.push (tmp->right);
        }
    }
    return true;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        Node *node = NULL;
        int a, b;
        char c;
        while (n--) {
            cin >> a >> b >> c;
            if (!node) { //tạo cây
                node = new Node (a);
                makeNode (node, b, c);
            } else findNode (node, a, b, c);
        }
        if (checkLevel (node) && fullBinaryTree (node)) cout << "Yes"; //đưa ra kết quả
        else cout << "No";
        cout << endl;
    }
    return 0;
}
248. DSA11011	CÂY NHỊ PHÂN ĐỦ
/*Cho cây nhị phân, nhiệm vụ của bạn là kiểm tra xem cây nhị phân có phải là một cây đủ hay không (full binary tree)?
Một cây nhị phân được gọi là cây đủ nếu tất cả các node trung gian của nó đều có hai node con.
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào số N là số lượng cạnh của cây;
dòng tiếp theo đưa vào N bộ ba (u, v, x), trong đó u là node cha, v là node con, x= R nếu v là con phải, x=L nếu v là
con trái; u, v, x được viết cách nhau một vài khoảng trống.
T, N, u, v, thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤103; 1≤u, v≤104;
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                   Output
2
4                       1
1 2 L 1 3 R 2 4 L 2 5 R
3                       0
1 2 L 1 3 R 2 4 L
*/
//Ý tưởng: kiểm tra xem có bất cứ cây nào có 1 node thì trả về false
//Code:


#include <bits/stdc++.h>
using namespace std;

int n;

struct Node { //kiểu dữ liệu cây
    int data;
    Node *left, *right;

    Node (int x) {
        data = x;
        left = right = NULL;
    }
};

void makeNode(Node* root, int b, int c) { //hàm tạo cây
    if (c == 'L') root->left = new Node (b);
    else root->right = new Node (b);
}

void findNode(Node* root, int a, int b, int c) { //hàm tìm cây con
    if (!root) return;
    if (root->data == a) makeNode (root, b, c);
    else {
        findNode (root->left, a, b, c);
        findNode (root->right, a, b, c);
    }
}

int fullBinaryTree(Node *root) { //hàm kiểm tra cây nhị phân đầy đủ
    queue <Node *> q;
    q.push (root); //thêm gốc vào hàng đợi
    while (!q.empty ()) {
        Node *tmp = q.front ();
        q.pop ();
        if (!tmp->left && tmp->right ) return 0; //kiểm tra xem cây chỉ có 1 cây con thì trả về 0
        if (tmp->left && !tmp->right) return 0;
        if (tmp->left && tmp->right) {
            q.push (tmp->left); //thêm cây con bên trái vào hàng đợi
            q.push (tmp->right); //thêm cây con bên phải vào hàng đợi
        }
    }
    return 1;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        cin >> n;
        int a, b;
        char c;
        Node *root = NULL;
        while (n--) {
            cin >> a >> b >> c;
            if (!root) {
                root = new Node (a);
                makeNode (root, b, c);
            } else findNode (root, a, b, c);
        }
        cout << fullBinaryTree (root) << endl;
    }
    return 0;
}
249. DSA11012	CÂY NHỊ PHÂN BẰNG NHAU
/*Cho hai cây nhị phân, nhiệm vụ của bạn là kiểm tra xem cây nhị phân có giống nhau hay không?
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 3 dòng: dòng đầu tiên đưa vào số N là số lượng cạnh của cây;
dòng tiếp theo đưa vào N bộ ba (u, v, x), trong đó u là node cha, v là node con, x= R nếu v là con phải, x=L nếu v là
con trái của mỗi cây; u, v, x được viết cách nhau một vài khoảng trống.
T, N, u, v, thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤103; 1≤u, v≤104;
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
2
2                     1
1 2 L 1 3 R
2
1 2 L 1 3 R
2                     0
1 2 L 1 3 R
2
1 3 L 1 2 R
*/
//Ý tưởng: kiểm tra xem cây có bất kỳ node nào khác nhau hay không
//Code:

#include <bits/stdc++.h>
using namespace std;

struct Node { //kiểu dữ liệu cây
    int data;
    Node *left, *right;

    Node (int x) {
        data = x;
        left = right = NULL;
    }
};

void makeNode(Node* root, int b, int c) { //hàm tạo cây
    if (c == 'L') root->left = new Node (b);
    else root->right = new Node (b);
}

void findNode(Node* root, int a, int b, int c) { //hàm tìm cây con
    if (!root) return;
    if (root->data == a) makeNode (root, b, c);
    else {
        findNode (root->left, a, b, c);
        findNode (root->right, a, b, c);
    }
}

int indenticalTree(Node *T1, Node *T2) { //hàm kiểm tra cây bằng nhau
    if (!T1 && !T2) return 1;
    if (T1 && T2) //nếu có 1 node khác nhau thì trả về 0
        return (T1->data == T2->data && indenticalTree (T1->left, T2->left) && indenticalTree (T1->right, T2->right));
    return 0;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        Node *T1 = NULL;
        Node *T2 = NULL;
        int a, b;
        char c;
        while (n--) {
            cin >> a >> b >> c;
            if (!T1) { //tạo cây 1
                T1 = new Node (a);
                makeNode (T1, b, c);
            } else findNode (T1, a, b, c);
        }
        cin >> n;
        while (n--) {
            cin >> a >> b >> c;
            if (!T2) { //tạo cây 2
                T2 = new Node (a);
                makeNode (T2, b, c);
            } else findNode (T2, a, b, c);
        }
        cout << indenticalTree (T1, T2) << endl; //đưa ra kết quả
    }
    return 0;
}
250. DSA11014	TỔNG NODE LÁ BÊN PHẢI
/*Cho cây nhị phân, nhiệm vụ của bạn là tính tổng của tất cả các node lá bên phải trên cây? Ví dụ với cây dưới đây ta có
kết quả là 2.
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 3 dòng: dòng đầu tiên đưa vào số N là số lượng cạnh của cây;
dòng tiếp theo đưa vào N bộ ba (u, v, x), trong đó u là node cha, v là node con, x= R nếu v là con phải, x=L nếu v là
con trái; u, v, x được viết cách nhau một vài khoảng trống.
T, N, u, v, thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤103; 1≤u, v≤104;
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                                     Output
2
2                                         3
1 2 L 1 3 R
5                                         60
10 20 L 10 30 R 20 40 L 20 60 R 30 90 L
*/
//Ý tưởng: duyệt đến khi nào là 1 node lá nằm ở bên phải thì cộng vào kết quả
//Code:

#include<bits/stdc++.h>
using namespace std;

struct Node { //kiểu dữ liệu cây
    int data;
    Node* left, * right;

    Node(int x) {
        data = x;
        left = right = NULL;
    }
};

map<int, Node*> mp;
int n;

Node* build() { //hàm dựng cây
    Node* root = NULL;
    long long a, b;	char c;
    for (int i = 0; i < n; i++) {
        cin >> a >> b >> c;
        if (mp.find(a) == mp.end()) { //nếu chưa có cây này
            mp[a] = new Node(a); //tạo cây
            if (root == NULL) //nếu cây rỗng
                root = mp[a]; //tạo cây mới
        }
        if (c == 'L') { //tạo cây con bên trái
            mp[a]->left = new Node(b);
            mp[b] = mp[a]->left;
        }
        else { //tạo cây con bên phải
            mp[a]->right = new Node(b);
            mp[b] = mp[a]->right;
        }
    }
    return root; //trả về cây được tạo
}

void solve(Node* node, long long& sum) { //hàm xử lý
    if (node->right != NULL) {
        if (node->right->left == NULL && node->right->right == NULL)
            sum += node->right->data; //cập nhật tổng các cây con bên phải
        else solve(node->right, sum);
    }
    if (node->left != NULL) solve(node->left, sum);
}

int main() {
    int t;	cin >> t;
    while (t--) {
        cin >> n;
        Node* root = build(); //tạo cây
        long long sum = 0;
        solve(root, sum); //tính tổng cây con bên phải
        cout << sum << endl; //đưa ra kết quả
        mp.clear();
    }
    return 0;
}
251. DSA11015	TỔNG LỚN NHẤT
/*Cho cây nhị phân có giá trị mỗi node là một số, nhiệm vụ của bạn là tìm tổng lớn nhất từ một node lá này sang một node
lá khác? Ví dụ với cây dưới đây ta có tổng lớn nhất là 27.
https://media.geeksforgeeks.org/wp-content/cdn-uploads/tree.png
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 3 dòng: dòng đầu tiên đưa vào số N là số lượng cạnh của cây;
dòng tiếp theo đưa vào N bộ ba (u, v, x), trong đó u là node cha, v là node con, x= R nếu v là con phải, x=L nếu v là
con trái; u, v, x được viết cách nhau một vài khoảng trống.
T, N, u, v, thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤103; 1≤u, v≤104;
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                                                                                Output
1
12                                                                                   27
-15 5 L -15 6 R 5 -8 L 5 1 R -8 2 L -8 -3 R 6 3 L 6 9 R 9 0 R 0 4 L 0 -1 R -1 10 L
*/
//Ý tưởng: tình tổng các cây con và gốc rồi so sánh với kết quả hiện tại
//Code:

#include <bits/stdc++.h>
using namespace std;

int n;


struct Node { //kiểu dữ liệu cây
    int data;
    Node *left, *right;

    Node (int x) {
        data = x;
        left = right = NULL;
    }
};

void makeNode(Node* root, int b, int c) { //hàm tạo cây
    if (c == 'L') root->left = new Node (b);
    else root->right = new Node (b);
}

void findNode(Node* root, int a, int b, int c) { //hàm tìm cây con
    if (!root) return;
    if (root->data == a) makeNode (root, b, c);
    else {
        findNode (root->left, a, b, c);
        findNode (root->right, a, b, c);
    }
}

long long maxPath(Node *root, long long &res) { //hàm tính đường đi
    if (!root) return 0;
    if (!root->left && !root->right) return root->data;
    long long ls = maxPath (root->left, res); //tìm tổng từ lá của cây con bến trái đến gốc
    long long rs = maxPath (root->right, res); //tìm tổng từ lá của cây con bên phải đến gốc
    if (root->left && root->right) { //nếu có cả 2 cây con
        res = max (ls + rs + root->data, res); //cập nhật kết quả
        return max (ls, rs) + root->data; //trả về max của 1 bên lá cộng với gốc
    }
    if (!root->left) return rs + root->data; //nếu cây chỉ có cây bên phải trả về tồng của cây bên phải và gốc
    return ls + root->data; //nếu cây chỉ có cây bên trái trả về tồng của cây bên trái và gốc
}

long long maxPathSum(Node *root) { //hàm tìm tổng đường đi lớn nhất
    long long res = LONG_LONG_MIN; //khởi tạo kết quả
    maxPath (root, res); //cập nhật kết quả
    return res; //trả về kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        cin >> n;
        int a, b;
        char c;
        Node *root = NULL;
        while (n--) {
            cin >> a >> b >> c;
            if (!root) { //tạo cây
                root = new Node (a);
                makeNode (root, b, c);
            } else findNode (root, a, b, c);
        }
        cout << maxPathSum (root) << endl; //đưa ra kết quả
    }
    return 0;
}
252. DSA11016	BIẾN ĐỔI SANG CÂY NHỊ PHÂN TÌM KIẾM
/*Cho cây nhị phân, nhiệm vụ của bạn là dịch chuyển cây nhị phân thành cây nhị phân tìm kiếm. Phép dịch chuyển phải bảo
toàn được cấu trúc cây nhị phân ban đầu. Ví dụ dưới đây sẽ minh họa phép dịch chuyển:
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 3 dòng: dòng đầu tiên đưa vào số N là số lượng cạnh của cây;
dòng tiếp theo đưa vào N bộ ba (u, v, x), trong đó u là node cha, v là node con, x= R nếu v là con phải, x=L nếu v là
con trái; u, v, x được viết cách nhau một vài khoảng trống.
T, N, u, v, thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤103; 1≤u, v≤104;
Output:
Đưa ra kết quả mỗi test theo từng dòng là phép duyệt Inorder của cây tìm kiếm.
Input                            Output
2
2                                1 2 3
1 2 R 1 3 L
4                                10 20 30 40 60
10 20 L 10 30 R 20 40 L 20 60 R
*/
//Ý tưởng: phép duyệt Inorder của cây nhị phân tìm kiếm là sắp xếp tăng dần các phần tử
//Code:

#include <bits/stdc++.h>
using namespace std;

void solve(){ //hàm xử lý
    set <int> s; //khao báo 1 set lưu các giá trị của node
    set <int>::iterator it;
    int n, a, b;
    char c;
    cin >> n >> a >> b >> c;
    s.insert (a);
    s.insert (b);
    for (int i = 1; i < n; i++) { //nhâp vào input
        cin >> a >> b >> c;
        s.insert (b);
    }
    for (it = s.begin (); it != s.end (); it++) cout << *it << " "; //đưa ra kết quả
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        solve ();
    }
    return 0;
}
253. DSA11018	XÂY DỰNG LẠI CÂY NHỊ PHÂN TÌM KIẾM
/*Cho một mảng là phép duyệt level-order của cây nhị phân tìm kiếm. Nhiệm vụ của bạn là xây dựng lại cây nhị phân tìm
kiếm bảo toàn được cấu trúc cây nhị phân ban đầu.
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm dòng: dòng đầu tiên đưa vào số N là số lượng node của cây tìm
kiếm; dòng tiếp theo đưa vào phép duyệt level-order của cây tìm kiếm; các số được viết cách nhau một vài khoảng trống.
T, N, node thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤103; 1≤node≤104;
Output:
Đưa ra kết quả mỗi test theo từng dòng là phép duyệt trước (preOrder) của cây tìm kiếm.
Input                 Output
2
9                     7 4 3 1 6 5 12 8 10
7 4 12 3 6 8 1 5 10
6                     1 3 4 6 7 8
1 3 4 6 7 8
*/
//Ý tưởng: tạo cây nhị phân sau đó duyệt theo phép preoder
//Code:

#include <bits/stdc++.h>
using namespace std;

struct Node { //kiểu dữ liệu cây
    int data;
    Node *left, *right;

    Node (int x) {
        data = x;
        left = right = NULL;
    }
};

int n, lv[1005];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> lv[i];
}

void printPreOrder(Node *root) { //đưa ra kết quả theo phép duyệt preorder
    if (!root) return;
    cout << root->data << " ";
    printPreOrder (root->left);
    printPreOrder (root->right);
}

Node *levelOrder(Node *root, int data) { //hàm tìm kiếm theo mức
    if (!root) { //nếu cây rỗng
        root = new Node (data); //tạo cây mới
        return root;
    }
    if (data <= root->data) root->left = levelOrder (root->left, data); //nếu data thuộc cây con bên trái thì gắn nó vào
    else root->right = levelOrder (root->right, data);  //nếu data thuộc cây con bên phải thì gắn nó vào
    return root; //trả về cây đã tạo
}
 
Node *buildTree(Node *root) { //hàm dựng cây
    for (int i = 0; i < n; i++) root = levelOrder (root, lv[i]);
    return root; //trả về cây sau khi dựng
}

void solve() { //hàm xử lý
    Node *root = NULL;
    root = buildTree (root); //dựng cây
    printPreOrder (root); //đưa ra kết quả
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
254. DSA11019	DUYỆT CÂY NHỊ PHÂN TÌM KIẾM 2
/*Cho một mảng A[] gồm N phần tử biểu diễn phép duyệt preorder của cây nhị phân tìm kiếm. Nhiệm vụ của bạn là đưa ra
phép duyệt postorder của cây nhị phân tìm kiếm.
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào số N là số lượng node của cây
tìm kiếm; dòng tiếp theo đưa vào phép duyệt preorder của cây tìm kiếm; các số được viết cách nhau một vài khoảng trống.
T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤103; 1≤A[i]≤104;
Output:
Đưa ra kết quả mỗi test theo từng dòng là phép duyệt postorder của cây tìm kiếm.
Input                     Output
2
5                         35 30 100 80 40
40 30 35 80 100
8                         35 32 30 120 100 90 80 40
40 30 32 35 80 90 100 120
*/
//Ý tưởng: nếu cây con được duyệt tới nhỏ hơn cây hiện tại thì thêm vào cây con bên trái và ngược lại 
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, pre[1005];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> pre[i];
}

void find(int minval, int maxval, int& preIndex) { //hàm tìm kiếm theo posorder
    if (preIndex == n) return; //nếu đã duyệt hết mảng thì dừng lại
    if (pre[preIndex] < minval || pre[preIndex] > maxval) return; //nếu là lá thì dừng lại
    int val = pre[preIndex]; //gán giá trị cho cây hiện tại
    preIndex++; //tìm đến phần tử tiếp theo
    find (minval, val, preIndex); //tìm cây con bên trái của cây hiện tại
    find (val, maxval, preIndex); //tìm cây con bên phải của cây hiện tại
    cout << val << " "; //đưa ra giá trị của cây hiện tại
}

void solve() { //hàm xử lý
    int preIndex = 0; //khởi tạo preIndex
    find (INT_MIN, INT_MAX, preIndex); //gọi hàm tìm kiếm
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
255. DSA11020	KIỂM TRA CÂY NHỊ PHÂN TÌM KIẾM
/*Cho một mảng A[] gồm N phần tử. Nhiệm vụ của bạn là đưa ra 1 nếu mảng A[] biểu diễn phép duyệt inorder của cây nhị
phân tìm kiếm, ngược lại đưa ra 0.
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào số N là số lượng node của cây
tìm kiếm; dòng tiếp theo đưa vào N số A[i]; các số được viết cách nhau một vài khoảng trống.
T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤103; 1≤A[i]≤104;
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
3
5                     1
10 20 30 40 50
6                     0
90 80 100 70 40 30
3                     0
1 1 2
*/
//Ý tưởng: kiểm tra xem mảng có sắp xếp tăng dần hay không
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, in[1005];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> in[i];
}

int isBST() { //hàm kiểm tra
    if (n == 1) return 1; //nếu chỉ có gốc đưa ra 1
    for (int i = 1; i < n; i++)
        if (in[i - 1] >= in[i]) return 0; //nếu có phần tử không sắp xếp tăng dần đưa ra 0
    return 1; //nếu mảng đã sắp xếp tăng dần đưa ra 1
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        cout << isBST () << endl; //đưa ra kết quả
    }
    return 0;
}
256. DSA11021	NODE LÁ CỦA CÂY NHỊ PHÂN TÌM KIẾM
/*Cho dãy số gồm N số là phép duyệt theo thứ tự trước (Preorder) của một cây nhị phân tìm kiếm. Hãy in ra tất cả các
node lá của cây ?
Ví dụ với dãy A[] = {30, 20, 15, 25, 23, 28, 40, 35, 33, 38, 45} là phép duyệt cây theo thứ tự trước sẽ cho ta kết quả:
15, 23, 28, 33, 38, 45.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T (T≤100).
Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất là số tự nhiên N (N≤1000). Dòng tiếp theo là
N số là phép duyệt theo thứ tự trước của cây BST.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                              Output
2
6                                  1 7 50
10 5 1 7 40 50
11                                 15 23 28 33 38 45
30 20 15 25 23 28 40 35 33 38 45
*/
//Ý tưởng:
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, pre[1005];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> pre[i];
}

void solve() { //hàm xử lý
    stack <int> s;
    for (int i = 0, j = 1; j < n; i++, j++) {
        if (pre[i] > pre[j]) s.push (pre[i]); //nếu phần tử sau vẫn là con của phần tử trước thì thêm cha vào ngăn xếp
        else { //nếu phần tử sau lớn hơn phần tử trước thì kiểm tra xem nó có phải lá không
            bool found = false;
            while (!s.empty ()) { //nếu phần tử pre[j] lớn hơn 1 phần tử ở đỉnh của ngăn xếp thì nó là lá
                if (pre[j] > s.top ()) { //xoá đến khi gặp cha của phần tử pre[j]
                    s.pop ();
                    found = true;
                } else break;
            }
            if (found) cout << pre[i] << " "; //đưa ra kết quả
        }
    }
    cout << pre[n - 1] << endl; //phần tủ cuối cùng luôn là lá
}

int main(){
    int t;
    cin>>t;
    while(t--){
        init();
        solve();
    }
    return 0;
}
257. DSA11022	NODE TRUNG GIAN CỦA CÂY NHỊ PHÂN TÌM KIẾM
/*Cho dãy số gồm N số là phép duyệt theo thứ tự trước (Preorder) của một cây nhị phân tìm kiếm. Hãy đưa ra số các node
trung gian của cây ?
Ví dụ với dãy A[] = {30, 20, 15, 25, 23, 28, 40, 35, 33, 38, 45} là phép duyệt cây theo thứ tự trước sẽ cho ta kết quả
là 5 bao gồm các node: 30, 20, 25, 40, 35.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T (T≤100).
Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất là số tự nhiên N (N≤1000). Dòng tiếp theo là
N số là phép duyệt theo thứ tự trước của cây BST.
Output:
Đưa ra kết quả mỗi test theo từng dòng
Input                               Output
2
6                                   3
10 5 1 7 40 50
11                                  5
30 20 15 25 23 28 40 35 33 38 45
*/
//Ý tưởng: //đếm số lá, sau đó lấy n trừ đi số lá ta được số node trung gian
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, pre[1005];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> pre[i];
}

void solve() { //hàm xử lý
    int res = n - 1; //khởi tạo kết quả, do phần tử cuối cùng là lá nên lấy bắt đầu bằng n-1
    stack <int> s;
    for (int i = 0, j = 1; j < n; i++, j++) { //đếm số lá
        if (pre[i] > pre[j]) s.push (pre[i]);
        else {
            bool found = false;
            while (!s.empty ()) {
                if (pre[j] > s.top ()) {
                    found = true;
                    s.pop ();
                } else break;
            }
            if (found) res--; //cập nhật kết quả
        }
    }
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
258. DSA11023	ĐỘ SÂU CÂY NHỊ PHÂN TÌM KIẾM
/*Cho dãy số gồm N số là phép duyệt theo thứ tự trước (Preorder) của một cây nhị phân tìm kiếm. Hãy tìm độ sâu của cây ?
Ví dụ với dãy A[] = {30, 20, 15, 25, 23, 28, 40, 35, 33, 38, 45} là phép duyệt cây theo thứ tự trước sẽ cho ta kết quả
là 3. Input:
Dòng đầu tiên đưa vào số lượng bộ test T (T≤100).
Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất là số tự nhiên N (N≤1000). Dòng tiếp theo là
N số là phép duyệt theo thứ tự trước của cây BST.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                            Output
2
6                                2
10 5 1 7 40 50
11                               3
30 20 15 25 23 28 40 35 33 38 45
*/
//Ý tưởng: dựng cây sau đó tìm độ sâu
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, pre;

struct Node { //kiểu dữ liệu cây
    int data;
    Node *left, *right;

    Node (int x) {
        data = x;
        left = right = NULL;
    }
};

void makeNode(Node *&root, int data) { //hàm dựng cây
    if (!root) {
        root = new Node (data);
        return;
    }
    if (data < root->data) makeNode (root->left, data);
    else makeNode (root->right, data);
}

int maxDepth(Node* root) { //hàm tìm độ sâu
    if (root == NULL) return 0; //nếu cây rỗng độ sâu bằng 0
    int lDepth = maxDepth (root->left); //tìm độ sâu cây bên trái
    int rDepth = maxDepth (root->right); //tìm độ sâu cây bên phải
    if (lDepth > rDepth) return (lDepth + 1); //trả về kết quả
    else return (rDepth + 1);
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        cin >> n;
        Node *root = NULL;
        for (int i = 0; i < n; i++) { //tạo cây
            cin >> pre;
            makeNode (root, pre);
        }
        cout << maxDepth (root) - 1 << endl; //đưa ra kết quả
    }
    return 0;
}
259. DSA11024	CÂY NHỊ PHÂN TÌM KIẾM CÂN BẰNG 1
/*Hãy xây dựng một cây nhị phân tìm kiếm cân bằng từ dãy số A[] =(a0, a1, .., an-1}. Đưa ra nội dung node gốc của cây
tìm kiếm cân bằng.  Ví dụ với dãy A[]={40, 28, 45, 38, 33, 15, 25, 20, 23, 35, 30} ta sẽ có cây nhị phân tìm kiếm cân
bằng với node gốc là 30.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T (T≤100).
Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất là số tự nhiên N (N≤106). Dòng tiếp theo là
N số của mảng A[].
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                                     Output
2
11                                        30
40  28  45 38  33  15  25  20  23  35  30
10                                         5
1  2  3  4  5  6  7  8  9  10
*/
//Ý tưởng: gốc của cây chính là phần tử ở giữa của mảng duyệt inorder
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, a[1005];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void solve() { //hàm xử lý
    sort (a, a + n); //đưa về mảng duyệt inorder
    if (n % 2 == 0) cout << a[n / 2 - 1] << endl; //đưa ra kết quả
    else cout << a[n / 2] << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
260. DSA11025	CÂY NHỊ PHÂN TÌM KIẾM CÂN BẰNG 2
/*Hãy xây dựng một cây nhị phân tìm kiếm cân bằng từ dãy số A[] =(a0, a1, .., an-1}. Đưa ra phép duyệt theo thứ tự trước
(preorder) của cây tìm kiếm cân bằng.  Ví dụ với dãy A[]={40, 28, 45, 38, 33, 15, 25, 20, 23, 35, 30} ta sẽ có phép
duyệt theo thứ tự trước của cây nhị phân tìm kiếm cân bằng với node gốc là 33 :
33, 25, 20, 15, 23, 28, 30, 40, 38, 35, 45.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T (T≤100).
Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất là số tự nhiên N (N≤106). Dòng tiếp theo là
N số của mảng A[].
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                                      Output
2
11                                         30 23 15 20 25 28 38 33 35 40 45
40  28  45 38  33  15  25  20  23  35  30
10                                         5 2 1 3 4 8 6 7 9 10
1  2  3  4  5  6  7  8  9  10
*/
//Ý tưởng: gốc của cây hiện tại bằng phần tử ở chính giữa của cây trong mảng duyệt inorder
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, a[1005];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void printPreorder(int start, int end) { //hàm in theo preorder
    if (start > end) return; //nếu đã in hết cây hiện tại thì dừng lại 
    int size = end - start + 1; //tìm độ động của mảng cây hiện tại
    int preIndex = start + size / 2; //tìm phần tử ở giữa của cây
    if (size % 2 == 0) preIndex--;
    cout << a[preIndex] << " ";
    printPreorder (start, preIndex - 1); //in cây con bên trái
    printPreorder (preIndex + 1, end); //in cây con bên phải
}

void solve() { //hàm xử lý 
    sort (a, a + n); //đưa về mảng duyệt inorder
    printPreorder (0, n - 1); //đưa ra kết quả
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
261. DSA07030	HÌNH CHỮ NHẬT 0-1
/*Cho một bảng kích thước NxM, được chia thành lưới ô vuông đơn vị N dòng M cột. Trên các ô của bảng ghi số 0 hoặc 1.
Các dòng của bảng được đánh số 1, 2... N theo thứ tự từ trên xuống dưới và các cột của bảng được đánh số 1, 2..., M theo
thứ tự từ trái qua phải
Yêu cầu: Hãy tìm một hình chữ nhật gồm các ô của bảng thoả mãn các điều kiện sau:
1 - Hình chữ nhật đó chỉ gồm các số 1
2 - Cạnh hình chữ nhật song song với cạnh bảng
3 - Diện tích hình chữ nhật là lớn nhất có thể
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test bắt đầu bởi hai số nguyên N và M (1 ≤ M, N ≤ 500).
N dòng tiếp theo, mỗi dòng gồm M số nguyên 0 hoặc 1.
Output:
Với mỗi test, in ra diện tích hình chữ nhật lớn nhất tìm được.
Input                             Output
1
11 13                             49
0 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 0 1 1 1 0 0 0 0 0 0
0 0 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 0 0 0 0
0 1 1 1 1 1 1 1 1 1 0 0 0
1 1 1 1 1 1 1 1 1 1 1 0 0
0 1 1 1 1 1 1 1 1 1 0 0 0
0 0 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 0 0 0 0
0 0 0 0 1 1 1 0 0 0 0 1 1
0 0 0 0 0 1 0 0 0 0 0 1 1
*/
//Ý tưởng:Duyệt từng hàng : khởi tạo h, tạo l và r bằng QHĐ, tìm max cho res
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, m, a[505][505];
/*h[j] là chiều cao của hình chữ nhật tính từ hàng i đang xét đi lên tại cột j chứa liên tiếp các số 1
l[j] là vị trí trái nhất của cột j có h[j] -> h[l[j]] lớn hơn hoặc bằng h[j]
r[j] là vị trí phải nhất của cột j có h[j] -> h[r[j]] lớn hơn hoặc bằng h[j]*/
int h[505], l[505], r[505], res;

void init() { //hàm khởi tạo
    cin >> m >> n;
    for (int i = 1; i <= m; i++)
        for (int j = 1; j <= n; j++) cin >> a[i][j];
}

void solve() { //hàm xử lý
    res=0;
    h[0] = -1;
    h[n + 1] = -1;
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++)
            h[j] = a[i][j] * (h[j] + 1); //tính chiều cao của các cột
        for (int j = 1; j <= n; j++) { //tìm l
            l[j] = j;
            //nếu chiều cao của cột bên trái không nhỏ hơn chiều cao của cột bên phải
            while (h[l[j] - 1] >= h[j]) l[j] = l[l[j] - 1]; //cập nhật vị trí l
        }
        for (int j = n; j > 0; j--) { //tìm r
            r[j] = j;
            //nếu chiều cao của cột bên phải không nhỏ hơn chiều cao của cột bên trái
            while (h[r[j] + 1] >= h[j]) r[j] = r[r[j] + 1]; //cập nhật vị trí r
        }
        for (int j = 1; j <= n; j++)
            res = max (res, h[j] * (r[j] - l[j] + 1)); //cập nhật kết quả
    }
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
262. DSA01018	TẬP CON LIỀN KỀ PHÍA TRƯỚC
/*Cho hai số N, K và một tập con K phần tử X[] =(X1, X2,.., XK) của 1, 2, .., N. Nhiệm vụ của bạn là hãy đưa ra tập con
K phần tử trước đó của X[]. Ví dụ N=5, K=3, X[] ={2, 3, 5} thì tập con trước đó của X[] là {2, 3, 4}. Chú ý nếu tập con
trong input là đầu tiên thì trước đó là tập con cuối cùng.
Input:
Dòng đầu tiên đưa vào số lượng test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất là hai số N và K; dòng tiếp theo đưa vào
K phần tử của X[] là một tập con K phần tử của 1, 2, .., N.
T, K, N, X[] thỏa mãn ràng buộc: 1≤T≤100; 1≤K≤N≤10^3.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                Output
2
5  3                 2 3 4
2  3  5
5  3                 3 4 5
1  2  3
*/
//Ý tưởng: kiểm tra xem phần tử hiện tại đã ở giá trị sàn chưa, nếu chưa thì giảm nó đi 1, gán phần tử sau nó đến trần
//Code:

#include<bits/stdc++.h>
using namespace std;

int n, k, a[1005];

void init() { //hàm khởi tạo
    cin >> n >> k;
    for (int i = 1; i <= k; i++) cin >> a[i];
}

void solve() {
    int check = 0;
    for (int i = k; i > 1; i--)
        if (a[i] > a[i - 1] + 1) { //nếu phần tử hiện tại lớn hơn phần tử trước nó + 1
            a[i]--; //giảm phần tử hiện tại
            check = 1; //đánh dấu tìm được cấu hình
            for (int j = i + 1; j <= k; j++) a[j] = n - k + j; //gán các phần tử sau nó đến trần
            break;
        }
    if (check == 0) { //nếu không tìm được phần tử thoả mãn
        if (a[1] == 1) { //nếu là cấu hình đầu tiên
            for (int i = 1; i <= k; i++) cout << n - k + i << " "; //đưa ra cấu hình cuối cùng
            cout << endl;
        } else { //nếu không phải cấu hình đầu tiên
            a[1]--; //giảm phần tử đầu tiên đi 1
            cout << a[1] << " ";
            for (int i = 2; i <= k; i++) cout << n - k + i << " "; //gán các phần tử sau đến trần
            cout << endl;
        }
    } else {
        for (int i = 1; i <= k; i++) cout << a[i] << " "; //đưa ra kết quả
        cout << endl;
    }
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
263. DSA10011	DI CHUYỂN TRÊN BẢNG SỐ
/*Cho một bảng số kích thước N x M. Chi phí khi đi qua ô (i,j) bằng A[i][j]. Nhiệm vụ của bạn là hãy tìm một đường đi từ
ô (1, 1) tới ô (N, M) sao cho chi phí là nhỏ nhất. Tại mỗi ô, bạn được phép đi sang trái, sang phải, đi lên trên và
xuống dưới.
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test bắt đầu bởi hai số nguyên N và M (1 ≤ N, M ≤ 500).
N dòng tiếp theo, mỗi dòng gồm M số nguyên A[i][j] (0 ≤ A[i][j] ≤ 9).
Output:
Với mỗi test, in ra một số nguyên là chi phí nhỏ nhất cho đường đi tìm được
Input                 Output
3
4 5                    24
0 3 1 2 9
7 3 4 9 9
1 7 5 5 3
2 3 4 2 5
1 6                   15
0 1 2 3 4 5
5 5                   13
1 1 1 9 9
9 9 1 9 9
1 1 1 9 9
1 9 9 9 9
1 1 1 1 1
*/
//Ý tưởng: nếu chi phí đến ô hiện tại nhỏ hơn chi phí hiện tại thì cập nhật chi phí
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, m, a[505][505], d[505][505];
int dx[] = {-1, 0, 0, 1};
int dy[] = {0, -1, 1, 0};

bool check(int x, int y) {
    if (x < 0 || y < 0 || x >= n || y >= m) return false;
    return true;
}

void init() { //hàm khởi tạo
    cin >> n >> m;
    for (int i = 0; i < n; i++) 
        for (int j = 0; j < m; j++) 
            cin >> a[i][j];
}

void solve() { //hàm xử lý
    for (int i = 0; i < n; i++) 
        for (int j = 0; j < m; j++) 
            d[i][j] = INT_MAX; //đánh dấu chưa có đường đi
    d[0][0] = a[0][0]; //khởi tạo giá trị ban đầu
    queue <pair <int, int> > q;
    q.push ({0, 0}); //đưa điểm đầu vào hàng đợi
    while (!q.empty ()) {
        int i = q.front ().first;
        int j = q.front ().second;
        q.pop ();
        for (int k = 0; k < 4; k++) { //thử với 4 hướng
            int x = i + dx[k];
            int y = j + dy[k];
            if (check (x, y) && d[i][j] + a[x][y] < d[x][y]) { 
                d[x][y] = d[i][j] + a[x][y]; //cập nhật kết quả
                q.push ({x, y}); //đưa điểm hiện tại vào hàng đợi
            }
        }
    }
    cout << d[n - 1][m - 1] << endl; //đưa ra kết quả
}
int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
264. DSA10012	ĐƯỜNG ĐI TRUNG BÌNH
/*Cho một đồ thị có hướng gồm N đỉnh và M cạnh. Nhiệm vụ của bạn là hãy tính khoảng cách trung bình ngắn nhất giữa hai
node bất kì nếu như chúng liên thông với nhau. Input đảm bảo rằng trong một nhóm liên thông, nếu như u đi tới được v thì
v cũng đi tới được v với mọi cặp u, v.
Input:Dòng đầu tiên là số lượng bộ test T (T ≤ 20). Mỗi test bắt đầu bởi hai số nguyên N và M
(1 ≤ N ≤ 100, M ≤ N*(N-1)/2). M dòng tiếp theo, mỗi dòng gồm 2 số nguyên u, v cho biết có cạnh nối đơn hướng từ u tới v.
Output:  Với mỗi test, in ra đáp án tìm được với độ chính xác 2 chữ số sau dấu phảy.
Input                 Output
2
4 5                   1.83
1 2
2 4
1 3
3 1
4 3
7 5                   1.75
1 2
1 4
4 2
2 7
7 1
Giải thích test 1: Ta có
d(1, 2) = 1, d(1, 3) = 1, d(1, 4) = 2; d (2, 1) = 3, d(2, 3) = 2, d(2, 4) = 1;
d(3, 1) = 1, d(3, 2) = 2, d(3, 4) = 3; d(4, 1) = 2, d(4, 2) = 3, d(4, 3) = 1.
Trung bình bằng 22/12 = 1.83
*/
//Ý tưởng: tính tổng của tất cả đường đi sau đó chia cho số lượng đường đi
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, vs[105], used[105];
vector <int> edge[105];
vector <int> a;

void init() { //hàm khởi tạo
    cin >> v >> e;
    int i, j;
    while (e--) {
        cin >> i >> j;
        edge[i].push_back (j); //tạo ma trận kề
    }
}

float minPath() { //hàm tìm đường đi nhỏ nhất
    float cnt = 0; //đếm độ lượng đường đi
    for (int i = 0; i < a.size (); i++) {
        for (int j = 0; j < a.size (); j++) {
            if (i != j) { //tìm đường đi của tất cả các đỉnh đến nhau
                memset (used, 0, sizeof (used));
                queue <int> q; //sử dụng bfs để tìm đường đi nhỏ nhất
                q.push (a[i]); //thêm đỉnh bắt đầu vào hàng đợi
                used[a[i]] = 1; //đánh dấu nó đã được đi qua
                while (!q.empty ()) {
                    int u = q.front ();
                    for (int k = 0; k < edge[u].size (); k++) { //tìm tất cả các đỉnh kề với nó chưa được đi qua
                        int tmp = edge[u][k];
                        if (!used[tmp]) {
                            used[tmp] = used[u] + 1; //đánh dấu nó đã được đi qua
                            q.push (tmp); //thêm nó vào hàng đợi
                        }
                    }
                    if (used[a[j]] != 0) { //nếu đến đích
                        cnt += used[a[j]] - 1; //tăng độ dài đường đi
                        break;
                    }
                    q.pop ();
                }
            }
        }
    }
    return cnt / (a.size () * (a.size () - 1)); //trả về đường đi trung bình nhỏ nhất
}

void solve() { //hàm xử lý
    float res = 32767; //khởi tạo kết quả
    for (int i = 1; i <= v; i++) vs[i] = 0; //đánh dấu tất cả đều chưa được đi qua
    for (int i = 1; i <= v; i++) {
        if (!vs[i]) { //nếu đỉnh chưa được đi qua
            vs[i] = 1; //đánh dấu đỉnh được đi qua
            a.clear ();
            a.push_back (i); //thêm đỉnh đó vào hàng đợi
            queue <int> q;
            q.push (i);
            while (!q.empty ()) {
                int u = q.front ();
                q.pop ();
                for (int j = 0; j < edge[u].size (); j++) { //tìm tất cả các đỉnh chưa đi qua kề với đỉnh u
                    int tmp = edge[u][j];
                    if (!vs[tmp]) {
                        vs[tmp] = 1;
                        q.push (tmp); //thêm đỉnh đó vào hàng đợi
                        a.push_back (tmp); //thêm vào mảng các đỉnh đã duyệt
                    }
                }
            }
            if (a.size () > 1) {
                float f = minPath (); //nếu đỉnh hiện tại có đường đi đến đỉnh khác thì tìm đường đi nhỏ nhất
                if (f < res) res = f; //cập nhật kết quả
            }
        }
    }
    cout << setprecision (2) << fixed << res << endl; //đưa ra kết quả
    for (int i = 1; i <= v; i++) edge[i].clear (); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
265. DSA11028	ĐỘ CAO CỦA CÂY
/*Cho một cây có N node, gốc tại  1. Độ cao của một node u được tính bằng khoảng cách từ u tới node gốc. Độ cao của node
gốc bằng 0. Nhiệm vụ của bạn là hãy tìm node xa node gốc nhất và in ra độ cao của node này.
Input:
Dòng đầu tiên là số lượng bộ test T( T≤ 20).
Mỗi test bắt đầu bằng số nguyên N (1 ≤ N ≤ 100 000).
N-1 dòng tiếp theo, mỗi dòng gồm 2 số nguyên u, v cho biết node u nối với node v.
Output:
Với mỗi test, in ra một số nguyên là độ cao của cây.
Input                 Output 
2
5                     2
1 2
1 3
2 4
2 5
4                     3
1 2
2 3
3 4
*/
//Ý tưởng: sử dụng bfs hoặc dfs duyệt đến đỉnh không có đỉnh kề thì cập nhật kết quả

#include <bits/stdc++.h>
using namespace std;

int v;
vector <int> a[100005];

void init() { //hàm khởi tạo
    cin >> v;
    int x, y;
    for (int i = 1; i < v; i++) {
        cin >> x >> y;
        a[x].push_back (y); //tạo ma trận kề
    }
}

int maxHigh() { //hàm xử lý
    queue <pair <int, int> > q;
    q.push ({1, 0}); //đưa gốc vào hàng đợi
    int res = 0; //khởi tạo kết quả
    while (!q.empty ()) {
        int tmp = q.front ().first;
        int cnt = q.front ().second;
        q.pop ();
        res = max (res, cnt); //cập nhật kết quả
        for (int i = 0; i < a[tmp].size (); i++) q.push ({a[tmp][i], cnt + 1}); //thêm đỉnh tiếp theo vào hàng đợi
    }
    return res; //trả về kết quả
}

void solve() {
    cout << maxHigh () << endl; //đưa ra kết quả
    for (int i = 1; i <= v; i++) a[i].clear (); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
266. DSA11029	ĐƯỜNG ĐI TỚI NODE LÁ
/*Cho một cây có N node, gốc tại 1. Với mỗi node lá, bạn hãy in ra đường đi từ node gốc tới nó.
Input:
Dòng đầu tiên là số lượng bộ test T( T≤ 20).
Mỗi test bắt đầu bằng số nguyên N (1 ≤ N ≤ 1000).
N-1 dòng tiếp theo, mỗi dòng gồm 2 số nguyên u, v cho biết node u nối với node v.
Output:
Với mỗi test, in ra K dòng, trong đó K là số lượng node lá. Mỗi dòng là đường đi từ node gốc tới node lá X. Node lá nào
có nhãn nhỏ hơn, in ra trước.
Input                 Output
2
5                     1 3
1 2                   1 2 4
1 3                   1 2 5
2 4
2 5
4                     1 2 3 4
1 2
2 3
3 4
*/
//Ý tưởng: sử dụng bfs hoặc dfs để tìm đường đi
//Code:

#include <bits/stdc++.h>
using namespace std;

int n;
vector <int> a[1005];

void init() { //hàm khởi tạo
    cin >> n;
    int x, y;
    for (int i = 1; i < n; i++) {
        cin >> x >> y;
        a[x].push_back (y); //tạo ma trận kề
    }
}

void solve() { //hàm xử lý
    for (int i = 1; i <= n; i++) sort (a[i].begin (), a[i].end ()); //sắp xếp lại thứ tự các đỉnh
    queue <int> q;
    q.push (1);
    int prev[n + 1]; //mảng đỉnh trước
    memset (prev, 0, sizeof (prev)); //khởi tạo không có đỉnh nào đứng trước
    vector <int> res; 
    while (!q.empty ()) {
        int u = q.front (); //lấy ra đỉnh đầu của hàng đợi
        q.pop ();
        if (a[u].size () == 0) res.push_back (u); //nếu là lá thì thêm lá vào kết quả
        else { 
            for (int i = 0; i < a[u].size (); i++) { //tìm tất cả các đỉnh kề với đỉnh u
                int tmp = a[u][i];
                prev[tmp] = u; //đánh dấu u là đỉnh trước đỉnh đó
                q.push (tmp); //đưa đỉnh đó vào hàng đợi
            }
        }
    }
    sort (res.begin (), res.end ()); //sắp xếp lại kết quả
    for (int i = 0; i < res.size (); i++) { //sắp xếp lại thứ tự theo chiều xuôi
        stack <int> s;
        int tmp = res[i]; //bắt đầu tìm từ lá
        while (tmp != 0) {
            s.push (tmp);
            tmp = prev[tmp];
        }
        while (!s.empty ()) { //đưa ra kết quả
            cout << s.top () << " ";
            s.pop ();
        }
        cout << endl;
    }
    for (int i = 1; i <= n; i++) a[i].clear (); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
267. DSA08020	BIẾN ĐỔI SỐ NGUYÊN TỐ
/*Cho cặp số S và T là các số nguyên tố có 4 chữ số (Ví dụ S = 1033, T = 8197 là các số nguyên tố có 4 chữ số). Hãy viết
chương trình tìm cách dịch chuyển S thành T thỏa mãn đồng thời những điều kiện dưới đây:
Mỗi phép dịch chuyển chỉ được phép thay đổi một chữ số của số ở bước trước đó (ví dụ nếu S=1033 thì phép dịch chuyển S
thành 1733 là hợp lệ);
Số nhận được cũng là một số nguyên tố có 4 chữ số (ví dụ nếu S=1033 thì phép dịch chuyển S thành 1833 là không hợp lệ,
và S dịch chuyển thành 1733 là hợp lệ); Số các bước dịch chuyển là ít nhất.
Ví dụ số các phép dịch chuyển ít nhất để S = 1033 thành  T = 8179 là 6 bao gồm các phép dịch chuyển như sau:
8179 ß 8779ß 3779ß 3739ß 3733ß 1733ß 1033.
Input:
Dòng đầu tiên đưa vào số lượng test T (T≤100)
Những dòng kế tiếp mỗi dòng đưa vào một test. Mỗi test là một bộ đôi S, T.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
2
1033 8179             6
1033 8779             5
*/
//Ý tưởng: thực hiện bfs đến khi tìm được đích
//Code:

#include <bits/stdc++.h>
using namespace std;

int S, T, l, r;
int vs[1100];
vector <int> b[2000];
vector <int> a;

bool compare(int num1, int num2) { //hàm so sánh 2 số
    string s1 = to_string (num1);
    string s2 = to_string (num2);
    int c = 0;
    if (s1[0] != s2[0]) c++;
    if (s1[1] != s2[1]) c++;
    if (s1[2] != s2[2]) c++;
    if (s1[3] != s2[3]) c++;
    return (c == 1); //nếu khác 1 chữ số thì trả về true
}

int bfs(int u) { //hàm bfs
    queue <int> q;
    vs[u] = 1;
    q.push(u); //thêm số bắt đầu vào hàng đợi
    while (! q.empty()) {
        int p = q.front();
        q.pop();
        for (int i = 0; i < b[p].size(); i ++) { //tìm tất cả các số có thể biến đổi mà chưa được duyệt qua
            int tmp = b[p][i];
            if (! vs[tmp]) {
                vs[tmp] = vs[p] + 1; //tăng số bước biến đổi
                q.push(tmp); //thêm số đó vào hàng đợi
            }
            if (tmp == r) return vs[tmp] - 1; //trả về kết quả nếu tìm thấy
        }
    }
}

void solve(){ //hàm xử lý
    bool isPrime[10000] = {false};
    //sử dụng sàng nguyên tố để tạo số nguyên số có 4 chữ số
    for (int i = 2; i < 10000; i ++)
        if (isPrime[i] == false)
            for (int j = i * i; j <= 10000; j += i) isPrime[j] = true;
    for (int i = 1000; i < 10000; i ++)
        if (! isPrime[i]) a.push_back(i);
    for (int i = 0; i < a.size(); i ++) //tạo ma trận kề khi các số khác nhau đúng 1 chữ số
        for (int j = i + 1; j < a.size(); j ++)
            if (compare(a[i], a[j]) == 1) {
                b[i].push_back(j);
                b[j].push_back(i);
            }
}

void init() { //hàm khởi tạo
    cin >> S >> T;
}

void print() { //hàm in
    memset (vs, 0, sizeof (vs));
    for (int i = 0; i < a.size (); i++) //tìm vị trí của S trong mảng các số
        if (S == a[i]) {
            l = i;
            break;
        }
    for (int i = 0; i < a.size (); i++) //tìm vị trí của T trong mảng các số
        if (T == a[i]) {
            r = i;
            break;
        }
    if (l != r) cout << bfs (l) << endl; //đưa ra kết quả
    else cout << "0" << endl;
}

int main() {
    int t;
    cin >> t;
    solve();
    while (t --) {
        init();
        print();
    }
    return 0;
}
268. DSA02028	CHIA ĐỀU
/*Cho dãy số A có N phần tử và số K. Hãy đếm số cách chia dãy A thành K nhóm các phần tử liên tiếp sao cho tổng giá trị
của mỗi nhóm đều bằng nhau.
Input
Dòng đầu ghi hai số N và K (0 < N ≤ 12; 0 < K < N ).
Dòng thứ 2 ghi N số của dãy A (-10000 ≤ A[i] ≤ 10000)
Output
In ra số cách thỏa mãn
Input                 Output
3 2                   2
-2 0 -2

3 2                   1
1 2 3
*/
//Ý tưởng: quay lui với trường hợp sử dụng và không sử dụng phần tử hiện tại
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, k, res;
int a[15], sum;

void init() { //hàm khởi tạo
    cin >> n >> k;
    sum = 0;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
        sum += a[i]; //tỉnh tổng của mảng
    }
}

void Try(int i, int s, int cnt) { //hàm quay lui
    if (i < n - 1) { //nếu chưa duyệt hết mảng
        if (s + a[i] == sum * (cnt + 1)) //nếu ghép số a[i] vào ra được 1 nhóm tổng bằng k
            Try (i + 1, s + a[i], cnt + 1); //thử với trường hợp a[i] thuộc nhóm khác
        Try (i + 1, s + a[i], cnt); //thử với trường hợp a[i] vẫn thuộc nhóm hiện tại
    }
    if (i == n - 1) if (cnt == k - 1) res++; //nếu duyệt đến phần tử cuối cùng mà số nhóm bằng k-1 thì tăng số cách
}

void solve() { //hàm xử lý
    res = 0; //khởi tạo kết quả
    if (sum % k == 0) {
        sum /= k; //lấy tổng của mỗi cặp
        Try (0, 0, 0); //thực hiện quay lui
    }
    cout << res; //đưa ra kết quả
}

int main() {
    init ();
    solve ();
    return 0;
}
269. DSA06045	XÂU TỐT
270. DSA07024	GHÉP VÁN GỖ
271. DSA08022	BỘI SỐ LỚN NHẤT CỦA 3
/*Cho dãy số A[] có N phần tử là các chữ số từ 0 đến 9. Nhiệm vụ của bạn là hãy chọn lấy một tổ hợp các phần tử và sắp
xếp chúng sao cho thu được số lớn nhất chia hết cho 3.
Nếu không tìm được số nào, in ra -1.
Input:
Dòng đầu tiên là số lượng bộ test T (1 ≤ N ≤ 50).
Mỗi test bắt đầu bởi số nguyên N (1 ≤ N ≤ 100 000).
Dòng tiếp theo gồm N số nguyên A[i] (0 ≤ A[i] ≤ 9).
Output:
Với mỗi test, in ra đáp án tìm được trên một dòng.
Input                 Output
3
3                     981
8 1 9
5                     8760
8 1 7 6 0
2                     -1
5 2
*/
//Ý tưởng: sắp xếp lại sau đó chọn loại ra ít chữ số nhất có thể để tổng còn lại chia hết cho 3
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, sum, check, a[100005];

void init() {
    cin >> n;
    sum = 0;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
        sum += a[i]; //tỉnh tổng các chữ số
    }
}

void solve() {
    sort (a, a + n);
    if (sum % 3 == 0) {
        if (a[n - 1] == 0) cout << "0" << endl; //nếu mảng toàn số 0 đưa ra 0
        else for (int i = n - 1; i >= 0; i--) cout << a[i]; //nếu không đưa ra số theo thứ tự giảm dần của chữ số
    } else {
        queue <int> div1; //hàng đợi chưa các số chia 3 dư 1
        queue <int> div2; //hàng đợi chưa các số chia 3 dư 2
        for (int i = 0; i < n; i++) {
            if (div1.size () < 2 && a[i] % 3 == 1) { //thêm vào số chua cho 3 dư 1
                div1.push (a[i]);
                a[i] = -1; //đánh dấu loại bỏ phần tử đó
            } else if (div2.size () < 2 && a[i] % 3 == 2) { //thêm vào số chua cho 3 dư 2
                div2.push (a[i]);
                a[i] = -1; //đánh dấu loại bỏ phần tử đó
            } else if (div1.size () == 2 && div2.size () == 2) break; //nếu tìm đủ 2 số thì dừng lại
        }
        priority_queue <int, vector <int>, less <int> > q;
        for (int i = 0; i < n; i++)
            if (a[i] != -1) q.push (a[i]); //thêm các chữ số còn lại vào hàng đợi
        if (sum % 3 == 1) { //nếu tổng chia cho 3 dư 1
            if (div1.empty () && div2.size () != 2) cout << "-1"; //nếu không thể tạo đưa ra -1 ((1-4)%3=0 && (1-1)%3=0)
            else {
                if (!div1.empty ()) { //nếu có số chia 3 dư 1
                    div1.pop (); //loại bỏ số nhỏ nhất
                    q.push (div1.front ()); //thêm số còn lại nếu có vào hàng đợi
                    while (!div2.empty ()) { //thêm các số còn lại của vào hàng đợi
                        q.push (div2.front ());
                        div2.pop ();
                    }
                }
            }
        } else if (sum % 3 == 2) { //nếu tổng chia 3 dư 2
            if (div1.size () != 2 && div2.empty ()) cout << "-1"; //không thể tạo đưa ra -1 ((2-2)%3==0 && (2-1-1)%3=0)
            else if (!div2.empty ()) { //nếu có số chia 3 dư 2
                div2.pop (); //loại bỏ số nhỏ nhất
                q.push (div2.front ()); //thêm số còn lại nếu có vào hàng đợi
                while (!div1.empty ()) { //thêm các số còn lại của vào hàng đợi
                    q.push (div1.front ());
                    div1.pop ();
                }
            }
        }
        if (q.empty ()) cout << "-1"; //nếu không thể tạo đưa ra -1
        else //đưa ra kết quả
            while (!q.empty ()) {
                cout << q.top ();
                q.pop ();
            }
    }
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
272. DSA05039	TỔNG CHỮ SỐ
/*Cho hai số nguyên dương A và B. Tìm số N nhỏ nhất thỏa mãn: A là tổng các chữ số của N, B là tổng bình phương các chữ
số của N. Nếu không tồn tại N thỏa mãn A và B hãy đưa ra -1. Giả thiết N có không quá 100 chữ số.
Ví dụ với A = 18, B = 162 ta tìm được số nhỏ nhất N=99 vì 9+9=18 và 92 + 92 = 162. Với A = 12, B = 9 ta có kết quả là -1
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là cặp số A, B được viết trên một dòng.
T, A, B thỏa mãn ràng buộc: 1≤T≤100;  1≤A≤100; 1≤B≤10000.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                 Output
2
18  162               99
12  9                 -1
*/
//Ý tưởng: tìm số chữ số nhỏ nhất có thể sau đó thực hiện truy vét để tìm số đó

#include <bits/stdc++.h>
using namespace std;

int dp[905][8105];
int a,b;

void init() {
    cin >> a >> b;
}

int minDigits(int x, int y) {
    if (x > y || x < 0 || y < 0 || x > 100 || y > 8100) return -1; //không nằm trong khoảng xác định
    if (x == 0 && y == 0) return 0;
    if (dp[x][y] != -1) return dp[x][y]; //nếu số chữ số khác -1 tức là đã có th thoả mãn
    int ans = 101;
    for (int i = 9; i >= 1; i--) {
        int k = minDigits (x - i, y - (i * i)); //tìm số chữ số nhỏ nhất sau khi chọn 1 chữ số
        if (k != -1) ans = min (ans, k + 1); //so sánh số tìm được với giá trị nhỏ nhất hiện tại để cập nhật min
    }
    return dp[x][y] = ans; //trả về số chữ số ít nhất
}

void solve() {
    memset (dp, -1, sizeof (dp));
    dp[0][0] = 0;
    int k = minDigits (a, b);
    if (k == -1 || k > 100) cout << "-1"; //nếu nằm ngoài khoảng xác định thì in -1
    else {
        while (a > 0 && b > 0) //tìm từng chữ số của kết quả
            for (int i = 1; i <= 9; i++)
                if (a >= i && b >= i * i && 1 + dp[a - i][b - i * i] == dp[a][b]) {
                    //nếu chọn chữ số i mà số giá trị của dp[a - i][b - i * i ] bằng dp[a][b] tức là kết quả chứa i
                    cout << i; //in ra chữ số hiện tại đã duyệt đến của kết quả
                    a -= i;
                    b -= i * i;
                    break; //kết thúc để tìm kiếm chữ số sau nó
                }
    }
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
273. DSA09031	CHÚ CỪU XA CÁCH
/*Trên cánh đồng kích thước N x N có K chú cừu. Người nông dân sợ các chú cừu đi lạc nên đã làm một số rào chắn giữa các
khu vực. Các chú cừu chỉ có thể di chuyển lên trên, xuống dưới, sang trái, sang phải khu vực bên cạnh, và không thể vượt
qua được hàng rào.
Hai chú cừu A và B được gọi là ‘xa cách’ nếu như chúng không thể di chuyển tới vị trí của nhau. Các bạn hãy xác định xem
số cặp chú cừu xa cách bằng nhau nhiêu?
Input:  Dòng đầu tiên gồm 3 số nguyên dương N, K và M (1 ≤  N ≤  100, K ≤  100, M ≤  N^2).  M dòng tiếp theo, mỗi dòng
gồm 4 số nguyên u, v, x, y cho biết có rào chắn ở giữa hai khu vực (u, v) và (x, y) (2 ô này cạnh nhau). K dòng cuối,
mỗi dòng chứa 2 số nguyên là tọa độ của mỗi chú cừu.
Output: In ra số cặp chú cừu bị xa cách tìm được.
Input                 Output
3 3 3                 2
2 2 2 3
3 3 3 2
3 3 2 3
3 3
2 2
2 3
*/
//Ý tưởng: tạo hàng rào sau đó dùng bfs hoặc dfs để đếm số cừu
//Code:

#include <bits/stdc++.h>
using namespace std;

struct data {
    int up, left, right, down;
};

int n, k, m, res, vs[105][105];
data a[105][105]; // mảng lưu trữ vị trí hàng rào
int dx[] = {-1, 0, 0, 1}; // toạ độ x ứng với lên, trái, phải, xuống
int dy[] = {0, -1, 1, 0}; // toạ độ y ứng với lên, trái, phải, xuống
vector <pair <int, int> > b;

bool check(int i, int j) {
    if (i < 1 || i > n || j < 1 || j > n) return false;
    return true;
}

void init() { //hàm khởi tạo
    cin >> n >> k >> m;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++) {
            vs[i][j] = 0; //đánh dấu tất cả chưa được thăm
            a[i][j] = {0, 1, 2, 3}; // đánh dấu tất cả vị trí đều đi được lên, trái, phải, xuống
        }
    int u, v, x, y;
    while (m--) {
        cin >> u >> v >> x >> y;
        if (u == x + 1) {
            a[u][v].up = -1; //đánh dấu có hàng rào
            a[x][y].down = -1; //đánh dấu có hàng rào
        } else if (v == y + 1) {
            a[u][v].left = -1; //đánh dấu có hàng rào
            a[x][y].right = -1; //đánh dấu có hàng rào
        } else if (v == y - 1) {
            a[u][v].right = -1; //đánh dấu có hàng rào
            a[x][y].left = -1; //đánh dấu có hàng rào
        } else {
            a[u][v].down = -1; //đánh dấu có hàng rào
            a[x][y].up = -1; //đánh dấu có hàng rào
        }
    }
    int i, j;
    for (int t = 0; t < k; t++) {
        cin >> i >> j;
        vs[i][j] = 2; //đánh dấu 2 là có cừu, đánh dấu 1 là đã duyệt qua, đánh dấu 0 là không có cừu và chưa duyệt qua
        b.push_back ({i, j}); //thêm con cừu
    }
}

void solve() { //hàm xử lý
    res = 0;
    int row, col;
    for (int i = 0; i < b.size (); i++) { //duyệt qua tất cả con cừu
        row = b[i].first;
        col = b[i].second;
        if (vs[row][col] == 2) { //nếu cừu chưa được duyệt qua
            vs[row][col] = 1; //đánh dấu đã được duyệt qua
            queue <pair <int, int> > q;
            q.push ({row, col}); //thêm con cừu đó vào hàng đợi
            int cnt = 1; //đánh dấu có 1 con cừu trong đàn hiện tại
            while (!q.empty ()) {
                row = q.front ().first;
                col = q.front ().second;
                q.pop ();
                if (a[row][col].up == 0) { // nếu bên trên không có hàng rào
                    int x = row + dx[0];
                    int y = col + dy[0];
                    if (check (x, y) && vs[x][y] != 1) { //kiểm tra nếu chưa được duyệt
                        if (vs[x][y] == 2) //nếu tại vị trí có cừu
                            cnt++; //tăng số con cừu trong 1 thành phần liên thông
                        vs[x][y] = 1; // đánh dấu đã duyệt qua
                        q.push ({x, y}); //thêm con cừu đó vào hàng đợi
                    }
                }
                if (a[row][col].left == 1) { // nếu bên trái không có hàng rào
                    int x = row + dx[1];
                    int y = col + dy[1];
                    if (check (x, y) && vs[x][y] != 1) { //kiểm tra nếu chưa được duyệt
                        if (vs[x][y] == 2) //nếu tại vị trí có cừu
                            cnt++; //tăng số con cừu trong 1 thành phần liên thông
                        vs[x][y] = 1; //đánh dấu đã duyệt qua
                        q.push ({x, y}); //thêm con cừu đó vào hàng đợi
                    }
                }
                if (a[row][col].right == 2) { // nếu bên phải không có hàng rào
                    int x = row + dx[2];
                    int y = col + dy[2];
                    if (check (x, y) && vs[x][y] != 1) { //kiểm tra nếu chưa được duyệt
                        if (vs[x][y] == 2)  //nếu tại vị trí có cừu
                            cnt++; //tăng số con cừu trong 1 thành phần liên thông
                        vs[x][y] = 1; //đánh dấu đã duyệt qua
                        q.push ({x, y}); //thêm con cừu đó vào hàng đợi
                    }
                }
                if (a[row][col].down == 3) { // nếu bên dưới không có hàng rào
                    int x = row + dx[3];
                    int y = col + dy[3];
                    if (check (x, y) && vs[x][y] != 1) { //kiểm tra nếu chưa được duyệt
                        if (vs[x][y] == 2) //nếu tại vị trí có cừu
                            cnt++; //tăng số con cừu trong 1 thành phần liên thông
                        vs[x][y] = 1; //đánh dấu đã duyệt qua
                        q.push ({x, y}); //thêm con cừu đó vào hàng đợi
                    }
                }
            }
            k -= cnt; // số con cừu còn lại chưa được duyệt qua
            res += k * cnt; //số cừu trong đàn hiện tại nhân với số con cừu chưa được duyệt qua
        }
    }
    cout << res << endl; //đưa ra kết quả
}

int main() {
    init ();
    solve ();
    return 0;
}
274. DSA09049	LAN TRUYỀN DINH DƯỠNG
/*Cho một cây có N đỉnh và gốc tại đỉnh 1. Mỗi nút lá có chức năng tổng hợp chất dinh dưỡng, đồng thời lan truyền năng
lượng cũng như các chất dinh dưỡng cho nút cha của nó để thực hiện quá trình tổng hợp.
Quá trình lan truyền năng lượng sẽ làm tăng giá trị dinh dưỡng lên 1. Tức là nếu một nút tổng hợp được giá trị dinh
dưỡng bằng V, sẽ giúp cho nút cha của nó sẽ tổng hợp được giá trị dinh dưỡng bằng V+1. Nếu một nút cha có nhiều nút con,
giá trị dinh dưỡng của nó bằng tổng của giá trị dinh dưỡng của các nút con gửi lên.
Biết rằng mỗi nút lá ban đầu tổng hợp được chất dinh dưỡng có giá trị 1. Nhiệm vụ của bạn là hãy xác định xem mỗi nút
của cây tổng hợp được bao nhiêu giá trị dinh dưỡng?
Input:
Dòng đầu tiên là số lượng đỉnh N (N <= 200 000).
Dòng tiếp theo gồm N-1 số nguyên, a[2], a[3], …, a[N] lần lượt là cha của các nút 2, 3, …, N.
Output:
In ra N số nguyên, số nguyên thứ i cho biết giá trị dinh dưỡng mà nút i tổng hợp được.
Input                 Output
3
1 1                   5 1 1
5
1 2 2 4               13 8 1 3 1
*/
//Ý tưởng: tạo kiểu dữ liệu struct gồm giá trị dinh dưỡng hiện tại và số con của nó, cập nhật dần kết quả từ cuối lên
//Code:

#include <bits/stdc++.h>
using namespace std;

struct data { //kiểu dữ liệu data
    long long val;
    int cntSon;
};

int n, father[200005];
data a[200005];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 2; i <= n; i++) cin >> father[i];
}

void solve() { //hàm xử lý
    for (int i = 1; i <= n; i++) {
        a[i].cntSon = 1; //gán tất cả đều có 1 con
        a[i].val = 0; //gán giá trị dinh dưỡng hiện tại bằng 0
    }
    for (int i = n; i >= 1; i--) { //bắt đầu cập nhật kết quả
        a[i].val += a[i].cntSon; //giá trị dinh dưỡng được thêm bởi số con
        a[father[i]].cntSon += a[i].cntSon; //cập nhật số con
        a[father[i]].val += a[i].val; //giá trị dinh dưỡng bằng giá trị dinh dưỡng của các con gửi lên
    }
    for (int i = 1; i <= n; i++) cout << a[i].val << " "; //đưa ra kết quả
}

int main() {
    init ();
    solve ();
    return 0;
}
275. DSA09034	ĐẾM SỐ AO
/*Sau khi thi trượt môn Cấu trúc dữ liệu và giải thuật, một số sinh viên D19 CNTT - PTIT quyết định bỏ học, đầu tư thuê
đất để trồng rau. Mảnh đất thuê là một hình chữ nhật N x M (1≤ N≤ 100; 1≤ M≤ 100) ô đất hình vuông. Nhưng chỉ sau đó vài
ngày, trận lụt khủng khiếp đã diễn ra làm một số ô đất bị ngập. Mảnh đất bỗng biến thành các cái ao. Và sinh viên D19
lại dự định chuyển sang nuôi cá. Các bạn ấy muốn biết mảnh đất được chia thành bao nhiêu cái ao để có thể tính toán nuôi
cá cho hợp lý. Hãy giúp các bạn ấy nhé. Chú ý: Ao là gồm một số ô đất bị ngập có chung đỉnh. Dễ nhận thấy là một ô đất
có thể có tối đa 8 ô chung đỉnh.
Dữ liệu vào: Dòng1: 2 số nguyên cách nhau bởi dấu cách: N và M. Dòng 2..N+1: M kí tự liên tiếp nhau mỗi dòng đại diện
cho 1 hàng các ô đất.  Mỗi kí tự là 'W' hoặc '.' tương ứng với ô đất đã bị ngập và ô đất vẫn còn nguyên.
Kết quả:  Một dòng chứa 1 số nguyên duy nhất là số ao tạo thành.
Input                 Output
10 12                 3
W........WW.
.WWW.....WWW
....WW...WW.
.........WW.
.........W..
..W......W..
.W.W.....WW.
W.W.W.....W.
.W.W......W.
..W.......W.
*/
//Ý tưởng: đếm số thành phần liên thông
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, m, res, vs[105][105];
char a[105][105];

void dfs(int i, int j) { //hàm dfs
    vs[i][j] = 1; //đánh dấu điểm hiện tại đã thăm
    //tìm ở cả 8 hướng xem đâu bị ngập thì dfs tại đó
    if (a[i - 1][j] == 'W' && vs[i - 1][j] == 0) dfs(i - 1, j);
    if (a[i - 1][j - 1] == 'W' && vs[i - 1][j - 1] == 0) dfs(i - 1, j - 1);
    if (a[i - 1][j + 1] == 'W' && vs[i - 1][j + 1] == 0) dfs(i - 1, j + 1);
    if (a[i][j - 1] == 'W' && vs[i][j - 1] == 0) dfs(i, j - 1);
    if (a[i][j + 1] == 'W' && vs[i][j + 1] == 0) dfs(i, j + 1);
    if (a[i + 1][j - 1] == 'W' && vs[i + 1][j - 1] == 0) dfs(i + 1, j - 1);
    if (a[i + 1][j] == 'W' && vs[i + 1][j] == 0) dfs(i + 1, j);
    if (a[i + 1][j + 1] == 'W' && vs[i + 1][j + 1] == 0) dfs(i + 1, j + 1);
}

void init() { //hàm khởi tạo
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            cin >> a[i][j];
}

void solve() { //hàm xử lý
    memset (vs, 0, sizeof (vs));
    for (int i = 1; i <= n; i++) //đếm số thành phần liên thông
        for (int j = 1; j <= m; j++) 
            if (a[i][j] == 'W' && vs[i][j] == 0) {
                res++;
                dfs (i, j);
            }
    cout << res << endl; //đưa ra kết quả
}

int main() {
    init ();
    solve ();
    return 0;
}
276. DSA09037	HỌP MẶT
/*Có K người (1 ≤ K ≤ 100) đứng tại vị trí nào đó trong N địa điểm cho trước (1 ≤ N ≤ 1,000) được đánh số từ 1..N. Các
điểm được nối với nhau bởi M đoạn đường một chiều (1 ≤ M ≤ 10,000) (không có đoạn đường nào nối một điểm với chính nó).
Mọi người muốn cùng tụ họp tại một địa điểm nào đó. Tuy nhiên, với các đường đi cho trước, chỉ có một số địa điểm nào đó
có thể được chọn là điểm họp mặt. Cho trước K, N, M và vị trí ban đầu của K người cùng với M đường đi một chiều, hãy xác
định xem có bao nhiêu điểm có thể được chọn làm điểm họp mặt.
Input
Dòng 1: Ghi 3 số: K, N, và M
Dòng 2 đến K+1: dòng i+1 chứa một số nguyên trong khoảng (1..N) cho biết địa điểm mà người thứ i đang đứng.
Dòng K+2 đến M+K+1: Mỗi dòng ghi một cặp số A và B mô tả một đoạn đường đi một chiều từ A đến B (cả hai trong khoảng
1..N và A != B).
Output
Số địa điểm có thể được chọn là điểm họp mặt.
Input                 Output
2 4 4                 2
2
3
1 2
1 4
2 3
3 4
*/
//Ý tưởng: kiểm tra các địa điểm mỗi người có thế đến và kiểm tra xem có điểm nào trùng nhau
//Code:

#include <bits/stdc++.h>
using namespace std;

int k, n, m, vs[1005];
vector <int> edge[1005];
vector <int> a;
set <int> res;
set <int>::iterator it;

void init() { //hàm khởi tạo
    cin >> k >> n >> m;
    while (k--) {
        int x;
        cin >> x;
        a.push_back (x);
    }
    int i, j;
    while (m--) {
        cin >> i >> j;
        edge[i].push_back (j);  //tạo ma trận kề
    }
}

void bfs(int u) { //hàm bfs
    set <int> s;
    for (it = res.begin (); it != res.end (); it++) s.insert (*it); //thêm các đia điểm còn có thể đến vào s
    res.clear (); //làm mới kết quả
    res.insert (u); //thêm địa điểm hiện tại vào kết quả
    queue <int> q;
    q.push (u);
    while (!q.empty ()) {
        u = q.front (); 
        q.pop ();
        for (int i = 0; i < edge[u].size (); i++) { //tìm tất cả các địa điểm mà từ u có thể đi tới
            int tmp = edge[u][i];
            if (!vs[tmp] && s.find (tmp) != s.end ()) { //nếu địa điểm đó có thể đến được
                res.insert (tmp); //thêm địa điểm đó vào kết quả
                q.push (tmp);
                vs[tmp] = 1; //đánh dấu nó đã đi qua
            }
        }
    }
}

void solve() { //hàm xử lý
    for (int i = 1; i <= n; i++) res.insert (i); //thêm tất cả địa điểm vào kết quả
    for (int i = 0; i < a.size (); i++) {
        for (int j = 1; j <= n; j++) vs[j] = 0; //đánh dấu chưa thăm địa điểm nào
        bfs (a[i]); //thực hiện bfs tại điểm đó
    }
    cout << res.size () << endl; //đưa ra kết quả
    res.clear (); //làm mới kết quả
}

int main() {
    init ();
    solve ();
    return 0;
}
277. DSA10015	KRUSKAL
278. DSA10017	CHU TRÌNH ÂM
/*Cho đồ thị có trọng số G=<V, E> được biểu diễn dưới dạng danh sách cạnh trọng số âm hoặc dương. Hãy viết chương trình
xác định xem đồ thị có chu trình âm hay không.
Input:
Dòng đầu tiên đưa vào T là số lượng bộ test.
Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm |E|+1 dòng: dòng đầu tiên đưa vào hai số |V|, |E| tương ứng
với số đỉnh và số cạnh của đồ thị; |E| dòng tiếp theo mỗi dòng đưa vào bộ ba uÎV, vÎV, w tương ứng với một cạnh cùng với
trọng số canh của đồ thị.
T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤103; 1≤|E|≤|V|(|V|-1)/2;
Output:
Đưa ra 1 hoặc 0 theo từng dòng của mỗi test tương ứng với đồ thị có hoặc không có chu trình âm.
Input                 Output
2
3  3                  0
1  2 -1
2  3  4
3  1 -2
3  3                  1
1  2 -1
2  3  2
3  1 -2
*/
//Ý tưởng: sử dụng thuật toán Floyd
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, negCycle, d[1005][1005];

void init() { //hàm khởi tạo
    cin >> v >> e;
    for (int i = 1; i <= v; i++)
        for (int j = 1; j <= v; j++) {
            if (i == j) d[i][j] = 0; //chi phí đi từ i đế chính nó bằng 0
            else d[i][j] = INT_MAX; //khởi tạo không có đường đi từ i đến j
        }
    int i, j, k;
    while (e--) {
        cin >> i >> j >> k;
        d[i][j] = k;
    }
}

void solve() { //hàm xử lý 
    negCycle = 0; //khởi tạo biến chu trình âm
    for (int k = 1; k <= v; k++) //sử dụng thuật toán Floyd tính đường đi nhỏ nhất giữa các đỉnh
        for (int i = 1; i <= v; i++) 
            for (int j = 1; j <= v; j++) 
                if (d[i][k] != INT_MAX && d[k][j] != INT_MAX && d[i][j] > d[i][k] + d[k][j]) d[i][j] = d[i][k] + d[k][j];
    for (int i = 1; i <= v; i++) {
        if (d[i][i] < 0) { //nếu đường đi từ 1 đỉnh quay về chính nó nhỏ hơn 0 thì tồn tại chu trình âm
            negCycle = 1;
            break;
        }
    }
    cout << negCycle << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
279. DSA02014	TỪ ĐIỂN
/*Cho tập từ ghi trong trừ điển dic[] và một bảng hai chiều A[M][N] các ký tự. Hãy tạo nên tất cả các từ có mặt trong từ
điển dic[] bằng cách nối các ký tự kề nhau trong mảng A[][]. Chú ý, phép nối các ký tự kề nhau trong mảng A[][] được
thực hiện theo 8 hướng nhưng không có phần tử A[i][j] nào được lặp lại. Ví dụ với từ điển dic[] ={ “GEEKS”, “FOR”,
“QIUZ”, “GO”} và mảng A[][] dưới đây sẽ cho ta kết quả: “GEEKS”, “QUIZ”
G I Z
U E K
Q S E
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất đưa vào ba số K, M, N tương ứng với số
từ của từ điển dic[], số hàng và số cột của ma trận ký tự A[M][N]; dòng tiếp theo đưa vào K từ của từ điển dic[]; dòng
cuối cùng đưa vào các phần tử A[i][j].
T, K, M, N thỏa mãn ràng buộc: 1≤T ≤10; 1≤K≤100; 1≤ M, N ≤3.
Output:
Đưa ra theo thứ tự tăng dần các từ có mặt trong từ điển dic[] được tạo ra từ ma trận A[][]. Đưa ra -1 nếu không thể tạo
ra từ nào thuộc dic[] từ A[][].
Input                 Output
1
4  3  3
GEEKS FOR QUIZ GO     GEEKS QUIZ
G I Z
U E K
Q S E
*/
//Ý tưởng: quay lui với 8 hướng
//Code:

#include <bits/stdc++.h>
using namespace std;

int k, m, n;
string str[110];
char a[5][5]; 
int used[5][5]; //mảng used dùng để đánh dấu phần tử đã sử dụng
vector <string> res;
int hang[]={-1, -1, -1, 0, 0, 1, 1, 1};  //mảng hàng dùng để lưu toạ độ của hàng theo 8 hướng so với vị trí hiện tại
int cot[]={-1, 0, 1, -1, 1, -1, 0, 1}; //mảng cột dùng để lưu toạ độ của cột theo 8 hướng so với vị trí hiện tại

void Try(int i, int j, string tmp) { //hàm quay lui
    for (int l = 0 ; l < k ; l++) 
        if (str[l] == tmp) res.push_back (tmp); //nếu có thể tìm ra từ thì lưu từ đó vào kết quả
    for (int l = 0 ; l < 8 ; l++) { //thử với 8 hướng của vị trí hiện tại
        int x = i + hang[l];
        int y = j + cot[l];
        if (x > 0 && y > 0 && x <= m && y <= n && used[x][y] == 0) { //nếu vị trí nào chưa được sử dụng thì đi đến đó
            used[x][y] = 1; //đánh dấu là đã sử dụng
            Try (x, y, tmp + a[x][y]); //tiếp tục thử tại vị trí hiện tại
            used[x][y] = 0; //sử dụng xong gán lại vị trí chưa sử dụng để đi hướng khác
        }
    }
}

void init() { //hàm khởi tạo
    cin >> k >> m >> n;
    for (int i = 0; i < k; i++) cin >> str[i];
    for (int i = 1; i <= m; i++)
        for (int j = 1; j <= n; j++)
            cin >> a[i][j];
}

void solve() { //hàm xử lý
    res.clear ();
    for (int i = 1; i <= m; i++)
        for (int j = 1; j <= n; j++) {
            memset (used, 0, sizeof (used)); //đánh dấu tất cả đều chưa sử dụng
            used[i][j] = 1;  //gán vị trí hiện tại đã sử dụng
            string s = "";
            Try (i, j, s + a[i][j]); //thử tại vị trí hiện tại
        }
    if (res.size () == 0) cout << "-1"; //đưa ra kết quả
    else
        for (int i = 0; i < res.size (); i++) cout << res[i] << " ";
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
280. DSA02018	BIỂU THỨC TOÁN HỌC
/*Cho 5 số nguyên dương A, B, C, D, E. Bạn có thể hoán vị các phần tử cho nhau, hãy đặt các dấu biểu thức +, -, * sao
cho biểu thức sau đúng:
[[[A o(1) B] o(2) C] o(3) D] o(4) E = 23
Trong đó: o(1) … o(4) là các phép toán +, -, *.
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test gồm 5 số nguyên dương A, B, C, D, E có giá trị không vượt quá 100.
Output: Với mỗi test, in ra đáp án tìm được, mỗi xâu in ra trên một dòng.
Input                                        Output
3
1 1 1 1 1                                    NO
1 2 3 4 5                                    YES
2 3 5 7 11                                   YES
*/
//Ý tưởng: sinh ra các hoán vị của các vị trí, sau đó đặt vào các dấu rồi kiểm tra xem có đúng không
//Code:

#include <bits/stdc++.h>
using namespace std;

int a[5], c[5], check;

void Try(int i, int res) { //bắt đầu thử từ 0 với kết quả bằng A
    if (check == 1) return; //nếu đã tìm ra trường hợp thoả mãn thì dừng
    for (int j = 2; j >= 0; j--) { //vòng lặp 2 ứng với '+' 1 ứng với '-' và 0 ứng với '*'
        if (j == 2) {
            res += c[i + 1];  //kết quả được cộng lên
            //khi đã duyệt đến E và kết quả bằng 23 thì gán biến kiểm tra bằng 1 chưa thử đến E thì thử tiếp
            if (i == 3 && res == 23) check = 1;
            else if (i < 3) Try(i + 1, res);
            res -= c[i + 1]; //khi dùng xong trả lại kết quả trước đó
        } else if (j == 1) {
            res -= c[i + 1];  //kết quả được trừ đi
            //khi đã duyệt đến E và kết quả bằng 23 thì gán biến kiểm tra bằng 1 chưa thử đến E thì thử tiếp
            if (i == 3 && res == 23) check = 1;
            else if (i < 3) Try(i + 1, res);
            res += c[i + 1];  //khi dùng xong trả lại kết quả trước đó
        }else {
            res *= c[i + 1];  //kết quả được nhân lên
            //khi đã duyệt đến E và kết quả bằng 23 thì gán biến kiểm tra bằng 1 chưa thử đến E thì thử tiếp
            if (i == 3 && res == 23) check = 1;
            else if (i < 3) Try(i + 1, res);
            res /= c[i + 1];    //khi dùng xong trả lại kết quả trước đó
        }
    }
}

void hoanvi(int k,int b[]) { //hàm sinh các hoán vị của A B C D E
    for (int i = 0; i <= 4; i++) {
        if (!b[a[i]]) {
            c[k] = a[i];
            b[a[i]] = 1;
            if (k == 4) {
                Try (0, c[0]);  //khi sinh xong 1 hoán vị thì thử các phép toán
                if (check == 1) break;  //nếu đã có kết quả đúng rồi thì dừng lại
            } else hoanvi (k + 1, b);
            b[a[i]] = 0;
        }
    }
}

void init() { //hàm khởi tạo
    for (int i = 0; i < 5; i++) {
        cin >> a[i];
        c[i] = a[i];
    }
}

void solve() {
    check = 0;
    int b[101] = {false};
    hoanvi (0, b); //bắt đầu quay lui
    if (check == 1) cout << "YES" << endl; //đưa ra kết quả
    else cout << "NO" << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
281. DSA02019	ĐƯỜNG ĐI DÀI NHẤT
/*Cho đồ thị vô hướng có N đỉnh và M cạnh. Bạn hãy tìm đường đi dài nhất trên đồ thị, sao cho mỗi cạnh chỉ được đi qua
nhiều nhất 1 lần.
Input: Dòng đầu tiên là số lượng bộ test T (T ≤ 10). Mỗi test bắt đầu bằng số nguyên N và M (1 ≤ N, M ≤ 20). Các đỉnh
đánh dấu từ 0, 1, …, N-1. M dòng tiếp theo, mỗi dòng gồm 2 số u, v cho biết có cạnh nối giữa uàv.
Output: Với mỗi test, in ra đáp án tìm được, mỗi xâu in ra trên một dòng.
Input                 Output
2
3 2                   2
0 1
1 2
15 16                 12
0 2
1 2
2 3
3 4
3 5
4 6
5 7
6 8
7 8
7 9
8 10
9 11
10 12
11 12
10 13
12 14
*/
//Ý tưởng: sử dụng dfs, khi đến đích thì cập nhật kết quả
//Code:

#include <bits/stdc++.h>
using namespace std;

int v, e, res, vs[20][20];
vector<int>a[20];

void Try(int i, int cnt) { //hàm quay lui
    res = max(res, cnt); //cập nhật kết quả
    for (int j = 0; j < a[i].size(); j ++) { //tìm tất cả các đỉnh kề với đỉnh hiện tại chưa được thăm
        int t = a[i][j];
        if (vs[i][t] == 0) { //nếu tìm thấy
            vs[i][t] = 1; //đánh dấu đã thăm
            vs[t][i] = 1;
            cnt ++; //tăng độ dài
            Try(t, cnt); //tiếp tục quay lui tại đỉnh đó
            vs[i][t] = 0; //trả lại chưa đi qua
            vs[t][i] = 0;
            cnt --;
        }
    }
}

void init(){ //hàm khởi tạo
    cin >> v >> e;
    while (e --) {
        int x, y;
        cin >> x >> y;
        a[x].push_back(y); //tạo ma trận kề
        a[y].push_back(x);
    }
}

void solve(){ //hàm xử lý
    res = INT_MIN; //khởi tạo kết quả
    for (int i = 0; i < v; i ++) {
        memset(vs, 0, sizeof(vs)); //đánh dấu tất cả chưa thăm
        Try(i, 0); //bắt đầu quay lui
    }
    for (int i = 0; i < v; i ++) a[i].clear(); //làm mới ma trận kề
    cout << res << endl; //đưa ra kết quả
}
int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
282. DSA02020	SỐ NHỎ NHẤT CÓ N ƯỚC SỐ
/*Cho số nguyên dương N. Nhiệm vụ của bạn là tìm số K nhỏ nhất, sao cho K có đúng N ước. Input đảm bảo rằng đáp án
không vượt quá 10^18.
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤  20).
Mỗi test gồm 1 số nguyên N ( 1 ≤  N ≤  1000).
Output:  Với mỗi test, in ra đáp án trên một dòng.
Input                Output
2
4                    8
6                    12
*/
//Ý tưởng: thử tất cả các trường hợp, nếu số nguyên tố hiện tại được sử dụng j lần thì số ước bằng sô ước cũ nhân j+1

#include<bits/stdc++.h>
using namespace std;

int n, a[]={2,3,5,7,11,13,17,19,23,29,31}; //tạo mảng số nguyên tố
long long res;

void Try(int i, long long tmp, long div) {
    if (div > n) return; //nếu ước lớn hơn n thì dừng lại nếu bằng thì so sánh với res hiện tại
    else if (div == n) res = min (res, tmp); //cập nhật kết quả
    for (int j = 1;; j++) { //j ứng với số lần sử dụng số nguyên tố
        if (tmp * a[i] > res) break;   //nếu kết quả trung gian lớn hơn kết quả hiện tại thì dừng lại
        tmp *= a[i]; //cập nhật kết quả trung gian mới
        Try (i + 1, tmp, div * (j + 1));   //thử tiếp với a[i+1]
    }
}

void init(){ //hàm khởi tạo
    cin>>n;
}

void solve() { //hàm xử lý
    res = 1e18; //khởi tạo kết quả
    Try (0, 1, 1); //bắt đầu thử
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
283. DSA02021	KÝ TỰ ĐẶC BIỆT
/*Cho một xâu s. Xâu F(s) được xác định bằng cách ghép xâu xâu s ban đầu với xâu s sau khi đã được quay vòng sang bên
phải 1 kí tự (kí tự cuối cùng của s được chuyển lên đầu).
Thực hiện liên tiếp các bước cộng xâu như trên với xâu mới thu được, ta có được xâu X.
Nhiệm vụ của bạn là hãy xác định kí tự thứ N trong xâu X là kí tự nào?
Input: Dòng đầu ghi số bộ test T (T<10). Mỗi bộ test gồm một xâu s có độ dài không vượt quá 30 kí tự và số nguyên N
(1 ≤ N ≤ 1018).
Output: Với mỗi bộ test ghi ra trên một dòng kí tự tìm được.
Input                Output
1                    C
COW 8
*/
/*Ý tưởng: nếu k nằm ở vị trí nhỏ hơn độ dài của xâu trước nó thì k là ký tự thứ k của xâu trước, còn không thì giảm k
đi độ dài của xâu trước nó vào tiếp tục tìm ký tự thứ k trong xâu đó*/
//Code:

#include<bits/stdc++.h>
using namespace std;

long long n;
int cnt;

long find(int cnt, long long k) { //hàm tìm kiếm vị trí của ký tự 
    if (cnt == 0) return k; //nếu ở xâu đầu tiên thì trả về vị trí thứ k
    else {
        n /= 2; //tính độ dài của xâu trước nó
        cnt--; //trở về xâu trước
        if (k >= n) { //nếu k lớn hơn độ dài của xâu trước
            k -= n; //giảm k đi độ dài của xâu đó
            if (k == 1 || k == 0) return find (cnt, n); //trả về ký tự cuối cùng của xâu trước
            else return find (cnt, k - 1); //trả về ký tự thứ k-1 của xâu trước
        } else return find (cnt, k); //trả về ký tự thứ k của xâu trước
    }
}

void solve(){ //hàm xử lý
    string str;
    cin >> str;
    long long k;
    cin >> k;
    if (k <= str.length ()) cout << str[k - 1] << endl; //nếu k nhỏ hơn độ dài của xâu ban đầu đưa ra kết quả
    else {
        n = str.length (), cnt = 0; //khởi tạo độ dài xâu ban đầu và thứ tự của xâu
        while (n < k) { //tìm tất cả luỹ thử của 2 nhỏ hơn hoặc bằng k
            n *= 2;
            cnt++;
        }
        cout << str[find (cnt, k)-1] << endl; //đưa ra kết quả
    }
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        solve ();
    }
    return 0;
}
284. DSA07015	TÍNH TOÁN GIÁ TRỊ BIỂU THỨC TRUNG TỐ
/*Cho biểu thức trung tố S với các toán tử +, -, *, / và dấu ngoặc (). Các toán hạng là các số có giá trị không vượt quá
100. Hãy tính giá trị biểu thức S. Phép chia thực hiện với số nguyên, input đảm bảo số bị chia luôn khác 0, đáp số biểu
thức có không quá 10 chữ số.
Input:
Dòng đầu tiên là số lượng bộ test (T ≤ 100).
Mỗi dòng gồm một xâu S, không quá 100 kí tự. Các toán hạng là các số nguyên không âm.
Output:
Input                 Output
4
6*3+2-(6-4/2)         16
100+99*22             2278
6*((4*3)+5)           102
1-2                   -1
*/
//Ý tưởng: chuyển đổi sang biểu thức tiền tố hoặc hậu tố rồi tính
//Code:

#include <bits/stdc++.h>
using namespace std;

int comp( char x ) { //hàm so sánh độ ưu tiên của các toán tử, độ ưu tiên cao thực hiện trước
    if (x == '(') return 1;
    else if (x == '+' || x == '-') return 2;
    else if (x == '*' || x == '/') return 3;
    else return 4;
}

bool isOperator( char x ) { //hàm kiểm tra toán tử
    if (x == '+' || x == '-' || x == '*' || x == '/') return true;
    return false;
}

string str;

void init() { //hàm khởi tạo
    cin >> str;
}

void solve() { //hàm xử lý
    stack <char> stk;
    string s = "";
    for (int i = 0; i < str.length (); i++) {
        if (isdigit (str[i])) { //nếu là 1 chữ số
            s += str[i]; //thêm nó vào biểu thức hiện tại
            if (i == str.length () - 1 || !isdigit (str[i + 1])) s += '.'; //hết 1 số thì thêm ký tự . để ngắt
        } else if (str[i] == '(') stk.push (str[i]); //thêm ngoặc trái vào ngăn xếp
        else if (str[i] == ')') { //nếu gặp ngoặc phải
            while (stk.size () > 0 && stk.top () != '(') { //kiểm tra xem trước nó có toán hạng không
                s += stk.top (); //thêm các toán hạng vào biểu thức hiện tại
                stk.pop (); //xoá nó khỏi ngăn xếp
            }
            stk.pop (); //xoá dấu ngoặc trái khỏi ngăn xếp
        } else {
            while (stk.size () > 0 && comp (stk.top ()) >= comp (str[i])) { //kiểm tra độ ưu tiên của các toán tử
                s += stk.top (); //thêm toán tử vào biểu thức
                stk.pop ();
            }
            stk.push (str[i]); //thêm toán tử hiện tại vào ngăn xếp
        }
    }
    while (stk.size () > 0 && stk.top () != '(') { //đưa các toán tử còn lại vào biểu thức
        s += stk.top ();
        stk.pop ();
    }
    long val = 0; //tính toán giá trị biểu thức hậu tố
    stack <long> st;
    for (int i = 0; i < s.length (); i++) {
        if (isOperator (s[i])) {
            long x = st.top ();
            st.pop ();
            long y = st.top ();
            st.pop ();
            if (s[i] == '+') st.push (y + x);
            else if (s[i] == '-') st.push (y - x);
            else if (s[i] == '*') st.push (y * x);
            else st.push (y / x);
        } else if (s[i] == '.') {
            st.push (val);
            val = 0;
        } else val = val * 10 + (s[i] - 48);
    }
    cout << st.top () << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
285. DSA08011	KHOẢNG CÁCH XÂU KÝ TỰ
/*Cho tập n xâu ký tự S và hai xâu s, t Î S. Ta giả thiết các xâu ký tự S[i] Î S có độ dài bằng nhau.  Hãy tìm khoảng
cách đường đi ngắn nhất từ s đến t. Biết từ một xâu ký tự bất kỳ ta chỉ được phép dịch chuyển đến xâu khác với nó duy
nhất 1 ký tự. Ví dụ ta có tập các từ S = { POON, TOON, PLEE, SAME, POIE, PLEA, PLIE, POIN }, s = TOON, t = PLEA ta có độ
dài đường đi ngắn nhất là 7 tương ứng với các phép dịch chuyển : TOON -> POON –> POIN –> POIE –> PLIE –> PLEE –> PLEA.
Input:
Dòng đầu tiên đưa vào số lượng test T (T≤100).
Mỗi test được tổ chức thành 2 dòng. Dòng thứ nhất ghi lại n là số từ trong S và hai từ s, t.  Dòng thứ 2 đưa vào n xâu
xâu ký tự của S; các xâu ký tự được viết cách nhau một vài khoảng trống, có độ dài không vượt quá 10 kí tự.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                                        Output
1
8 TOON  PLEA                                 7
POON TOON PLEE SAME  POIE  PLEA  PLIE  POIN
*/
//Ý tưởng: sử dụng bfs
//Code:

#include <bits/stdc++.h>
using namespace std;

int n;
string start, target;
set <string> s;
set <string> ::iterator it;

void init() { //hàm khởi tạo
    cin >> n;
    s.clear();
    cin.ignore();
    cin >> start >> target;
    for (int i = 0; i < n; i ++) {
        cin.ignore();
        string str;
        cin >> str;
        s.insert(str);
    }
}

int bfs() { //hàm bfs
    if (start == target) return 0; //nếu bắt đầu bằng kết thúc thì trả về 0
    map <string, vector <string>> umap; //map dùng để lưu các chuỗi kề nhau (khác nhau 1 ký tự)
    for (it = s.begin(); it != s.end(); it ++) {
        string word = *it;
        for (int j = 0; j < word.size(); j ++) {
            string str = word.substr(0, j) + "*" + word.substr(j + 1); //xoá đi 1 ký tự đặt nó bằng *
            umap[str].push_back(word); //tạo ma trận kề
        }
    }
    queue <pair <string, int>> q;
    map <string, int> vs; //map dùng để đánh dấu các chuỗi đã được duyệt qua
    q.push({start, 1}); //thêm chuỗi bắt đầu vào hàng đợi
    vs[start] = 1;
    while (! q.empty()) {
        string word = q.front().first;
        int dist = q.front().second;
        q.pop();
        if (word == target) return dist; //nếu tìm được xâu cuối cùng trả về kết quả
        for (int i = 0; i < word.size(); i ++) {
            string str = word.substr(0, i) + "*" + word.substr(i + 1);
            vector <string> v = umap[str];
            for (int j = 0; j < v.size(); j ++) { //tìm tất cả những từ mà word có thể duyệt tới
                if (vs[v[j]] == 0) { //nếu tìm thấy
                    vs[v[j]] = 1; //đánh dấu đã thăm
                    q.push({v[j], dist + 1}); //thêm từ đó vào hàng đợi
                }
            }
        }
    }
    return 0;
}

void solve() { //hàm xử lý
    cout << bfs () << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
286. DSA08013	DI CHUYỂN TRÁNH VẬT CẢN
/*Cho một bảng kích thước N x N, trong đó có các ô trống ‘.’ và vật cản ‘X’. Các hàng và các cột được đánh số từ 0.
Mỗi bước di chuyển, bạn có thể đi từ ô (x, y) tới ô (u, v) nếu như 2 ô này nằm trên cùng một hàng hoặc một cột, và không
có vật cản nào ở giữa.
Cho điểm xuất phát và điểm đích. Bạn hãy tính số bước di chuyển ít nhất?
Input:
Dòng đầu ghi số bộ test (không quá 10). Mỗi test gồm:
Dòng đầu tiên là số nguyên dương N (1 ≤ N ≤ 100).
N dòng tiếp theo, mỗi dòng gồm N kí tự mô tả bảng.
Cuối cùng là 4 số nguyên a, b, c, d với (a, b) là tọa độ điểm xuất phát, (c, d) là tọa độ đích. Dữ liệu đảm bảo hai vị
trí này không phải là ô có vật cản.
Output:
Với mỗi test, in ra một số nguyên là đáp số của bài toán.
Input                 Output
1
3                     3
.X.
.X.
...
0 0 0 2
*/
//Ý tưởng: sử dụng bfs
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, start_row, start_col, dest_row, dest_col, vs[105][105];
char a[105][105];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i ++) {
        cin.ignore();
        string str;
        cin >> str;
        for (int j = 0; j < n; j ++) a[i][j] = str[j];
    }
    cin >> start_row >> start_col >> dest_row >> dest_col;
    memset(vs, 0, sizeof(vs)); //đánh dấu tất cả vị trí chưa được thăm
    vs[start_row][start_col] = 1; //đánh dấu vị trí xuất phát đã được thăm
}

int bfs() { //hàm bfs
    queue <pair <int, int> > q;
    q.push ({start_row, start_col}); //thêm điểm xuất phát vào hàng đợi
    while (!q.empty ()) {
        int row = q.front ().first;
        int col = q.front ().second;
        q.pop ();
        for (int i = row - 1; i >= 0; i--) { //thêm tất cả các điểm khác X theo 4 hướng vào hàng đợi, đến X thì dừng
            if (a[i][col] == 'X') break; //dừng lại do bị cản
            else {
                if (vs[i][col] == 0) {
                    vs[i][col] = vs[row][col] + 1; //đánh dấu đã thăm
                    q.push ({i, col}); // thêm vào hàng đợi
                }
            }
        }
        for (int i = row + 1; i < n; i++) {
            if (a[i][col] == 'X') break;
            else {
                if (vs[i][col] == 0) {
                    vs[i][col] = vs[row][col] + 1;
                    q.push ({i, col});
                }
            }
        }
        for (int i = col - 1; i >= 0; i--) {
            if (a[row][i] == 'X') break;
            else {
                if (vs[row][i] == 0) {
                    vs[row][i] = vs[row][col] + 1;
                    q.push ({row, i});
                }
            }
        }
        for (int i = col + 1; i < n; i++) {
            if (a[row][i] == 'X') break;
            else {
                if (vs[row][i] == 0) {
                    vs[row][i] = vs[row][col] + 1;
                    q.push ({row, i});
                }
            }
        }
        if (vs[dest_row][dest_col] != 0) return vs[dest_row][dest_col] - 1; //nếu đến đích trả về kết quả
    }
}

void solve() { //hàm xử lý
    cout << bfs () << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
287. DSA08014	GIEO MẦM
/*Trên một giá có kích thước R x C (R hàng, C cột), một số hạt mầm đã được tra vào các ô. Một số hạt mầm được bón thêm
chất dinh dưỡng, nên đã nảy mầm sớm thành cây non.
Mỗi ngày, các cây non sẽ lan truyền chất dinh dưỡng của nó cho các mầm ở ô xung quanh (trái, trên, phải, dưới), làm cho
các hạt mầm này phát triển thành cây non. Tuy nhiên, có thể có một số hạt mầm được gieo ở vị trí lẻ loi, do không nhận
được chất dinh dưỡng nên không thể nảy mầm.
Các bạn hãy xác định xem cần ít nhất bao nhiêu ngày để tất cả các hạt đều mầm?
Input:
Dòng đầu ghi số bộ test (không quá 10). Mỗi bộ test gồm:
Dòng đầu tiên gồm 2 số nguyên R và C (1 ≤ R, C ≤ 500).
R dòng tiếp theo, mỗi dòng gồm C số nguyên A[i][j].
A[i][j] = 0, ô (i, j) là ô trống.
A[i][j] = 1, ô (i, j) là hạt chưa nảy mầm.
A[i][j] = 2, ô (i, j) là cây non.
Output:
Với mỗi test in ra thời gian ngắn nhất để tất cả các hạt đều nảy mầm. Nếu có hạt nào chưa nảy mầm, in ra -1.
Input                 Output
2
3 5                   2
2 1 0 2 1
1 0 1 2 1
1 0 0 2 1
3 5                   -1
2 1 0 2 1
0 0 1 2 1
1 0 0 2 1
*/
//Ý tưởng: sử dụng bfs
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, m, cnt, res, a[505][505];
queue <pair <int, int> > q;

void init() { //hàm khởi tạo
    while (!q.empty ()) q.pop (); //làm trống hàng đợi
    cin >> n >> m;
    cnt = 0, res = 1;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++) {
            cin >> a[i][j];
            if (a[i][j] == 1) cnt++; //tăng số hạt mầm
            else if (a[i][j] == 2) q.push ({i, j}); //thêm cây cây non vào hàng đợi
        }
}

int bfs() { //hàm bfs
    int tmp = q.size(); //khởi tạo số cây non
    while (! q.empty()) {
        tmp --;
        int i = q.front().first; //lấy ra cây ở đầu
        int j = q.front().second;
        q.pop();
        //tìm ở 4 hướng của cây con
        if (i > 0 && a[i - 1][j] == 1) { //nếu tìm thấy hạt mầm
            a[i - 1][j] = 2; //chuyển thành cây con
            cnt --; //giảm số cây con
            q.push({i - 1, j});
        }
        if (j > 0 && a[i][j - 1] == 1) {
            a[i][j - 1] = 2;
            cnt --;
            q.push({i, j - 1});
        }
        if (i < n - 1 && a[i + 1][j] == 1) {
            a[i + 1][j] = 2;
            cnt --;
            q.push({i + 1, j});
        }
        if (j < m - 1 && a[i][j + 1] == 1) {
            a[i][j + 1] = 2;
            cnt --;
            q.push({i, j + 1});
        }
        if (cnt == 0) return res; //nếu tất cả đã nảy mầm thì trả về kết quả
        if (tmp == 0) { //nếu đã lan truyền hết cây con của hàng hôm nay
            tmp = q.size(); //đi đến ngày hôm sau
            res ++; //tăng số ngày lên
        }
    }
    return - 1; //nếu không thể nảy đưa ra -1
}
void solve() {
    cout << bfs() << endl;
}

int main() {
    int t;
    cin >> t;
    while (t --) {
        init();
        solve();
    }
    return 0;
}
288. DSA08015	DI CHUYỂN TRONG KHÔNG GIAN
/*Cho một hình hộp chữ nhật có kích thước A x B x C, trong đó A là chiều cao, B là chiều rộng và C là chiều dài. Mỗi ô
có thể là một ô trống ‘.’ hoặc vật cản ‘#’.
Mỗi bước, bạn được phép di chuyển sang một ô kề bên cạnh (không được đi chéo). Nhiệm vụ của bạn là tìm đường đi ngắn
nhất bắt đầu ‘S’ tới vị trí kết thúc ‘E’.
Input:
Dòng đầu tiên là số lượng bộ test T (1 ≤ N ≤ 50).
Mỗi test bắt đầu bởi 3 số nguyên A, B, C (A, B, C ≤ 30).
Tiếp theo là A khối, mỗi khối gồm B x C kí tự mô tả một lát cắt của hình hộp chữ nhật. Giữa 2 khối có một dấu xuống dòng.
Output:
In ra một số nguyên là đường đi ngắn nhất từ S tới E. Nếu không di chuyển được, in ra -1.
Input                 Ouput
2
3 4 5                 11
S....
.###.
.##..

###.#
#####
#####

##.##
##...
#####

#####
#.###
####E
1 3 3                 -1
S##

#E#

###
*/
//Ý tưởng: sử dụng bfs
//Code:

#include <bits/stdc++.h>
using namespace std;

int a, b, c, vs[30][30][30];
char d[30][30][30];
int row[] = {-1, 0, 0, 1};
int col[] = {0, -1, 1, 0};

bool check(int x, int y) { //hàm kiểm tra xem tạo độ có thuộc hình hộp không
    if (x < 0 || y < 0 || x >= b || y >= c) return false;
    return true;
}

struct item {
    int fi, se, th;
};

item s,e;

void init() { //hàm khởi tạo
    cin >> a >> b >> c;
    for (int i = 0; i < a; i++)
        for (int j = 0; j < b; j++)
            for (int k = 0; k < c; k++) {
                cin >> d[i][j][k];
                if (d[i][j][k] == 'S') s = {i, j, k};
                if (d[i][j][k] == 'E') e = {i, j, k};
            }
}

int bfs() { //hàm bfs
    queue <item> q;
    q.push ({s.fi, s.se, s.th}); //thêm điểm xuất phát vào hàng đợi
    vs[s.fi][s.se][s.th] = 1; //đánh dấu nó đã được thăm
    while (!q.empty ()) {
        item tmp = q.front ();
        q.pop ();
        //đi đến miếng đằng trước của hình hộp
        if (tmp.fi > 0 && d[tmp.fi - 1][tmp.se][tmp.th] != '#' && vs[tmp.fi - 1][tmp.se][tmp.th] == 0) {
            vs[tmp.fi - 1][tmp.se][tmp.th] = vs[tmp.fi][tmp.se][tmp.th] + 1;
            q.push ({tmp.fi - 1, tmp.se, tmp.th});
        }
        //đi đến miếng đằng sau của hình hộp
        if (d[tmp.fi + 1][tmp.se][tmp.th] != '#' && tmp.fi + 1 < a && vs[tmp.fi + 1][tmp.se][tmp.th] == 0) {
            vs[tmp.fi + 1][tmp.se][tmp.th] = vs[tmp.fi][tmp.se][tmp.th] + 1;
            q.push ({tmp.fi + 1, tmp.se, tmp.th});
        }
        //thử 4 hướng với miếng hiện tại của hình hộp
        for (int i = 0; i < 4; i++) {
            int x = tmp.se + row[i];
            int y = tmp.th + col[i];
            if (check (x, y) && d[tmp.fi][x][y] != '#' && vs[tmp.fi][x][y] == 0) {
                vs[tmp.fi][x][y] = vs[tmp.fi][tmp.se][tmp.th] + 1;
                q.push ({tmp.fi, x, y});
            }
        }
        if (vs[e.fi][e.se][e.th] != 0) return vs[e.fi][e.se][e.th] - 1; //nếu tìm được đích trả về kết quả
    }
    return -1; //nếu không đến được đích trả về -1
}

void solve() { //hàm xử lý
    for (int i = 0; i < a; i++)
        for (int j = 0; j < b; j++)
            for (int k = 0; k < c; k++) vs[i][j][k] = 0; //đánh dấu tất cả chưa được thăm
    cout << bfs () << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
289. DSA08045	HÀNG RÀO
290. DSA07022	PHẦN TỬ CÓ SỐ LẦN XUẤT HIỆN NHIỀU HƠN BÊN PHẢI
/*Cho mảng A[]  gồm n phần tử. Nhiệm vụ của bạn là tìm phần tử gần nhất phía bên phải có số lần xuất hiện lớn hơn phần
tử hiện tại. Nếu không có phần tử nào có số lần xuất hiện lớn hơn phần tử hiện tại hãy đưa ra -1.
Ví dụ với dãy A[] = {1, 1, 2, 3, 4, 2, 1 }, ta nhận được kết quả ans[] = {-1, -1, 1, 2, 2, 1, -1} vì số lần xuất hiện
mỗi phần tử trong mảng là F = {3, 3, 2, 1, 1, 2, 3} vì vậy phần tử A[0] = 1 có số lần xuất hiện là 3 và không có phần tử
nào xuất hiện nhiều hơn 3 nên ans[0] = -1, tương tự như vậy với A[2]=2 tồn tại A[6] =1 có số lần xuất hiện là 3 nên
ans[2] = 1.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T;
Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test gồm hai dòng, dòng đầu tiên đưa vào số n là số các phần
tử của mảng A[]; dòng tiếp theo đưa vào n số của mảng A[]; các phần tử được viết cách nhau một vài khoảng trống.
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Ràng buộc:
T, n, A[i] thỏa mãn ràng buộc: 1≤T≤100; 0≤n, A[i]≤106.
Input                 Output
1
7                     -1 -1 1 2 2 1 -1
1  1  2  3  4  2  1
*/
//Ý tưởng: sử dụng mảng đánh dấu và ngăn xếp lưu lại phần tử bên phải có số lần xuấn hiện theo thứ tự giảm dần
//Code:

#include <bits/stdc++.h>
using namespace std;

long n, a[100000], cnt[1000000];
vector <long> res;

void init() { //hàm khởi tạo
    cin >> n;
    memset(cnt, 0, sizeof(cnt)); //đánh dấu số lần xuất hiện của tất cả các số bằng 0
    for (long i = 0; i < n; i ++) {
        cin >> a[i];
        cnt[a[i]] ++; //tăng số lần xuất hiện của số hiện tại
    }
}

void solve() { //hàm xử lý
    res.clear (); /làm
    mới
    kết quả
    stack <long> s;
    s.push (a[n - 1]); //đưa phần tử cuối cùng vào ngăn xếp
    for (long i = n - 1; i >= 0; i--) {
        while (!s.empty () && cnt[s.top ()] <= cnt[a[i]]) s.pop (); //tìm phần tử có số lần xuất hiện nhiều hơn 
        if (!s.empty ()) res.push_back (s.top ()); //nếu tìm được thêm phần tử đó vào kết quả
        else res.push_back (-1); //nếu không tìm được thêm -1 vào kết quả
        s.push (a[i]); //đẩy phần tử hiện tại vào ngăn xếp
    }
    for (long i = res.size () - 1; i >= 0; i--) cout << res[i] << " "; //đưa ra kết quả
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
291. DSA11026	DUYỆT SAU CÂY TÌM KIẾM CÂN BẰNG
/*Hãy xây dựng một cây nhị phân tìm kiếm cân bằng từ dãy số A[] =(a0, a1, .., an-1}. Đưa ra phép duyệt theo thứ tự sau
(post-order) của cây tìm kiếm cân bằng.  Ví dụ với dãy A[]={40, 28, 45, 38, 33, 15, 25, 20, 23, 35, 30} ta sẽ có phép
duyệt theo thứ tự trước của cây nhị phân tìm kiếm cân bằng với node gốc là 33:15, 23, 20, 30, 28, 25, 35, 38, 45, 40, 33
Input:
Dòng đầu tiên đưa vào số lượng bộ test T (T≤100).
Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất là số tự nhiên N (N≤106). Dòng tiếp theo là
N số của mảng A[].
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                                     Output
2
11                                        20 15 28 25 23 35 33 45 40 38 30
40  28  45 38  33  15  25  20  23  35  30
10                                        1 4 3 2 7 6 10 9 8 5
1  2  3  4  5  6  7  8  9  10 
*/
//Ý tưởng: phần tử chính giữa trên mảng inorder là gốc của cây con hiện tại
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, a[1005];

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void printPostOrder(int start, int end) { //hàm in theo thứ tự sau
    if (start > end) return; //nếu cây không tồn tại thì dừng lại
    int size = end - start + 1; //tìm độ rộng của cây hiện tại
    int rootIndex = start + size / 2; //tìm vị trí giữa của cây
    if (size % 2 == 0) rootIndex--; 
    printPostOrder (start, rootIndex - 1); //in cây con bên trái
    printPostOrder (rootIndex + 1, end); //in cây con bên phải
    cout << a[rootIndex] << " "; //in ra gốc của cây hiện tại
}

void solve() { //hàm xử lý
    sort (a, a + n); //đưa về thứ tự duyệt inorder
    printPostOrder (0, n - 1); //đưa ra kết quả
    cout << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
292. DSA11027	ĐẾM SỐ NODE LÁ CÂY NHỊ PHÂN TÌM KIẾM CÂN BẰNG
/*Hãy xây dựng một cây nhị phân tìm kiếm cân bằng từ dãy số A[] =(a0, a1, .., an-1}. Đếm số node lá của cây nhị phân tìm
kiếm cân bằng.  Ví dụ với dãy A[]={40, 28, 45, 38, 33, 15, 25, 20, 23, 35, 30} ta sẽ có phép duyệt theo thứ tự trước của
cây nhị phân tìm kiếm cân bằng với số node lá là 5 : 15, 23, 30, 35 45.
Input:
Dòng đầu tiên đưa vào số lượng bộ test T (T≤100).
Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất là số tự nhiên N (N≤1000). Dòng tiếp theo là
N số của mảng A[].
Output:
Đưa ra kết quả mỗi test theo từng dòng.
Input                            Output
2
11                               4
40 28 45 38 33 15 25 20 23 35 30
10                               4
1 2 3 4 5 6 7 8 9 10
*/
//Ý tưởng: nếu cây có độ rộng là 1 thì đó là lá
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, a[1005], res;

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
}

void preOrder(int start, int end) { //hàm duyệt theo thứ tự trước
    if (start > end) return; //nếu cây không tồn tại thì dừng lại
    if (start == end) res++; //nếu cây có độ rộng là 1 thì đó là lá
    int size = end - start + 1; //tìm độ rộng của cây hiện tại
    int rootIndex = start + size / 2; //tìm vị trí gốc của cây hiên tại
    if (size % 2 == 0) rootIndex--;
    preOrder (start, rootIndex - 1); //tìm ở cây con bên trái
    preOrder (rootIndex + 1, end); //tìm ở cây con bên phải
}

void solve() { //hàm xử lý
    res = 0; //khởi tạo kết quả
    sort (a, a + n); //đưa về mảng inorder
    preOrder (0, n - 1); //duyệt theo thứ tự trước
    cout << res << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
293. DSA11030	KHOẢNG CÁCH GIỮA HAI NODE
/*Cho một cây có N node, gốc tại 1. Có Q truy vấn, mỗi truy vấn yêu cầu bạn tìm khoảng cách giữa hai node u và v.
Input:
Dòng đầu tiên là số lượng bộ test T( T≤ 20).
Mỗi test bắt đầu bằng số nguyên N (1 ≤ N ≤ 1000). N-1 dòng tiếp theo, mỗi dòng gồm 2 số nguyên u, v cho biết node u nối
với node v.
Dòng tiếp theo là số lượng truy vấn Q (1 ≤ Q ≤ 1000). Q dòng tiếp theo, mỗi dòng gồm 2 số nguyên u và v.
Output:
Với mỗi test, in ra Q dòng là đáp án với mỗi truy vấn.
Input                 Output
1
8
1 2
1 3
2 4
2 5
3 6
3 7
6 8
5
4 5                   2
4 6                   4
3 4                   3
2 4                   1
8 5                   5
*/
//Ý tưởng: sử dụng bfs tìm đường đi ngắn nhất giữa 2 đỉnh
//Code:

#include <bits/stdc++.h>
using namespace std;

int n, Q, u, v, vs[1005];
vector <int> a[1005];

void init() { //hàm khởi tạo
    cin >> n;
    int x, y;
    for (int i = 1; i < n; i++) {
        cin >> x >> y;
        a[x].push_back (y); //tạo ma trận kề
        a[y].push_back (x);
    }
    cin >> Q;
}

int bfs() { //hàm bfs
    if (u == v) return 0; 
    queue <pair <int, int> > q;
    q.push ({u, 0}); //đưa điểm xuất phát vào hàng đợi
    vs[u] = 1; //đánh dấu đã duyệt qua
    while (!q.empty ()) { 
        u = q.front ().first; 
        int cnt = q.front ().second + 1;
        q.pop ();
        for (int i = 0; i < a[u].size (); i++) { //tìm đến tất cả các đỉnh kề với u mà chưa được thăm
            int tmp = a[u][i];
            if (!vs[tmp]) { 
                if (tmp == v) return cnt; //nếu là đích trả về kết  quả
                else { //nếu không phải đích
                    vs[tmp] = 1; //đánh dấu đã thăm
                    q.push ({tmp, cnt}); //thêm nó vào hàng đợi
                }
            }
        }
    }
}

void solve() { //hàm xử lý
    while (Q--) {
        cin >> u >> v;
        memset (vs, 0, sizeof (vs)); //đánh dấu tất cả các điểm chưa được thăm
        cout << bfs () << endl; //đưa ra kết quả
    }
    for (int i = 1; i <= n; i++) a[i].clear (); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
294. DSA04030	SỐ TRIBONACCI
#include <bits/stdc++.h>
const long long MOD = 1000000000000007ll;
using namespace std;

struct mat {
    long long a[4][4];
} a, b;
int t, n;
long long F[5], T[5];

long long mul(long long a, long long b) {
    long long c = 0;
    while (b) {
        if (b & 1) {
            c += a;
            if (c >= MOD) c -= MOD;
        }
        a += a; if (a >= MOD) a -= MOD;
        b /= 2;
    }
    return c;
}

mat operator * (mat a, mat b) {
    mat c;
    for(int i = 0; i < 4; i++)
        for(int j = 0; j < 4; j++) {
            c.a[i][j] = 0;
            for(int k = 0; k < 4; k++)
                c.a[i][j] = (c.a[i][j] + mul(a.a[i][k], b.a[k][j])) % MOD;
        }
    return c;
}

mat POW(int p) {
    if (p == 1) return a;
    mat x = POW(p / 2);
    x = x * x;
    if (p & 1) x = x * a;
    return x;
}

int main() {
    scanf("%d", &t);
    a.a[0][0] = a.a[0][1] = a.a[1][1] = a.a[1][2] = a.a[1][3] = a.a[2][1] = a.a[3][2] = 1;
    F[1] = 1; F[2] = 3; F[3] = 6; T[1] = 1; T[2] = 2; T[3] = 3;
    while (t--) {
        scanf("%d", &n);
        if (n <= 3) printf("%lld\n", F[n]);
        else {
            b = POW(n - 2);
            printf("%lld\n", (F[2] * b.a[0][0] + T[3] * b.a[0][1] + T[2] * b.a[0][2] + T[1] * b.a[0][3]) % MOD);
        }
    }
    return 0;
}
295. DSA07045	GÕ BÀN PHÍM
/*Trong quá trình gõ một dòng văn bản, chúng ta thường sử dụng phím sang trái, sang phải hoặc xóa lùi (backspace). Cho
một dãy ký tự mô tả các thao tác gõ phím, trong đó:
Ký tự ‘-’ mô tả phím backspace (xóa lùi). Ký tự ở phía trước con trỏ (nếu có) sẽ bị xóa.
Ký tự ‘<’ mô tả phím di chuyển sang trái. Con trỏ sẽ sang trái 1 ký tự nếu có thể.
Ký tự ‘>’ mô tả phím di chuyển sang phải. Con trỏ sẽ sang phải 1 ký tự nếu có thể.
Các ký tự khác là các chữ cái Tiếng Anh (in hoa hoặc in thường). Bàn phím để ở chế độ Insert. Tức là nếu con trỏ không ở
cuối dòng thì khi chèn các ký tự sẽ đẩy các ký tự khác sang phải một vị trí.
Hãy thử tính toán và viết ra kết quả tương ứng.
Input
Có một dòng không quá 106 ký tự mô tả dãy gõ bàn phím.
Output
Ghi ra kết quả.
Input                Output
<<PI<T>>Ta-          PTIT
*/
//Ý tưởng: lưu trữ các phần tử đằng sau con trỏ bằng ngăn xếp, các ký tự trước nó bằng hàng đợi 2 đầu
#include<bits/stdc++.h>
using namespace std;

string str;

void init(){
    cin >> str;
}

void solve(){ //hàm xử lý
    deque <char> q;
    stack <char> s;
    string res = ""; //khởi tạo kết quả
    for (long long i = 0; i < str.length(); i ++) {
        if (str[i] == '-' && ! q.empty()) q.pop_back(); //loại bỏ phần tử ở trước con trỏ
        else if (! q.empty() > 0 && str[i] == '<') { //nếu gặp ký tự đi lùi
            s.push(q.back()); //thêm phần tử bị lùi vào ngăn xếp
            q.pop_back(); //xoá phần tử đó khỏi hàng đợi
        } else if (! s.empty() && str[i] == '>') { //nếu gặp ký tự đi tiến
            q.push_back(s.top()); //thêm phần tử ở ngăn xếp vào hàng đợi
            s.pop();
        } else if (str[i] != '-' && str[i] != '<' && str[i] != '>') q.push_back(str[i]); //gặp ký tự thêm vào hàng đợi
    }
    while (! q.empty()) { //cập nhật kết quả
        res += q.front();
        q.pop_front();
    }
    while (! s.empty()) { //cập nhật kết quả
        res += s.top();
        s.pop();
    }
    cout << res; //đưa ra kết quả
}

int main() {
    init ();
    solve ();
    return 0;
}
296. DSA05045	BÀI TOÁN CÁI TÚI KHÔNG NGUYÊN
/*Một trong những bài toán kinh điển của lý thuyết tổ hợp là Bài toán cái túi. Bài toán được phát biểu như sau: Một nhà
thám hiểm cần đem theo một cái túi trọng lượng không quá W. Có N đồ vật cần đem theo. Đồ vật thứ i có trọng lượng A[i],
có giá trị sử dụng C[i]. Nhiệm vụ của bạn là hãy tìm cách đưa đồ vật vào túi cho nhà thám hiểm sao cho tổng giá trị sử
dụng các đồ vật trong túi là lớn nhất. Giả thiết với mỗi đồ vật, ta có thể chia nhỏ chúng ra thành nhiều phần khác nhau
(Fraction Knapsack).
Input:
Dòng đầu tiên đưa vào số lượng bộ test T.
Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất đưa vào hai số N, W tương ứng với số
lượng đồ vật và trọng lượng túi; phần thứ 2 đưa vào 2*N số tương ứng với trọng lượng đồ vật A[i] và giá trị sử dụng C[i]
của mỗi đồ vật.
T, N, W, A[i], C[i]  thỏa mãn ràng buộc: 1≤T≤100;  1≤N, W≤100; 1≤A[i], C[i]≤100.
Output:
Đưa ra kết quả mỗi test theo từng dòng, in ra 2 chữ số sau dấu phảy.
Input                 Output
2
3 50                  240.00
60 10
100 20
120 30
2 50                  160.00
60 10
100 20
*/
//Ý tưởng: thêm vào túi vật có tỉ lệ giá trị sử dụng riêng cao nhất (giá trị / trọng lượng)
//Code:

#include <bits/stdc++.h>
using namespace std;

struct data{ //kiểu dữ liệu đồ vật
    int w, c;
};

int n;
double W;
data a[105];

bool cmp(data x, data y) { //hàm so sánh giá trị sử dụng riêng
    double r1 = (double) x.c / (double) x.w;
    double r2 = (double) y.c / (double) y.w;
    if (r1 > r2) return true;
    return false;
}

void init() { //hàm khởi tạo
    cin >> n >> W;
    for (int i = 0; i < n; i++) cin >> a[i].c >> a[i].w;
}

void solve() { //hàm xử lý
    sort (a, a + n, cmp); //sắp xếp theo giá trị sử dụng riêng
    double maxValue = 0;
    for (int i = 0; i < n; i++) { //thêm nhiều nhất có thể vật có giá trị sử dụng riêng cao nhất
        if (a[i].w <= W) {
            maxValue += a[i].c;
            W -= a[i].w;
        } else {
            maxValue += a[i].c * (W / a[i].w);
            break;
        }
    }
    cout << setprecision (2) << fixed << maxValue << endl; //đưa ra kết quả
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
297. DSA09040	MÊ CUNG
298. DSA10016	NỐI ĐIỂM
/*Cho N điểm trên mặt phẳng Oxy. Để vẽ được đoạn thẳng nối A và B sẽ tốn chi phí tương đương với khoảng cách từ A tới B.
Nhiệm vụ của bạn là nối các điểm với nhau, sao cho N điểm đã cho tạo thành 1 thành phần liên thông duy nhất và chi phí
để thực hiện là nhỏ nhất có thể.
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test bắt đầu bởi số nguyên N (1 ≤ N ≤ 100).
N dòng tiếp theo, mỗi dòng gồm 2 số thực x[i], y[i] là tọa độ của điểm thứ i (|x[i]|, |y[i]| ≤ 100).
Output:
Với mỗi test, in ra chi phí nhỏ nhất tìm được với độ chính xác 6 chữ số thập phân sau dấu phẩy.
Input                 Output
1
3                     3.414214
1.0 1.0
2.0 2.0
2.0 4.0
*/
//Ý tưởng: sử dụng Kruskal tìm cây khung nhỏ nhất, chú ý đọc hiểu bài Kruskal
//Code:

#include <bits/stdc++.h>
using namespace std;

struct Point { //kiểu dữ liệu điểm
    double x, y;
};

int n, parent[105], Rank[105];
Point p[105];
vector <pair <double, pair <int, int> > >edge;

void init() { //hàm khởi tạo
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> p[i].x >> p[i].y;
}

double dist(Point a, Point b) { //hàm tính khoảng cách giữa 2 điểm
    return sqrt ((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}

int find(int i) { //hàm find trong thuật toán Kruskal
    if (i != parent[i]) parent[i] = find (parent[i]);
    return parent[i];
}

void Union(int x, int y) { //hàm Union trong thuật toán Kruskal
    if (Rank[x] > Rank[y]) parent[y] = x;
    else parent[x] = y;
    if (Rank[x] == Rank[y]) Rank[y]++;
}

void solve() {
    for (int i = 1; i < n; i++) 
        for (int j = i + 1; j <= n; j++) 
            edge.push_back ({dist (p[i], p[j]), {i, j}}); //tính khoảng cách các điểm rồi thêm vào ma trận kề
    sort (edge.begin (), edge.end ()); //sắp xếp lại theo khoảng cách
    for (int i = 1; i <= n; i++) { //sử dụng Kruskal tìm cây khung nhỏ nhất
        parent[i] = i;
        Rank[i] = 0;
    }
    double res = 0; //khởi tạo kết quả
    for (int i = 0; i < edge.size (); i++) {
        int x = find (edge[i].second.first);
        int y = find (edge[i].second.second);
        if (x != y) {
            res += edge[i].first;
            Union (x, y);
        }
    }
    cout << setprecision (6) << fixed << res << endl; //đưa ra kết quả
    edge.clear (); //làm mới ma trận kề
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        init ();
        solve ();
    }
    return 0;
}
299. DSA04019	CẶP ĐIỂM GẦN NHẤT
/*Cho N điểm trên mặt phẳng tọa độ Oxy. Bạn cần tìm khoảng cách ngắn nhất giữa hai điểm trong số N điểm đã cho.
Input:
Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
Mỗi test bắt đầu bởi một số nguyên N (1 ≤ N ≤ 100 000).
N dòng tiếp theo, mỗi dòng gồm 2 số nguyên X[i], Y[i] (-106 ≤ X[i], Y[i] ≤ 106).
Output:
Với mỗi test, in ra đáp án trên một dòng với độ chính xác 6 chữ số sau dấu phẩy.
Input                 Output
2
6                     1.414214
2 3
12 30
40 50
5 1
12 10
3 4
3                     1.000000
0 0
3 0
4 0
/*Ý tưởng: Chia N điểm cần xử lý thành 2 tập hợp bằng một đường thẳng đứng, gọi đệ quy tìm cặp điểm gần nhất cho tập bên
trái và tập bên phải, tìm khoảng cách ngắn nhất giữa một điểm thuộc tập bên trái và một điểm thuộc tập bên phải*/
//Code:

#include <bits/sdtc++.h>
using namespace std;

struct point { //kiểu dữ liệu điểm
    double x, y;
};

bool cmp_x(const point &a, const point &b) { //hàm so sánh theo x
    return a.x < b.x;
}

bool cmp_y(const point &a, const point &b) { //hàm so sánh theo y
    return a.y < b.y;
}

#define MAXN 1000005
point a[MAXN];
double mindist; // biến lưu kết quả bài toán


void upd_ans(const point &a, const point &b) { // hàm tính khoảng cách giữa a và b
    double dist = sqrt((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y)); //tính khoảng cách a và b
    if (dist < mindist) mindist = dist; //cập nhật kết quả nhỏ nhất
}

void find(int l, int r) { //hàm tìm kiếm cặp điểm gần nhất
    if (r <= l) return;
    if (r == l + 1) { // đoạn [l,r] có 2 phần tử
        upd_ans (a[l], a[r]);
        if (!cmp_y (a[l], a[r])) swap (a[l], a[r]);  // sắp các phần tử lại theo y
        return;
    }
    int m = (l + r) / 2;
    double midx = a[m].x;
    find (l, m);
    find (m + 1, r);
    static point t[MAXN];
    merge (a + l, a + m + 1, a + m + 1, a + r + 1, t, cmp_y); // trộn a[l,m] và a[m+1,r] lại, lưu vào mảng tạm t
    copy (t, t + r - l + 1, a + l);   // copy từ t về lại a
    // mảng t ở đây lưu các phần tử thỏa |x_i - midx| < mindist,
    // với số lượng phần tử là tm
    // do đã sort nên các phần tử sẽ có y tăng dần
    int tm = 0;
    for (int i = l; i <= r; i++)
        if (abs (a[i].x - midx) < mindist) {
            for (int j = tm - 1; j >= 0 && t[j].y > a[i].y - mindist; j--)
                upd_ans (a[i], t[j]);
            t[tm++] = a[i];
        }
}

int main() {
    ios::sync_with_stdio (false);
    cin.tie (0);
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        for (int i = 0; i < n; i++) cin >> a[i].x >> a[i].y;
        mindist = 1E20;
        sort (a, a + n, cmp_x); //sắp xếp các phần tử theo x
        find (0, n - 1); //gọi hàm tìm kiếm
        printf ("%.6lf\n", mindist); //đưa ra kết quả
    }
    return 0;
}
300. DSA08016	HEXGAME
//
// Created by khanhnvtb on 23/07/2021.
//
/*HEXGAME là một trò chơi xếp hình gồm 10 miếng ghép hình lục giác đều, trên mỗi miếng ghép được điền một số nguyên, có
8 miếng được điền số  từ 1 đến 8 và có hai miếng điền số 0. Các miếng liên kết với nhau tạo thành lưới tổ ong. Ban đầu
các miếng ghép ở vị trí như hình vẽ. Tại mỗi bước, chọn một miếng ghép có đúng 6 miếng ghép kề cạnh làm tâm, rồi xoay
một nấc 6 miếng ghép kề cạnh đó theo chiều kim đồng hồ. Như vậy chỉ có hai cách chọn tâm, đó là chọn tâm bên trái và
chọn tâm bên phải.
Yêu cầu: Cho một trạng thái của trò chơi (nhận được sau một dãy biến đổi từ trạng thái ban đầu), hãy tính số phép biến
đổi ít nhất để đưa về trạng thái ban đầu.
Input:
Dòng đầu ghi số bộ test (không quá 10). Mỗi bộ test gồm:
Dòng đầu tiên chứa 3 số ở 3 miếng ghép dòng thứ nhất (thứ tự từ trái qua phải).
Dòng thứ hai chứa 4 số ở 4 miếng ghép dòng thứ hai (thứ tự từ trái qua phải).
Dòng thứ 3 chứa 3 số ở 3 miếng ghép dòng thứ ba (thứ tự từ trái qua phải).
Output:
Với mỗi bộ test in ra một số nguyên là số phép biến đổi ít nhất để đưa được về trạng thái ban đầu.
Input                 Output
1
1 0 2                 5
8 6 0 3
7 5 4
*/
//Ý tưởng: sử dụng bfs và bfs 2 điểm đầu và cuối
//Code:

#include <bits/stdc++.h>
using namespace std;

string start, target;
map <string, int> mm, mE;
int res;

string leftS(string s){ //xoay phải tâm bên trái
    return string({s[3],s[0],s[2],s[7],s[4],s[1],s[6],s[8],s[5],s[9]});
}

string rightS(string s){ //xoay phải tâm bên phải
    return string ({s[0],s[4],s[1],s[3],s[8],s[5],s[2],s[7],s[9],s[6]});
}

string leftT(string s) { //xoay trái tâm bên trái
    return string ({s[1], s[5], s[2], s[0], s[4], s[8], s[6], s[3], s[7], s[9]});
}

string rightT(string s) { //xoay trái tâm bên phải
    return string ({s[0], s[2], s[6], s[3], s[1], s[5], s[9], s[7], s[4], s[8]});
}

void init() { //hàm khơi tạo
    start = "";
    for (int i = 0; i < 10; i++) {
        char x;
        cin >> x;
        start += x;
    }
}

int bfsT() { //hàm bfs cuối
    queue <string> q;
    q.push (target); //thêm điểm cuối vào hàng đợi
    while (!q.empty ()) {
        string tmp = q.front ();
        q.pop ();
        if (mm[tmp] != 0) { //trả về kết quả
            return mm[tmp] + mE[tmp];
        }
        string s1 = leftT (tmp); //xoay
        string s2 = rightT (tmp);
        if (mE[s1] == 0) { //nếu chưa đi qua
            q.push (s1); //thêm nó vào hàng đợi
            mE[s1] = mE[tmp] + 1; //cập nhật kết quả
        }
        if (mE[s2] == 0) { //nếu chưa đi qua
            q.push (s2); //thêm nó vào hàng đợi
            mE[s2] = mE[tmp] + 1; //cập nhật kết quả
        }
        if (mE[q.back ()] > 19) break; //nếu không tìm được kết quả dừng lại
    }
    return -1; //trả về -1 nếu k tìm được kết quả
}

int bfsS() { //hàm bfs đầu
    queue <string> q;
    q.push (start); //thêm điểm đầu vào hàng đợi
    while (!q.empty ()) {
        string tmp = q.front ();
        q.pop ();
        string s1 = leftS (tmp); //xoay
        string s2 = rightS (tmp);
        if (mm[s1] == 0) { //nếu chưa đi qua
            q.push (s1); //thêm nó vào hàng đợi
            mm[s1] = mm[tmp] + 1; //cập nhật kết quả
        }
        if (mm[s2] == 0) { //nếu chưa đi qua
            q.push (s2); //thêm nó vào hàng đợi
            mm[s2] = mm[tmp] + 1; //cập nhật kết quả
        }
        if (mm[target] != 0) return mm[target]; //trả về kết quả
        if (mm[q.back ()] > 13) break; //nếu không tìm được kết quả dừng lại
    }
    return -1; //trả về -1 nếu k tìm được kết quả
}

void solve() {
    mm.clear ();
    mE.clear ();
    int res = bfsS (); //cập nhật kết quả
    if (res != -1) cout << res << endl; //nếu đã có kết quả đưa ra kết quả
    else cout << bfsT () << endl; //nếu chưa có kết quả đưa ra kết quả của hàm bfs cuối
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        target = "1238004765";
        init ();
        solve ();
    }
    return 0;
}
301. DSA03033	ATM THẾ HỆ MỚI
/*Tại một cây rút tiền ATM thế hệ mới, Tý muốn rút ra W đồng. Các tờ tiền trong máy ATM có mệnh giá từ 1000, 2000, 3000,
5000, 1000*10, 2000*10, 3000*10, 5000*10, …, 1000*10c, 2000*10c, 3000*10c, 5000*10c.
Chiếc máy ATM đã được tối ưu hóa sao cho số lượng tờ tiền đưa ra cho khách hàng là nhỏ nhất.
Các bạn hãy thử tính xem Tý sẽ nhận được bao nhiêu tờ tiền? Và có bao nhiêu cách thỏa mãn?
Input
Số đầu tiên là số lượng bộ test T (T ≤ 1000). Mỗi test gồm 2 dòng:
Dòng thứ nhất chứa số nguyên W.
Dòng thứ hai chứa số nguyên c.
Output
Với mỗi test, hãy in ra số lượng tờ tiền nhỏ nhất mà máy ATM sinh ra và số tổ hợp các tờ tiền khác nhau thỏa mãn tổng
giá trị của chúng bằng W.
Nếu không có đáp án, in ra số 0 trên một dòng.
Input                 Output
4
2000                  1 1
1
7000                  2 1
1
1500                  0
1
110000                3 2
1
Subtask 1: 30% số test đầu tiên, c ≤ 5, W ≤ 109.
Subtask 2: 70% số test còn lại, c ≤ 15, W ≤ 1018.
Giải thích test 4: 2 cách tìm được là: 50000+50000+10000 và 50000+30000+30000
*/
//Ý tưởng: trả theo thứ tự từ dưới lên
//Code:

#include <bits/stdc++.h>
using namespace std;

long long w, res, cnt;
int c;

void init() {
    cin >> w >> c;
}

void solve() {
    if (w % 1000 != 0) cout << "0" << endl; //nế không thể trả đưa ra 0
    else {
        res = 0, cnt = 1; //khởi tạo kết quả
        w /= 1000; //chia cho 1000 vì tờ tiền trả lấy giá trị từ 1
        int dem = 0, prev = 0; //khởi tạo biến đếm số mũ của hàng hiện tại và số được trả trước đó
        while (w > 0) {
            if (dem <= c) { //nếu số mũ không lớn hơn số mũ của các tờ có thể trả
                int tmp = w % 10; //lấy ra chữ số hiện tại
                if (tmp == 1 || tmp == 2 || tmp == 3 || tmp == 5) res += 1; //chỉ có 1 cách trả là chính nó
                else if (tmp == 4 || tmp == 6) { //có 2 cách trả và bằng 2 tờ tiền (4=2+2=1+3 và 6=3+3=5+1)
                    res += 2;
                    cnt *= 2;
                } else if (tmp == 7 || tmp == 8) res += 2; //có 1 cách trả duy nhất bằng 2 tờ tiền (7=2+5 và 8=3+5)
                else if (tmp == 9) { //có 3 cách trả bằng 3 tờ tiền (9=1+3+5=2+2+5=3+3+3)
                    res += 3;
                    cnt *= 3;
                }
                prev = tmp; //gán giá trị trước nó
            } else if (dem == c + 1) { //nếu số mũ của hàng hiện tại lớn hơn số mũ có thể trả tối đa
                if (prev != 1 && prev != 4) { //nếu số trả trước nó khác 1 và 4 thì có thể trả các tờ mệnh giá 5
                    res += w * 2; //ví dụ 12 sẽ trả 24 tờ mệnh giá 5
                }else if (prev == 1) { //nếu trước nó là số 1
                    cnt *= 2; //có 2 cách trả
                    res += w * 2; //trả bằng các tờ mệnh giá 5 cho số tiền còn lại
                }else if (prev == 4) { //nếu trước nó là số 4
                    cnt /= 2; //chia lại cho 2 do sẽ thực hiện trả tiền lại hàng trước đó
                    cnt *= 3; // có 3 cách trả
                    res += w * 2; //trả bằng các tờ mệnh giá 5 cho số tiền còn lại
                }
                break;
            }
            dem++; //đi đến số mũ của hàng kế tiếp
            w /= 10; //đi đến hàng kế tiếp
        }
        cout << res << " " << cnt << endl; //đưa ra kết quả
    }
}

int main() {
    int t;
    cin >> t;
    while (t --) {
        init();
        solve();
    }
    return 0;
}
